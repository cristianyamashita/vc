<!DOCTYPE html>
<html lang="en" data-theme="dark">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title data-i18n="title">Prompt Concat</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="../assets/fontawesome/css/all.min.css" />
    <style>
      :root {
        --bg-color: #1a1a1a;
        --text-color: #f0f0f0;
        --card-bg-color: #2a2a2a;
        --border-color: #444;
        --accent-color: #0d6efd;
      }

      html[data-theme='light'] {
        --bg-color: #f8f9fa;
        --text-color: #212529;
        --card-bg-color: #fff;
        --border-color: #dee2e6;
        --accent-color: #0d6efd;
      }

      body {
        background-color: var(--bg-color);
        color: var(--text-color);
        display: flex;
        flex-direction: column;
        min-height: 100vh;
        margin: 0;
      }

      .container-fluid {
        padding-top: 20px;
        padding-bottom: 20px;
        flex: 1;
      }

      .card {
        background-color: var(--card-bg-color);
        border-color: var(--border-color);
      }

      .card-header {
        border-bottom-color: var(--border-color);
      }

      .navbar-brand,
      .form-label {
        color: var(--text-color);
      }

      .form-control {
        background-color: var(--card-bg-color);
        color: var(--text-color);
        border-color: var(--border-color);
      }

      .form-control:focus,
      .form-select:focus {
        background-color: var(--card-bg-color);
        color: var(--text-color);
        border-color: var(--accent-color);
        box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25);
      }

      .form-select {
        background-color: var(--card-bg-color);
        color: var(--text-color);
        border-color: var(--border-color);
      }

      .help-text {
        color: #aaa;
        font-size: 0.9rem;
      }

      textarea.form-control {
        resize: vertical;
      }

      .mono {
        font-family: 'Courier New', Courier, monospace;
      }
    </style>
  </head>
  <body>
    <nav class="navbar navbar-expand-lg" style="background-color: var(--card-bg-color); border-bottom: 1px solid var(--border-color)">
      <div class="container-fluid">
        <a class="navbar-brand" href="#" data-i18n="title">Prompt Concat</a>
        <div class="d-flex ms-auto gap-2 align-items-center">
          <select id="lang-switcher" class="form-select form-select-sm" style="width: auto;">
            <option value="en">English</option>
            <option value="pt">Português</option>
            <option value="ja">日本語</option>
          </select>
          <select id="storage-select" class="form-select form-select-sm" style="background-color: var(--card-bg-color); color: var(--text-color); border-color: var(--border-color); min-width: 150px;">
          </select>
          <button id="copy-result-btn" class="btn btn-sm btn-outline-secondary" type="button" data-i18n-title="copyResultBtn" title="Copy result">
            <i class="fas fa-copy"></i>
          </button>
          <button id="history-btn" class="btn btn-sm btn-outline-secondary" type="button" data-i18n-title="historyBtn" title="History">
            <i class="fas fa-history"></i>
          </button>
          <button id="permanent-vars-btn" class="btn btn-sm btn-outline-secondary" type="button" data-i18n-title="permanentVarsBtn" title="Permanent Variables">
            <i class="fas fa-bookmark"></i>
          </button>
          <button id="clear-btn" class="btn btn-sm btn-outline-secondary" type="button" data-i18n-title="clearBtn" title="Clear">
            <i class="fas fa-eraser"></i>
          </button>
          <button id="theme-switcher" class="btn btn-sm btn-outline-secondary" type="button" data-i18n-title="themeBtn" title="Toggle theme">
            <i class="fas fa-moon"></i>
          </button>
        </div>
      </div>
    </nav>

    <div class="container-fluid">
      <div class="row justify-content-center">
        <div class="col-xl-10 col-lg-11">
          <div class="card">
            <div class="card-header d-flex align-items-center justify-content-between">
              <h4 class="mb-0" data-i18n="title">Prompt Concat</h4>
              <div class="help-text" id="storage-scope"></div>
            </div>
            <div class="card-body">
              <div class="mb-3">
                <label for="input-template" class="form-label" data-i18n="inputLabel">Input</label>
                <textarea id="input-template" class="form-control mono" rows="4" data-i18n-placeholder="inputPlaceholder" placeholder="The {V1} is {V2} and has size {V3}, color {V4}, this is my {V1}"></textarea>
                <div class="help-text mt-1" data-i18n="placeholderHelp">Use placeholders: {V1}, {V2}, {V3}, {V4}, {V5}. # = comment. [[a, b, c]] = random pick per line (Input & V1–V5, max 100 items).</div>
                <div class="mt-2 d-flex gap-2 align-items-center flex-wrap">
                  <input type="text" id="search-input" class="form-control mono" style="max-width: 280px;" data-i18n-placeholder="searchPlaceholder" placeholder="Buscar no Input e V1–V5...">
                  <button type="button" id="search-btn" class="btn btn-sm btn-outline-primary" data-i18n="searchBtn">
                    <i class="fas fa-search"></i> <span data-i18n="searchBtn">Buscar</span>
                  </button>
                </div>
                <div id="search-results" class="mt-2 p-2 rounded" style="display: none; background-color: var(--border-color); max-height: 320px; overflow-y: auto;"></div>
                <div class="help-text mt-1" data-i18n="conditionalHelp">Conditional: IF({V1}==1,"value") | Operators: ==, !=, &lt;, &gt;, &lt;=, &gt;=, contains, &amp;&amp;, ||</div>
              </div>

              <div class="row g-3 row-cols-1 row-cols-md-2 row-cols-lg-5">
                <div class="col">
                  <label for="v1" class="form-label">V1</label>
                  <textarea id="v1" class="form-control mono" rows="5" data-i18n-placeholder="v1Placeholder" placeholder="car&#10;bicycle&#10;boat"></textarea>
                  <div class="btn-group mt-1 w-100" role="group">
                    <button class="btn btn-sm btn-outline-secondary" type="button" data-shuffle="v1" data-i18n-title="shuffleBtn" title="Shuffle lines">
                      <i class="fas fa-random"></i>
                    </button>
                    <button class="btn btn-sm btn-outline-secondary" type="button" data-sort-asc="v1" data-i18n-title="sortAscBtn" title="Sort A-Z">
                      <i class="fas fa-sort-alpha-down"></i>
                    </button>
                    <button class="btn btn-sm btn-outline-secondary" type="button" data-sort-desc="v1" data-i18n-title="sortDescBtn" title="Sort Z-A">
                      <i class="fas fa-sort-alpha-down-alt"></i>
                    </button>
                  </div>
                </div>
                <div class="col">
                  <label for="v2" class="form-label">V2</label>
                  <textarea id="v2" class="form-control mono" rows="5" data-i18n-placeholder="v2Placeholder" placeholder="modern&#10;old&#10;vintage"></textarea>
                  <div class="btn-group mt-1 w-100" role="group">
                    <button class="btn btn-sm btn-outline-secondary" type="button" data-shuffle="v2" data-i18n-title="shuffleBtn" title="Shuffle lines">
                      <i class="fas fa-random"></i>
                    </button>
                    <button class="btn btn-sm btn-outline-secondary" type="button" data-sort-asc="v2" data-i18n-title="sortAscBtn" title="Sort A-Z">
                      <i class="fas fa-sort-alpha-down"></i>
                    </button>
                    <button class="btn btn-sm btn-outline-secondary" type="button" data-sort-desc="v2" data-i18n-title="sortDescBtn" title="Sort Z-A">
                      <i class="fas fa-sort-alpha-down-alt"></i>
                    </button>
                  </div>
                </div>
                <div class="col">
                  <label for="v3" class="form-label">V3</label>
                  <textarea id="v3" class="form-control mono" rows="5" data-i18n-placeholder="v3Placeholder" placeholder="large&#10;small"></textarea>
                  <div class="btn-group mt-1 w-100" role="group">
                    <button class="btn btn-sm btn-outline-secondary" type="button" data-shuffle="v3" data-i18n-title="shuffleBtn" title="Shuffle lines">
                      <i class="fas fa-random"></i>
                    </button>
                    <button class="btn btn-sm btn-outline-secondary" type="button" data-sort-asc="v3" data-i18n-title="sortAscBtn" title="Sort A-Z">
                      <i class="fas fa-sort-alpha-down"></i>
                    </button>
                    <button class="btn btn-sm btn-outline-secondary" type="button" data-sort-desc="v3" data-i18n-title="sortDescBtn" title="Sort Z-A">
                      <i class="fas fa-sort-alpha-down-alt"></i>
                    </button>
                  </div>
                </div>
                <div class="col">
                  <label for="v4" class="form-label">V4</label>
                  <textarea id="v4" class="form-control mono" rows="5" data-i18n-placeholder="v4Placeholder" placeholder="yellow&#10;red"></textarea>
                  <div class="btn-group mt-1 w-100" role="group">
                    <button class="btn btn-sm btn-outline-secondary" type="button" data-shuffle="v4" data-i18n-title="shuffleBtn" title="Shuffle lines">
                      <i class="fas fa-random"></i>
                    </button>
                    <button class="btn btn-sm btn-outline-secondary" type="button" data-sort-asc="v4" data-i18n-title="sortAscBtn" title="Sort A-Z">
                      <i class="fas fa-sort-alpha-down"></i>
                    </button>
                    <button class="btn btn-sm btn-outline-secondary" type="button" data-sort-desc="v4" data-i18n-title="sortDescBtn" title="Sort Z-A">
                      <i class="fas fa-sort-alpha-down-alt"></i>
                    </button>
                  </div>
                </div>
                <div class="col">
                  <label for="v5" class="form-label">V5</label>
                  <textarea id="v5" class="form-control mono" rows="5" placeholder=""></textarea>
                  <div class="btn-group mt-1 w-100" role="group">
                    <button class="btn btn-sm btn-outline-secondary" type="button" data-shuffle="v5" data-i18n-title="shuffleBtn" title="Shuffle lines">
                      <i class="fas fa-random"></i>
                    </button>
                    <button class="btn btn-sm btn-outline-secondary" type="button" data-sort-asc="v5" data-i18n-title="sortAscBtn" title="Sort A-Z">
                      <i class="fas fa-sort-alpha-down"></i>
                    </button>
                    <button class="btn btn-sm btn-outline-secondary" type="button" data-sort-desc="v5" data-i18n-title="sortDescBtn" title="Sort Z-A">
                      <i class="fas fa-sort-alpha-down-alt"></i>
                    </button>
                  </div>
                </div>
              </div>

              <hr class="my-4" />

              <div class="mb-2 d-flex align-items-center justify-content-between gap-2">
                <label for="result" class="form-label mb-0" data-i18n="resultLabel">Result</label>
                <div class="help-text">
                  <span id="result-count">0</span> <span data-i18n="linesText">lines</span>
                </div>
              </div>
              <textarea id="result" class="form-control mono" rows="10" readonly></textarea>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- History Modal -->
    <div class="modal fade" id="history-modal" tabindex="-1">
      <div class="modal-dialog">
        <div class="modal-content" style="background-color: var(--card-bg-color); color: var(--text-color); border-color: var(--border-color);">
          <div class="modal-header" style="border-bottom-color: var(--border-color);">
            <h5 class="modal-title" data-i18n="historyTitle">History</h5>
            <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
          </div>
          <div class="modal-body">
            <div id="history-list"></div>
            <div id="history-empty" class="text-muted text-center py-3" data-i18n="historyEmpty">No history entries</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Permanent Variables Modal -->
    <div class="modal fade" id="permanent-vars-modal" tabindex="-1">
      <div class="modal-dialog modal-lg">
        <div class="modal-content" style="background-color: var(--card-bg-color); color: var(--text-color); border-color: var(--border-color);">
          <div class="modal-header" style="border-bottom-color: var(--border-color);">
            <h5 class="modal-title" data-i18n="permanentVarsTitle">Permanent Variables</h5>
            <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
          </div>
          <div class="modal-body">
            <div id="permanent-vars-rows"></div>
            <button type="button" id="permanent-vars-add-row" class="btn btn-sm btn-outline-primary mt-2" data-i18n="permanentVarsAdd">
              <i class="fas fa-plus"></i> <span data-i18n="permanentVarsAdd">Add</span>
            </button>
          </div>
          <div class="modal-footer" style="border-top-color: var(--border-color);">
            <button type="button" class="btn btn-primary" id="permanent-vars-save" data-i18n="permanentVarsSave">Save</button>
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
          </div>
        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
      const i18n = {
        en: {
          title: "Prompt Concat",
          inputLabel: "Input",
          inputPlaceholder: "The {V1} is {V2} and has size {V3}, color {V4}, this is my {V1}",
          placeholderHelp: "Use placeholders: {V1}, {V2}, {V3}, {V4}, {V5}. {{ID}} = permanent variable (same across storages). # = comment. [[a, b, c]] = random pick per line (Input & V1–V5, max 100 items).",
          conditionalHelp: "Conditional: IF({V1}==1,\"value\") | Operators: ==, !=, <, >, <=, >=, contains, &&, ||",
          v1Placeholder: "car\nbicycle\nboat",
          v2Placeholder: "modern\nold\nvintage",
          v3Placeholder: "large\nsmall",
          v4Placeholder: "yellow\nred",
          shuffleBtn: "Shuffle",
          sortAscBtn: "Sort A-Z",
          sortDescBtn: "Sort Z-A",
          resultLabel: "Result",
          linesText: "lines",
          copyResultBtn: "Copy result",
          clearBtn: "Clear",
          clearConfirm: "Clear all Input and V1–V5 content?",
          themeBtn: "Toggle theme",
          storageText: "storage",
          historyBtn: "Manage",
          historyTitle: "Manage Storages",
          historyEmpty: "No entries to manage",
          loadBtn: "Load",
          renameBtn: "Rename",
          deleteBtn: "Delete",
          renamePrompt: "Enter new name:",
          deleteConfirm: "Delete this history entry?",
          searchPlaceholder: "Search in Input and V1–V5...",
          searchBtn: "Search",
          searchFoundIn: "Found in",
          searchPromptsContaining: "Prompts containing:",
          openInNewTab: "Open in new tab",
          searchNoResults: "No matches",
          searchLineLabel: "line",
          searchOtherStorages: "other storages",
          permanentVarsBtn: "Permanent Variables",
          permanentVarsTitle: "Permanent Variables",
          permanentVarsAdd: "Add",
          permanentVarsSave: "Save",
          permanentVarsId: "ID",
          permanentVarsValue: "Value"
        },
        pt: {
          title: "Prompt Concat",
          inputLabel: "Entrada",
          inputPlaceholder: "O {V1} é {V2} e tem o tamanho {V3}, da cor {V4}, esse é o meu {V1}",
          placeholderHelp: "Placeholders: {V1}, {V2}, {V3}, {V4}, {V5}. {{ID}} = variável permanente (igual em todos os storages). # = comentário. [[a, b, c]] = escolha aleatória por linha (Input e V1–V5, máx. 100 itens).",
          conditionalHelp: "Condicional: IF({V1}==1,\"valor\") | Operadores: ==, !=, <, >, <=, >=, contains, &&, ||",
          v1Placeholder: "carro\nbicicleta\nbarco",
          v2Placeholder: "moderno\nvelho\nvintage",
          v3Placeholder: "grande\npequeno",
          v4Placeholder: "amarelo\nvermelho",
          shuffleBtn: "Embaralhar",
          sortAscBtn: "Ordenar A-Z",
          sortDescBtn: "Ordenar Z-A",
          resultLabel: "Resultado",
          linesText: "linhas",
          copyResultBtn: "Copiar resultado",
          clearBtn: "Limpar",
          clearConfirm: "Limpar todo o conteúdo do Input e V1–V5?",
          themeBtn: "Alternar tema",
          storageText: "armazenamento",
          historyBtn: "Gerenciar",
          historyTitle: "Gerenciar Storages",
          historyEmpty: "Nenhuma entrada para gerenciar",
          loadBtn: "Carregar",
          renameBtn: "Renomear",
          deleteBtn: "Excluir",
          renamePrompt: "Digite o novo nome:",
          deleteConfirm: "Excluir este histórico?",
          searchPlaceholder: "Buscar no Input e V1–V5...",
          searchBtn: "Buscar",
          searchFoundIn: "Encontrado em",
          searchPromptsContaining: "Prompts que contêm:",
          openInNewTab: "Abrir em nova aba",
          searchNoResults: "Nenhum resultado",
          searchLineLabel: "linha",
          searchOtherStorages: "outros storages",
          permanentVarsBtn: "Variáveis Permanentes",
          permanentVarsTitle: "Variáveis Permanentes",
          permanentVarsAdd: "Adicionar",
          permanentVarsSave: "Salvar",
          permanentVarsId: "ID",
          permanentVarsValue: "Valor"
        },
        ja: {
          title: "プロンプト連結",
          inputLabel: "入力",
          inputPlaceholder: "{V1}は{V2}で、サイズは{V3}、色は{V4}です。これが私の{V1}です",
          placeholderHelp: "プレースホルダー: {V1}, {V2}, {V3}, {V4}, {V5}。{{ID}}=永続変数（全ストレージ共通）。#=コメント。[[a, b, c]]=行ごとにランダム選択（Input・V1–V5、最大100件）。",
          conditionalHelp: "条件式: IF({V1}==1,\"値\") | 演算子: ==, !=, <, >, <=, >=, contains, &&, ||",
          v1Placeholder: "車\n自転車\nボート",
          v2Placeholder: "モダン\n古い\nヴィンテージ",
          v3Placeholder: "大きい\n小さい",
          v4Placeholder: "黄色\n赤",
          shuffleBtn: "シャッフル",
          sortAscBtn: "昇順ソート",
          sortDescBtn: "降順ソート",
          resultLabel: "結果",
          linesText: "行",
          copyResultBtn: "結果をコピー",
          clearBtn: "クリア",
          clearConfirm: "InputとV1–V5の内容をすべてクリアしますか？",
          themeBtn: "テーマを切り替え",
          storageText: "ストレージ",
          historyBtn: "管理",
          historyTitle: "ストレージ管理",
          historyEmpty: "管理する項目がありません",
          loadBtn: "読み込む",
          renameBtn: "名前変更",
          deleteBtn: "削除",
          renamePrompt: "新しい名前を入力:",
          deleteConfirm: "この履歴を削除しますか？",
          searchPlaceholder: "InputとV1–V5で検索...",
          searchBtn: "検索",
          searchFoundIn: "見つかった場所",
          searchPromptsContaining: "含むプロンプト:",
          openInNewTab: "新しいタブで開く",
          searchNoResults: "一致なし",
          searchLineLabel: "行",
          searchOtherStorages: "他のストレージ",
          permanentVarsBtn: "永続変数",
          permanentVarsTitle: "永続変数",
          permanentVarsAdd: "追加",
          permanentVarsSave: "保存",
          permanentVarsId: "ID",
          permanentVarsValue: "値"
        }
      };

      document.addEventListener('DOMContentLoaded', () => {
        // Elements
        const langSwitcher = document.getElementById('lang-switcher');
        const themeSwitcher = document.getElementById('theme-switcher');
        const clearBtn = document.getElementById('clear-btn');
        const copyResultBtn = document.getElementById('copy-result-btn');
        const storageScopeEl = document.getElementById('storage-scope');
        const storageSelectEl = document.getElementById('storage-select');

        const inputTemplateEl = document.getElementById('input-template');
        const vEls = [document.getElementById('v1'), document.getElementById('v2'), document.getElementById('v3'), document.getElementById('v4'), document.getElementById('v5')];
        const resultEl = document.getElementById('result');
        const resultCountEl = document.getElementById('result-count');

        const searchInputEl = document.getElementById('search-input');
        const searchBtnEl = document.getElementById('search-btn');
        const searchResultsEl = document.getElementById('search-results');

        const historyBtn = document.getElementById('history-btn');
        const historyListEl = document.getElementById('history-list');
        const historyEmptyEl = document.getElementById('history-empty');
        const historyModal = new bootstrap.Modal(document.getElementById('history-modal'));

        const permanentVarsBtn = document.getElementById('permanent-vars-btn');
        const permanentVarsModalEl = document.getElementById('permanent-vars-modal');
        const permanentVarsModal = new bootstrap.Modal(permanentVarsModalEl);
        const permanentVarsRowsEl = document.getElementById('permanent-vars-rows');
        const permanentVarsAddRowBtn = document.getElementById('permanent-vars-add-row');
        const permanentVarsSaveBtn = document.getElementById('permanent-vars-save');

        // Language
        let currentLanguage = localStorage.getItem('app_lang') || 'en';
        const applyI18n = () => {
          const lang = i18n[currentLanguage] || i18n.en;
          document.querySelectorAll('[data-i18n]').forEach(el => {
            const key = el.getAttribute('data-i18n');
            if (lang[key]) {
              el.innerText = lang[key];
            }
          });
          document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
            const key = el.getAttribute('data-i18n-placeholder');
            if (lang[key]) {
              el.placeholder = lang[key];
            }
          });
          document.querySelectorAll('[data-i18n-title]').forEach(el => {
            const key = el.getAttribute('data-i18n-title');
            if (lang[key]) {
              el.title = lang[key];
            }
          });
          document.title = lang.title;
        };

        // Theme
        let currentTheme = localStorage.getItem('app_theme') || 'dark';
        const applyTheme = (theme) => {
          document.documentElement.setAttribute('data-theme', theme);
          const icon = themeSwitcher.querySelector('i');
          icon.className = theme === 'light' ? 'fas fa-moon' : 'fas fa-sun';
          localStorage.setItem('app_theme', theme);
        };

        // History helpers
        const formatTimestamp = () => {
          const now = new Date();
          const pad = (n) => String(n).padStart(2, '0');
          const date = `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}`;
          const time = `${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
          return `${date}_${time}`;
        };

        const parseHistoryDate = (prefix) => {
          // prefix format: history_YYYYMMDD_HHMMSS
          const match = prefix.match(/^history_(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})(\d{2})$/);
          if (!match) return null;
          return new Date(match[1], parseInt(match[2]) - 1, match[3], match[4], match[5], match[6]);
        };

        const formatHistoryDateForDisplay = (prefix) => {
          const date = parseHistoryDate(prefix);
          if (!date) return prefix;
          const pad = (n) => String(n).padStart(2, '0');
          return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
        };

        const isHistoryPrefix = (prefix) => /^history_\d{8}_\d{6}$/.test(prefix);

        // Storage (hash prefix)
        const getPrefix = () => {
          const h = String(location.hash || '').replace(/^#/, '').trim();
          return h ? h : 'default';
        };
        const keyFor = (field) => `prompt_concat:${getPrefix()}:${field}`;
        const updateStorageScopeText = () => {
          const prefix = getPrefix();
          const lang = i18n[currentLanguage] || i18n.en;
          storageScopeEl.textContent = `${lang.storageText}: ${prefix}`;
          document.title = `${lang.title} - ${prefix}`;
        };

        // List all existing storages
        const getAllStorages = () => {
          const storages = new Set(['default']);
          try {
            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key && key.startsWith('prompt_concat:')) {
                const parts = key.split(':');
                if (parts.length >= 2) {
                  storages.add(parts[1]);
                }
              }
            }
          } catch {
            // ignore
          }
          return Array.from(storages).sort();
        };

        // Update storage select dropdown
        const updateStorageSelect = () => {
          const storages = getAllStorages();
          const currentPrefix = getPrefix();
          storageSelectEl.innerHTML = '';

          // Separate normal storages from history
          const normalStorages = storages.filter(s => !isHistoryPrefix(s));
          const historyStorages = storages.filter(s => isHistoryPrefix(s)).sort().reverse(); // newest first

          // Add normal storages
          normalStorages.forEach((storage) => {
            const option = document.createElement('option');
            option.value = storage;
            option.textContent = storage;
            if (storage === currentPrefix) {
              option.selected = true;
            }
            storageSelectEl.appendChild(option);
          });

          // Add history storages in optgroup
          if (historyStorages.length > 0) {
            const lang = i18n[currentLanguage] || i18n.en;
            const optgroup = document.createElement('optgroup');
            optgroup.label = lang.historyTitle || 'History';
            historyStorages.forEach((storage) => {
              const option = document.createElement('option');
              option.value = storage;
              option.textContent = formatHistoryDateForDisplay(storage);
              if (storage === currentPrefix) {
                option.selected = true;
              }
              optgroup.appendChild(option);
            });
            storageSelectEl.appendChild(optgroup);
          }
        };

        const readField = (field, fallback = '') => {
          try {
            const v = localStorage.getItem(keyFor(field));
            return v == null ? fallback : v;
          } catch {
            return fallback;
          }
        };
        const readFieldFromPrefix = (prefix, field, fallback = '') => {
          try {
            const v = localStorage.getItem(`prompt_concat:${prefix}:${field}`);
            return v == null ? fallback : v;
          } catch {
            return fallback;
          }
        };
        const writeField = (field, value) => {
          try {
            localStorage.setItem(keyFor(field), String(value));
          } catch {
            // ignore
          }
        };

        // Permanent variables (shared across all storages)
        const PERMANENT_VARS_KEY = 'prompt_concat:permanent_vars';
        const getPermanentVars = () => {
          try {
            const raw = localStorage.getItem(PERMANENT_VARS_KEY);
            if (raw == null) return {};
            const parsed = JSON.parse(raw);
            return typeof parsed === 'object' && parsed !== null ? parsed : {};
          } catch {
            return {};
          }
        };
        const setPermanentVars = (obj) => {
          try {
            localStorage.setItem(PERMANENT_VARS_KEY, JSON.stringify(obj));
          } catch {
            // ignore
          }
        };
        const applyPermanentVariables = (text, varsObj) => {
          if (!text || typeof text !== 'string') return text;
          let out = text;
          for (const id of Object.keys(varsObj)) {
            if (!id) continue;
            const value = varsObj[id];
            const placeholder = '{{' + id + '}}';
            out = out.split(placeholder).join(value != null ? String(value) : '');
          }
          return out;
        };

        const writeFieldToPrefix = (prefix, field, value) => {
          try {
            localStorage.setItem(`prompt_concat:${prefix}:${field}`, String(value));
          } catch {
            // ignore
          }
        };

        const saveHistory = () => {
          const historyPrefix = `history_${formatTimestamp()}`;
          writeFieldToPrefix(historyPrefix, 'input', inputTemplateEl.value);
          vEls.forEach((el, idx) => writeFieldToPrefix(historyPrefix, `v${idx + 1}`, el.value));
          cleanOldHistory();
          updateStorageSelect();
        };

        const cleanOldHistory = () => {
          const threeDaysAgo = new Date(Date.now() - 3 * 24 * 60 * 60 * 1000);
          const keysToRemove = [];
          const prefixesToRemove = new Set();

          try {
            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key && key.startsWith('prompt_concat:history_')) {
                const parts = key.split(':');
                if (parts.length >= 2) {
                  const prefix = parts[1]; // history_YYYYMMDD_HHMMSS
                  const date = parseHistoryDate(prefix);
                  if (date && date < threeDaysAgo) {
                    prefixesToRemove.add(prefix);
                  }
                }
              }
            }

            // Collect all keys for old prefixes
            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key) {
                for (const prefix of prefixesToRemove) {
                  if (key.startsWith(`prompt_concat:${prefix}:`)) {
                    keysToRemove.push(key);
                  }
                }
              }
            }

            keysToRemove.forEach(key => localStorage.removeItem(key));
          } catch {
            // ignore
          }
        };

        const getAllEditablePrefixes = () => {
          const prefixes = new Set();
          try {
            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key && key.startsWith('prompt_concat:')) {
                const parts = key.split(':');
                if (parts.length >= 2 && parts[1] !== 'default') {
                  prefixes.add(parts[1]);
                }
              }
            }
          } catch {
            // ignore
          }
          // Sort: history entries first (newest first), then other names alphabetically
          const arr = Array.from(prefixes);
          const historyPrefixes = arr.filter(p => isHistoryPrefix(p)).sort().reverse();
          const otherPrefixes = arr.filter(p => !isHistoryPrefix(p)).sort();
          return [...historyPrefixes, ...otherPrefixes];
        };

        const deleteHistoryPrefix = (prefix) => {
          const keysToRemove = [];
          try {
            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key && key.startsWith(`prompt_concat:${prefix}:`)) {
                keysToRemove.push(key);
              }
            }
            keysToRemove.forEach(key => localStorage.removeItem(key));
          } catch {
            // ignore
          }
        };

        const renameHistoryPrefix = (oldPrefix, newPrefix) => {
          const fields = ['input', 'v1', 'v2', 'v3', 'v4', 'v5'];
          try {
            // Copy data to new prefix
            fields.forEach(field => {
              const oldKey = `prompt_concat:${oldPrefix}:${field}`;
              const newKey = `prompt_concat:${newPrefix}:${field}`;
              const value = localStorage.getItem(oldKey);
              if (value !== null) {
                localStorage.setItem(newKey, value);
              }
            });
            // Delete old prefix
            deleteHistoryPrefix(oldPrefix);
          } catch {
            // ignore
          }
        };

        const renderHistoryModal = () => {
          const prefixes = getAllEditablePrefixes();
          const lang = i18n[currentLanguage] || i18n.en;
          historyListEl.innerHTML = '';

          if (prefixes.length === 0) {
            historyEmptyEl.style.display = 'block';
            return;
          }
          historyEmptyEl.style.display = 'none';

          prefixes.forEach(prefix => {
            const item = document.createElement('div');
            item.className = 'd-flex align-items-center justify-content-between p-2 mb-2 rounded';
            item.style.cssText = 'background-color: var(--bg-color); border: 1px solid var(--border-color);';
            
            const label = document.createElement('span');
            // Show formatted date for history entries, plain name for others
            label.textContent = isHistoryPrefix(prefix) ? formatHistoryDateForDisplay(prefix) : prefix;
            label.style.flex = '1';
            label.style.cursor = 'pointer';
            label.title = lang.loadBtn || 'Load';
            label.addEventListener('click', () => {
              location.hash = prefix;
              historyModal.hide();
            });

            const btnGroup = document.createElement('div');
            btnGroup.className = 'd-flex gap-1';

            const loadBtn = document.createElement('button');
            loadBtn.className = 'btn btn-sm btn-outline-primary';
            loadBtn.innerHTML = '<i class="fas fa-folder-open"></i>';
            loadBtn.title = lang.loadBtn || 'Load';
            loadBtn.addEventListener('click', () => {
              location.hash = prefix;
              historyModal.hide();
            });

            const renameBtn = document.createElement('button');
            renameBtn.className = 'btn btn-sm btn-outline-warning';
            renameBtn.innerHTML = '<i class="fas fa-edit"></i>';
            renameBtn.title = lang.renameBtn || 'Rename';
            renameBtn.addEventListener('click', () => {
              const defaultName = isHistoryPrefix(prefix) ? prefix.replace('history_', '') : prefix;
              const newName = prompt(lang.renamePrompt || 'Enter new name:', defaultName);
              if (newName && newName.trim()) {
                const sanitized = newName.trim().replace(/[^a-zA-Z0-9_-]/g, '_');
                if (sanitized && sanitized !== prefix && sanitized !== 'default') {
                  renameHistoryPrefix(prefix, sanitized);
                  updateStorageSelect();
                  renderHistoryModal();
                }
              }
            });

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'btn btn-sm btn-outline-danger';
            deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
            deleteBtn.title = lang.deleteBtn || 'Delete';
            deleteBtn.addEventListener('click', () => {
              if (confirm(lang.deleteConfirm || 'Delete this entry?')) {
                deleteHistoryPrefix(prefix);
                updateStorageSelect();
                renderHistoryModal();
              }
            });

            btnGroup.appendChild(loadBtn);
            btnGroup.appendChild(renameBtn);
            btnGroup.appendChild(deleteBtn);

            item.appendChild(label);
            item.appendChild(btnGroup);
            historyListEl.appendChild(item);
          });
        };

        // Permanent Variables modal
        const lang = () => i18n[currentLanguage] || i18n.en;
        const createPermanentVarRow = (idVal, valueVal) => {
          const row = document.createElement('div');
          row.className = 'permanent-var-row d-flex gap-2 align-items-start mb-2';
          const idInput = document.createElement('input');
          idInput.type = 'text';
          idInput.className = 'form-control form-control-sm permanent-var-id mono';
          idInput.placeholder = lang().permanentVarsId || 'ID';
          idInput.value = idVal || '';
          idInput.style.minWidth = '80px';
          idInput.style.maxWidth = '120px';
          const valueInput = document.createElement('textarea');
          valueInput.className = 'form-control form-control-sm permanent-var-value mono flex-grow-1';
          valueInput.placeholder = lang().permanentVarsValue || 'Value';
          valueInput.rows = 2;
          valueInput.value = valueVal != null ? String(valueVal) : '';
          const deleteBtn = document.createElement('button');
          deleteBtn.type = 'button';
          deleteBtn.className = 'btn btn-sm btn-outline-danger';
          deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
          deleteBtn.title = lang().deleteBtn || 'Delete';
          deleteBtn.addEventListener('click', () => row.remove());
          row.appendChild(idInput);
          row.appendChild(valueInput);
          row.appendChild(deleteBtn);
          return row;
        };
        const renderPermanentVarsModal = () => {
          permanentVarsRowsEl.innerHTML = '';
          const vars = getPermanentVars();
          const entries = Object.entries(vars);
          if (entries.length === 0) {
            permanentVarsRowsEl.appendChild(createPermanentVarRow('', ''));
          } else {
            entries.forEach(([id, value]) => {
              permanentVarsRowsEl.appendChild(createPermanentVarRow(id, value));
            });
          }
        };
        const savePermanentVarsFromModal = () => {
          const obj = {};
          permanentVarsRowsEl.querySelectorAll('.permanent-var-row').forEach((row) => {
            const idEl = row.querySelector('.permanent-var-id');
            const valueEl = row.querySelector('.permanent-var-value');
            const id = (idEl && idEl.value || '').trim();
            if (id) obj[id] = valueEl && valueEl.value != null ? valueEl.value : '';
          });
          setPermanentVars(obj);
          render();
        };

        // Logic
        const MAX_ARRAY_ITEMS = 100;

        // Parse [[val1, val2, ...]] into array of strings, or null if not an array line
        const parseArrayLiteral = (line) => {
          const s = String(line).trim();
          const m = s.match(/^\[\[(.*)\]\]$/s);
          if (!m) return null;
          const inner = (m[1] || '').trim();
          const parts = inner ? inner.split(',').map((p) => p.trim()).filter(Boolean) : [];
          const arr = parts.slice(0, MAX_ARRAY_ITEMS);
          return arr.length ? arr : [''];
        };

        // Pick one value at random from a line (string or array of strings)
        const pickValue = (line) => {
          if (Array.isArray(line)) {
            return line.length ? line[Math.floor(Math.random() * line.length)] : '';
          }
          return line;
        };

        const parseLines = (text) => {
          const raw = String(text || '').split(/\r?\n/).map((s) => s.trim()).filter((s) => s !== '' && !s.startsWith('#'));
          const out = [];
          for (const s of raw) {
            const arr = parseArrayLiteral(s);
            out.push(arr !== null ? arr : s);
          }
          return out.length ? out : [''];
        };

        // Shuffle lines in a textarea
        const shuffleLines = (textareaEl) => {
          const lines = String(textareaEl.value || '').split(/\r?\n/);
          // Fisher-Yates shuffle algorithm
          for (let i = lines.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [lines[i], lines[j]] = [lines[j], lines[i]];
          }
          textareaEl.value = lines.join('\n');
          schedule();
        };

        // Sort lines ascending (A-Z)
        const sortLinesAsc = (textareaEl) => {
          const lines = String(textareaEl.value || '').split(/\r?\n/);
          lines.sort((a, b) => a.localeCompare(b));
          textareaEl.value = lines.join('\n');
          schedule();
        };

        // Sort lines descending (Z-A)
        const sortLinesDesc = (textareaEl) => {
          const lines = String(textareaEl.value || '').split(/\r?\n/);
          lines.sort((a, b) => b.localeCompare(a));
          textareaEl.value = lines.join('\n');
          schedule();
        };

        // Parse IF statement: IF(condition, "value")
        // Returns { isConditional: true, condition: string, value: string } or { isConditional: false, value: string }
        const parseIfStatement = (line) => {
          const trimmed = String(line).trim();
          // Match IF(condition, "value") or IF(condition, 'value')
          const match = trimmed.match(/^IF\s*\(\s*(.+?)\s*,\s*["'](.*)["']\s*\)$/i);
          if (match) {
            return { isConditional: true, condition: match[1].trim(), value: match[2] };
          }
          return { isConditional: false, value: trimmed };
        };

        // Evaluate a single comparison: left op right
        const evaluateSingleComparison = (left, op, right) => {
          // Try to parse as numbers
          const leftNum = parseFloat(left);
          const rightNum = parseFloat(right);
          const bothNumbers = !isNaN(leftNum) && !isNaN(rightNum);

          switch (op) {
            case '==':
              return bothNumbers ? leftNum === rightNum : left === right;
            case '!=':
              return bothNumbers ? leftNum !== rightNum : left !== right;
            case '<':
              return bothNumbers ? leftNum < rightNum : left < right;
            case '>':
              return bothNumbers ? leftNum > rightNum : left > right;
            case '<=':
              return bothNumbers ? leftNum <= rightNum : left <= right;
            case '>=':
              return bothNumbers ? leftNum >= rightNum : left >= right;
            case 'contains':
              return String(left).includes(String(right));
            default:
              return false;
          }
        };

        // Evaluate condition with variables replaced
        // Supports: ==, !=, <, >, <=, >=, contains, &&, ||
        const evaluateCondition = (condition, values) => {
          // Replace variables {V1}, {V2}, etc. with actual values
          let expr = condition;
          for (let i = 0; i < values.length; i++) {
            const placeholder = `{V${i + 1}}`;
            expr = expr.replaceAll(placeholder, values[i]);
          }

          // Split by || (OR) first, then by && (AND)
          const orParts = expr.split(/\s*\|\|\s*/);
          
          for (const orPart of orParts) {
            const andParts = orPart.split(/\s*&&\s*/);
            let andResult = true;
            
            for (const andPart of andParts) {
              const part = andPart.trim();
              let compResult = false;

              // Try to match comparison operators
              // Order matters: check longer operators first (<=, >=, !=, ==) before (<, >)
              const compMatch = part.match(/^(.+?)\s*(<=|>=|!=|==|<|>|contains)\s*(.+)$/i);
              
              if (compMatch) {
                let left = compMatch[1].trim();
                const op = compMatch[2].toLowerCase();
                let right = compMatch[3].trim();

                // Remove quotes from left/right if present
                left = left.replace(/^["']|["']$/g, '');
                right = right.replace(/^["']|["']$/g, '');

                compResult = evaluateSingleComparison(left, op, right);
              } else {
                // If no operator found, treat non-empty as true
                compResult = part.length > 0;
              }

              andResult = andResult && compResult;
            }

            // If any OR part is true, return true
            if (andResult) {
              return true;
            }
          }

          return false;
        };

        // Process a line that may contain IF(), or be an array [[...]]; return value/array or null if condition fails
        const processConditionalLine = (line, values) => {
          if (Array.isArray(line)) return line; // Array line: include as-is; random pick at render time
          const parsed = parseIfStatement(line);
          if (!parsed.isConditional) {
            return parsed.value; // Always include non-conditional lines
          }
          // Evaluate the condition with the current values
          if (evaluateCondition(parsed.condition, values)) {
            return parsed.value;
          }
          return null; // Condition failed, exclude this line
        };

        const cartesianProduct = (arrays) => {
          let acc = [[]];
          for (const arr of arrays) {
            const next = [];
            for (const prev of acc) {
              for (const item of arr) next.push(prev.concat([item]));
            }
            acc = next;
          }
          return acc;
        };

        // Replace each [[val1, val2, ...]] in template with one random value (for Input template)
        const replaceArrayLiteralsInTemplate = (str) => {
          return String(str).replace(/\[\[(.*?)\]\]/g, (_, inner) => {
            const parts = (inner || '').split(',').map((p) => p.trim()).filter(Boolean).slice(0, MAX_ARRAY_ITEMS);
            return parts.length ? parts[Math.floor(Math.random() * parts.length)] : '';
          });
        };

        const render = () => {
          const permanentVars = getPermanentVars();
          // Apply {{ID}} substitution before processing
          const inputRaw = applyPermanentVariables(String(inputTemplateEl.value || ''), permanentVars);
          // Input: ignore lines that start with "#" (same as V1–V5)
          const template = inputRaw
            .split(/\r?\n/)
            .filter((line) => !line.trim().startsWith('#'))
            .join('\n');
          const lists = vEls.map((el) => parseLines(applyPermanentVariables(el.value, permanentVars)));
          
          // Cartesian product with conditional evaluation
          // We need to evaluate conditions as we build combinations
          const generateCombinations = (lists) => {
            const results = [];
            
            const recurse = (depth, currentValues) => {
              if (depth === lists.length) {
                // All values selected, add to results
                results.push([...currentValues]);
                return;
              }
              
              const currentList = lists[depth];
              for (const line of currentList) {
                // Process the line (may be conditional)
                const processedValue = processConditionalLine(line, currentValues);
                
                if (processedValue !== null) {
                  // Condition passed (or no condition), continue with this value
                  currentValues.push(processedValue);
                  recurse(depth + 1, currentValues);
                  currentValues.pop();
                }
                // If processedValue is null, skip this line (condition failed)
              }
            };
            
            recurse(0, []);
            return results;
          };
          
          const combos = generateCombinations(lists);

          const lines = combos.map((valuesRaw) => {
            // Resolve arrays to one random value per line, then chained placeholders
            const values = [];
            for (let i = 0; i < valuesRaw.length; i++) {
              let v = pickValue(valuesRaw[i]);
              v = String(v ?? '');
              for (let j = 0; j < i; j++) {
                v = v.replaceAll(`{V${j + 1}}`, values[j]);
              }
              values.push(v);
            }

            let out = template;
            for (let i = 0; i < values.length; i++) {
              const placeholder = `{V${i + 1}}`;
              out = out.replaceAll(placeholder, values[i]);
            }
            // Replace [[...]] in template with random pick per result line
            out = replaceArrayLiteralsInTemplate(out);
            return out;
          });

          resultEl.value = lines.join('\n');
          resultCountEl.textContent = String(lines.length);
        };

        const escapeHtml = (s) => {
          const div = document.createElement('div');
          div.textContent = s;
          return div.innerHTML;
        };

        const openPromptInNewTab = (promptText) => {
          const endStyle = '<' + '/style>';
          const endHeadBody = '<' + '/head><body>';
          const endBodyHtml = '<' + '/body><' + '/html>';
          const html = '<!DOCTYPE html><html><head><meta charset="utf-8"><title>Prompt</title><style>body{font-family:monospace;white-space:pre-wrap;word-break:break-all;padding:1rem;margin:0;background:#1a1a1a;color:#f0f0f0;}' + endStyle + endHeadBody + escapeHtml(promptText) + endBodyHtml;
          const dataUrl = 'data:text/html;charset=utf-8,' + encodeURIComponent(html);
          window.open(dataUrl, '_blank', 'noopener');
        };

        const runSearch = () => {
          const term = String(searchInputEl.value || '').trim();
          const lang = i18n[currentLanguage] || i18n.en;
          searchResultsEl.style.display = 'none';
          searchResultsEl.innerHTML = '';

          if (!term) return;

          const currentPrefix = getPrefix();
          const allStorages = getAllStorages();
          const otherStorages = allStorages.filter((p) => p !== currentPrefix);

          const sourceNames = [
            { key: 'input', name: 'Input' },
            { key: 'v1', name: 'V1' },
            { key: 'v2', name: 'V2' },
            { key: 'v3', name: 'V3' },
            { key: 'v4', name: 'V4' },
            { key: 'v5', name: 'V5' }
          ];

          const foundInSources = [];
          const lowerTerm = term.toLowerCase();

          for (const prefix of otherStorages) {
            for (const src of sourceNames) {
              const text = String(readFieldFromPrefix(prefix, src.key, ''));
              const lines = text.split(/\r?\n/);
              lines.forEach((line, idx) => {
                if (line.toLowerCase().includes(lowerTerm)) {
                  foundInSources.push({
                    storage: prefix,
                    storageDisplay: isHistoryPrefix(prefix) ? formatHistoryDateForDisplay(prefix) : prefix,
                    source: src.name,
                    line: line.trim(),
                    lineNum: idx + 1
                  });
                }
              });
            }
          }

          if (foundInSources.length === 0) {
            searchResultsEl.innerHTML = '<div class="text-muted small">' + (lang.searchNoResults || 'No matches') + '</div>';
            searchResultsEl.style.display = 'block';
            return;
          }

          const lineLabel = lang.searchLineLabel || 'line';
          const openStorageLabel = lang.openInNewTab || 'Open in new tab';
          const baseUrl = location.href.split('#')[0];
          let html = '<div class="small fw-bold mb-1">' + (lang.searchFoundIn || 'Found in') + ' (' + (lang.searchOtherStorages || 'other storages') + '):</div>';
          html += '<ul class="list-unstyled small mb-2">';
          foundInSources.forEach(({ storage, storageDisplay, source, line, lineNum }) => {
            const snippet = escapeHtml(line.length > 120 ? line.slice(0, 120) + '…' : line);
            const storageUrl = baseUrl + '#' + encodeURIComponent(storage);
            html += '<li class="mb-2">';
            html += '<span class="text-warning">' + escapeHtml(storageDisplay) + '</span> &rarr; <span class="text-info">' + escapeHtml(source) + '</span> (' + lineLabel + ' ' + lineNum + '): <span class="mono">' + snippet + '</span><br>';
            html += '<a href="' + escapeHtml(storageUrl) + '" class="open-storage-link" target="_blank" rel="noopener">' + escapeHtml(openStorageLabel) + ' <i class="fas fa-external-link-alt"></i></a>';
            html += '</li>';
          });
          html += '</ul>';

          searchResultsEl.innerHTML = html;
          searchResultsEl.style.display = 'block';
        };

        const saveAll = () => {
          writeField('input', inputTemplateEl.value);
          vEls.forEach((el, idx) => writeField(`v${idx + 1}`, el.value));
        };

        const loadAll = () => {
          inputTemplateEl.value = readField('input', '');
          vEls.forEach((el, idx) => (el.value = readField(`v${idx + 1}`, '')));
        };

        // Debounce
        let t = null;
        const schedule = () => {
          if (t) clearTimeout(t);
          t = setTimeout(() => {
            saveAll();
            render();
          }, 120);
        };

        // Events
        langSwitcher.addEventListener('change', (e) => {
          currentLanguage = e.target.value;
          localStorage.setItem('app_lang', currentLanguage);
          applyI18n();
          updateStorageScopeText();
        });

        themeSwitcher.addEventListener('click', () => {
          currentTheme = currentTheme === 'dark' ? 'light' : 'dark';
          applyTheme(currentTheme);
        });

        clearBtn.addEventListener('click', () => {
          const lang = i18n[currentLanguage] || i18n.en;
          if (!confirm(lang.clearConfirm || 'Clear all Input and V1–V5 content?')) return;
          inputTemplateEl.value = '';
          vEls.forEach((el) => (el.value = ''));
          saveAll();
          render();
        });

        historyBtn.addEventListener('click', () => {
          renderHistoryModal();
          historyModal.show();
        });

        permanentVarsBtn.addEventListener('click', () => {
          renderPermanentVarsModal();
          permanentVarsModal.show();
        });
        permanentVarsAddRowBtn.addEventListener('click', () => {
          permanentVarsRowsEl.appendChild(createPermanentVarRow('', ''));
        });
        permanentVarsSaveBtn.addEventListener('click', () => {
          savePermanentVarsFromModal();
          permanentVarsModal.hide();
        });
        permanentVarsModalEl.addEventListener('hide.bs.modal', () => {
          savePermanentVarsFromModal();
        });

        copyResultBtn.addEventListener('click', async () => {
          const text = String(resultEl.value || '');
          try {
            await navigator.clipboard.writeText(text);
          } catch {
            // fallback
            resultEl.focus();
            resultEl.select();
            document.execCommand('copy');
            resultEl.setSelectionRange(0, 0);
          }
          // Save to history
          saveHistory();
        });

        inputTemplateEl.addEventListener('input', schedule);
        vEls.forEach((el) => el.addEventListener('input', schedule));

        searchBtnEl.addEventListener('click', runSearch);
        searchInputEl.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            runSearch();
          }
        });

        // Shuffle buttons
        document.querySelectorAll('[data-shuffle]').forEach((btn) => {
          btn.addEventListener('click', () => {
            const targetId = btn.getAttribute('data-shuffle');
            const targetEl = document.getElementById(targetId);
            if (targetEl) {
              shuffleLines(targetEl);
            }
          });
        });

        // Sort ascending buttons
        document.querySelectorAll('[data-sort-asc]').forEach((btn) => {
          btn.addEventListener('click', () => {
            const targetId = btn.getAttribute('data-sort-asc');
            const targetEl = document.getElementById(targetId);
            if (targetEl) {
              sortLinesAsc(targetEl);
            }
          });
        });

        // Sort descending buttons
        document.querySelectorAll('[data-sort-desc]').forEach((btn) => {
          btn.addEventListener('click', () => {
            const targetId = btn.getAttribute('data-sort-desc');
            const targetEl = document.getElementById(targetId);
            if (targetEl) {
              sortLinesDesc(targetEl);
            }
          });
        });

        storageSelectEl.addEventListener('change', () => {
          const selectedStorage = storageSelectEl.value;
          location.hash = selectedStorage === 'default' ? '' : selectedStorage;
        });

        window.addEventListener('hashchange', () => {
          updateStorageScopeText();
          updateStorageSelect();
          loadAll();
          render();
        });

        // Init
        cleanOldHistory(); // Clean old history entries on page load
        langSwitcher.value = currentLanguage;
        applyI18n();
        applyTheme(currentTheme);
        updateStorageScopeText();
        updateStorageSelect();
        loadAll();
        render();
      });
    </script>
  </body>
</html>


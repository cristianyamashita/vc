<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pixel Art Sprint Editor</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  <style>
    body { font-family: 'Inter', sans-serif; touch-action: none; }
    .canvas-container { cursor: crosshair; aspect-ratio: 1 / 1; }
    canvas { display: block; width: 100%; height: 100%; }
    .color-box { transition: transform 0.1s ease-in-out; }
    .color-box:hover { transform: scale(1.1); }
    .color-box.selected { transform: scale(1.1); box-shadow: 0 0 0 3px #3b82f6; }
    .tool-btn.active { background-color: #3b82f6; color: white; }
    select:focus, input:focus { outline: 2px solid #3b82f6; outline-offset: 2px; }
    .layer-item.active { background-color: rgba(59,130,246,0.1); border-color: rgba(59,130,246,0.5); }
  </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 flex flex-col items-center justify-center min-h-screen p-4">
  <div class="w-full max-w-6xl">
    <header class="flex justify-between items-center mb-4">
      <h1 class="text-2xl md:text-3xl font-bold text-gray-800 dark:text-white" data-lang="title">Pixel Art Sprint Editor</h1>
      <div class="flex items-center space-x-2">
        <span data-lang="language">Language:</span>
        <select id="lang-selector" class="bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md p-1.5 text-sm">
          <option value="en">English</option>
          <option value="ja">日本語</option>
          <option value="pt">Português</option>
        </select>
      </div>
    </header>

    <main class="flex flex-col lg:flex-row gap-4">
      <!-- Left controls panel -->
      <div class="w-full lg:w-72 bg-white dark:bg-gray-800 p-4 rounded-xl shadow-lg flex flex-col space-y-4">
        <div>
          <h3 class="font-bold mb-2" data-lang="tools">Tools</h3>
          <div class="grid grid-cols-3 gap-2">
            <button id="brush-tool" class="tool-btn active flex items-center justify-center p-2 rounded-lg bg-gray-200 dark:bg-gray-700 hover:bg-blue-500 hover:text-white transition-colors" title="Brush">
              <span data-lang="brush">Brush</span>
            </button>
            <button id="eraser-tool" class="tool-btn flex items-center justify-center p-2 rounded-lg bg-gray-200 dark:bg-gray-700 hover:bg-blue-500 hover:text-white transition-colors" title="Eraser">
              <span data-lang="eraser">Eraser</span>
            </button>
            <button id="select-tool" class="tool-btn flex items-center justify-center p-2 rounded-lg bg-gray-200 dark:bg-gray-700 hover:bg-blue-500 hover:text-white transition-colors" title="Select">
              <span data-lang="select">Select</span>
            </button>
          </div>
        </div>

        <div>
          <h3 class="font-bold mb-2" data-lang="colors">Colors</h3>
          <div id="color-palette" class="grid grid-cols-6 gap-2"></div>
        </div>

        <div>
          <label for="grid-resolution" class="font-bold mb-2 block" data-lang="gridResolution">Grid Resolution</label>
          <select id="grid-resolution" class="w-full bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md p-2 text-sm">
            <option value="16">16x16</option>
            <option value="32" selected>32x32</option>
            <option value="64">64x64</option>
            <option value="128">128x128</option>
          </select>
        </div>

        <div>
          <h3 class="font-bold mb-2" data-lang="actions">Actions</h3>
          <div class="flex flex-col space-y-2">
            <div>
              <label for="export-size" class="text-sm font-medium" data-lang="exportSize">Export Size (px)</label>
              <input type="number" id="export-size" value="512" class="w-full mt-1 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md p-2 text-sm" />
            </div>
            <button id="import-btn" class="p-2 rounded-lg bg-blue-500 text-white hover:bg-blue-600 transition-colors">Import Image</button>
            <input id="image-input" type="file" accept="image/*" class="hidden" />
            <button id="export-active-btn" class="p-2 rounded-lg bg-emerald-600 text-white hover:bg-emerald-700 transition-colors" data-lang="exportActive">Export Active</button>
            <button id="export-all-btn" class="p-2 rounded-lg bg-indigo-600 text-white hover:bg-indigo-700 transition-colors" data-lang="exportAll">Export All</button>
          </div>
        </div>
      </div>

      <!-- Canvas center area -->
      <div class="flex-grow bg-white dark:bg-gray-800 rounded-xl shadow-lg p-2 relative canvas-container">
        <canvas id="pixel-canvas"></canvas>
        <div id="selection-box" class="absolute border-2 border-dashed border-blue-500 hidden pointer-events-none"></div>
      </div>

      <!-- Right layers panel -->
      <aside class="w-full lg:w-80 bg-white dark:bg-gray-800 p-4 rounded-xl shadow-lg flex flex-col space-y-3">
        <div class="flex items-center justify-between mb-1">
          <h3 class="font-bold" data-lang="layers">Layers</h3>
          <button id="add-layer-btn" class="px-2 py-1 text-xs rounded bg-blue-500 text-white hover:bg-blue-600" data-lang="addLayer">Add</button>
        </div>
        <div id="layers-list" class="space-y-2 max-h-[70vh] overflow-auto pr-1"></div>
        <div class="pt-2 border-t border-gray-200 dark:border-gray-700">
          <h3 class="font-bold mb-2" data-lang="playback">Playback</h3>
          <div class="flex items-center space-x-2">
            <label for="frame-duration" class="text-sm" data-lang="frameDuration">Frame (ms)</label>
            <input id="frame-duration" type="number" value="300" class="w-24 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md p-2 text-sm" />
          </div>
          <div class="flex items-center space-x-2 mt-2">
            <button id="play-btn" class="px-3 py-2 rounded bg-green-600 text-white hover:bg-green-700" data-lang="play">Play</button>
            <button id="stop-btn" class="px-3 py-2 rounded bg-gray-500 text-white hover:bg-gray-600" data-lang="stop">Stop</button>
          </div>
        </div>
      </aside>
    </main>
  </div>

  <script>
    const translations = {
      en: {
        title: 'Pixel Art Sprint Editor', language: 'Language', tools: 'Tools', brush: 'Brush', eraser: 'Eraser',
        colors: 'Colors', gridResolution: 'Grid Resolution', layers: 'Layers', addLayer: 'Add', duplicate: 'Duplicate',
        delete: 'Delete', visibility: 'Visible', opacity: 'Opacity', actions: 'Actions', exportSize: 'Export Size (px)',
        exportActive: 'Export Active', exportAll: 'Export All', playback: 'Playback', frameDuration: 'Frame (ms)',
        play: 'Play', stop: 'Stop', layerName: 'Layer'
      },
      ja: {
        title: 'ピクセルアート スプリントエディタ', language: '言語', tools: 'ツール', brush: 'ブラシ', eraser: '消しゴム',
        colors: 'カラー', gridResolution: 'グリッド解像度', layers: 'レイヤー', addLayer: '追加', duplicate: '複製',
        delete: '削除', visibility: '表示', opacity: '不透明度', actions: 'アクション', exportSize: 'エクスポートサイズ (px)',
        exportActive: 'アクティブを保存', exportAll: 'すべて保存', playback: '再生', frameDuration: 'フレーム (ms)',
        play: '再生', stop: '停止', layerName: 'レイヤー'
      },
      pt: {
        title: 'Editor de Sprint de Pixel Art', language: 'Idioma', tools: 'Ferramentas', brush: 'Pincel', eraser: 'Borracha',
        colors: 'Cores', gridResolution: 'Resolução da Grade', layers: 'Camadas', addLayer: 'Adicionar', duplicate: 'Duplicar',
        delete: 'Excluir', visibility: 'Visível', opacity: 'Opacidade', actions: 'Ações', exportSize: 'Tamanho da Exportação (px)',
        exportActive: 'Exportar Ativa', exportAll: 'Exportar Todas', playback: 'Reprodução', frameDuration: 'Quadro (ms)',
        play: 'Reproduzir', stop: 'Parar', layerName: 'Camada'
      }
    };

    const langSelector = document.getElementById('lang-selector');
    langSelector.addEventListener('change', (e) => setLanguage(e.target.value));

    function setLanguage(lang) {
      document.querySelectorAll('[data-lang]').forEach(el => {
        const key = el.getAttribute('data-lang');
        if (translations[lang] && translations[lang][key]) {
          el.textContent = translations[lang][key];
        }
      });
      updateLayersList();
    }

    const canvas = document.getElementById('pixel-canvas');
    const ctx = canvas.getContext('2d');
    const canvasContainer = document.querySelector('.canvas-container');

    let gridResolution = 32;
    let pixelSize = 0;
    let isDrawing = false;
    let currentColor = '#000000';
    let currentTool = 'brush';
    let isPlaying = false;
    let playTimer = null;
    let playIndex = 0;
    // Selection state (currentTool declared above)
    let isSelecting = false;
    let isDragging = false;
    let selectionRect = { x: 0, y: 0, w: 0, h: 0 };
    let selectedPixelData = null; // {color, dx, dy}[]
    let dragStart = { x: 0, y: 0 };
    const selectionBox = document.getElementById('selection-box');

    const colors = [
      '#ffffff', '#c2c2c2', '#858585', '#474747', '#000000', '#203548',
      '#ff4500', '#ff8c00', '#ffd700', '#9acd32', '#32cd32', '#008080',
      '#00ced1', '#1e90ff', '#4169e1', '#8a2be2', '#9932cc', '#c71585'
    ];

    const colorPalette = document.getElementById('color-palette');
    colors.forEach(color => {
      const colorBox = document.createElement('div');
      colorBox.className = 'w-8 h-8 rounded-full cursor-pointer border-2 border-gray-300 dark:border-gray-600 color-box';
      colorBox.style.backgroundColor = color;
      colorBox.addEventListener('click', () => {
        currentColor = color;
        document.querySelectorAll('.color-box').forEach(b => b.classList.remove('selected'));
        colorBox.classList.add('selected');
      });
      colorPalette.appendChild(colorBox);
    });
    colorPalette.children[4].classList.add('selected');

    // Layers state
    /** @typedef {{ id: number, name: string, pixels: (string|null)[][], opacity: number, visible: boolean }} Layer */
    /** @type {Layer[]} */
    let layers = [];
    let activeLayerIndex = 0;
    let layerIdCounter = 1;

    function createEmptyPixels() {
      return Array(gridResolution).fill(0).map(() => Array(gridResolution).fill(null));
    }

    function addLayer(duplicateFromIndex = null) {
      const pixels = duplicateFromIndex !== null
        ? layers[duplicateFromIndex].pixels.map(row => row.slice())
        : createEmptyPixels();
      const layer = {
        id: layerIdCounter++,
        name: `${translations[langSelector.value].layerName} ${layers.length + 1}`,
        pixels,
        opacity: 1.0,
        visible: true
      };
      layers.push(layer);
      activeLayerIndex = layers.length - 1;
      updateLayersList();
      renderCanvas();
    }

    function removeLayer(index) {
      if (layers.length <= 1) return;
      layers.splice(index, 1);
      if (activeLayerIndex >= layers.length) activeLayerIndex = layers.length - 1;
      updateLayersList();
      renderCanvas();
    }

    function moveLayer(index, direction) {
      const newIndex = index + direction;
      if (newIndex < 0 || newIndex >= layers.length) return;
      const [l] = layers.splice(index, 1);
      layers.splice(newIndex, 0, l);
      activeLayerIndex = newIndex;
      updateLayersList();
      renderCanvas();
    }

    function updateLayersList() {
      const list = document.getElementById('layers-list');
      list.innerHTML = '';
      const t = translations[langSelector.value];
      layers.forEach((layer, idx) => {
        const row = document.createElement('div');
        row.className = `border rounded p-2 space-y-2 ${idx === activeLayerIndex ? 'layer-item active' : ''}`;

        const topBar = document.createElement('div');
        topBar.className = 'flex items-center justify-between gap-2';

        const nameBtn = document.createElement('button');
        nameBtn.className = 'text-left font-medium truncate flex-1';
        nameBtn.textContent = layer.name;
        nameBtn.addEventListener('click', () => { activeLayerIndex = idx; updateLayersList(); renderCanvas(); });

        const controls = document.createElement('div');
        controls.className = 'flex items-center gap-1';

        const upBtn = document.createElement('button');
        upBtn.className = 'px-2 py-1 text-xs rounded bg-gray-200 dark:bg-gray-700 hover:bg-gray-300';
        upBtn.textContent = '↑';
        upBtn.title = 'Up';
        upBtn.addEventListener('click', () => moveLayer(idx, -1));

        const downBtn = document.createElement('button');
        downBtn.className = 'px-2 py-1 text-xs rounded bg-gray-200 dark:bg-gray-700 hover:bg-gray-300';
        downBtn.textContent = '↓';
        downBtn.title = 'Down';
        downBtn.addEventListener('click', () => moveLayer(idx, 1));

        const dupBtn = document.createElement('button');
        dupBtn.className = 'px-2 py-1 text-xs rounded bg-blue-500 text-white hover:bg-blue-600';
        dupBtn.textContent = t.duplicate;
        dupBtn.addEventListener('click', () => { addLayer(idx); });

        const delBtn = document.createElement('button');
        delBtn.className = 'px-2 py-1 text-xs rounded bg-red-500 text-white hover:bg-red-600';
        delBtn.textContent = t.delete;
        delBtn.addEventListener('click', () => { removeLayer(idx); });

        controls.appendChild(upBtn);
        controls.appendChild(downBtn);
        controls.appendChild(dupBtn);
        controls.appendChild(delBtn);

        topBar.appendChild(nameBtn);
        topBar.appendChild(controls);

        const bottomBar = document.createElement('div');
        bottomBar.className = 'flex items-center gap-2';

        const visLabel = document.createElement('label');
        visLabel.className = 'flex items-center gap-1 text-sm';
        const visCheckbox = document.createElement('input');
        visCheckbox.type = 'checkbox';
        visCheckbox.checked = layer.visible;
        visCheckbox.addEventListener('change', () => { layer.visible = visCheckbox.checked; renderCanvas(); });
        const visText = document.createElement('span');
        visText.textContent = t.visibility;
        visLabel.appendChild(visCheckbox);
        visLabel.appendChild(visText);

        const opLabel = document.createElement('label');
        opLabel.className = 'flex items-center gap-2 text-sm flex-1';
        const opText = document.createElement('span');
        opText.textContent = t.opacity;
        const opRange = document.createElement('input');
        opRange.type = 'range';
        opRange.min = '0';
        opRange.max = '100';
        opRange.value = String(Math.round(layer.opacity * 100));
        opRange.className = 'flex-1';
        const opVal = document.createElement('span');
        opVal.className = 'w-10 text-right';
        opVal.textContent = `${Math.round(layer.opacity * 100)}%`;
        opRange.addEventListener('input', () => { layer.opacity = parseInt(opRange.value, 10) / 100; opVal.textContent = `${opRange.value}%`; renderCanvas(); });

        opLabel.appendChild(opText);
        opLabel.appendChild(opRange);
        opLabel.appendChild(opVal);

        bottomBar.appendChild(visLabel);
        bottomBar.appendChild(opLabel);

        row.appendChild(topBar);
        row.appendChild(bottomBar);
        list.appendChild(row);
      });
    }

    function resizeAndRender() {
      const containerRect = canvasContainer.getBoundingClientRect();
      const size = Math.min(containerRect.width, containerRect.height) - 16;
      canvas.width = size;
      canvas.height = size;
      pixelSize = canvas.width / gridResolution;
      renderCanvas();
    }

    function drawGrid() {
      ctx.strokeStyle = '#e0e0e0';
      ctx.lineWidth = 1;
      for (let i = 0; i <= gridResolution; i++) {
        const pos = i * pixelSize;
        ctx.beginPath(); ctx.moveTo(pos + 0.5, 0); ctx.lineTo(pos + 0.5, canvas.height); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, pos + 0.5); ctx.lineTo(canvas.width, pos + 0.5); ctx.stroke();
      }
    }

    function renderCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      if (isPlaying) {
        const frame = layers[playIndex];
        if (frame && frame.visible) {
          ctx.globalAlpha = 1.0; // preview as final frame
          drawLayerPixels(frame.pixels);
          ctx.globalAlpha = 1.0;
        }
      } else {
        // Composite visible layers bottom to top with their opacities
        layers.forEach((layer, idx) => {
          if (!layer.visible) return;
          ctx.globalAlpha = layer.opacity;
          drawLayerPixels(layer.pixels);
        });
        ctx.globalAlpha = 1.0;
      }

      drawGrid();

      // Update selection box if exists
      if (selectedPixelData || isSelecting || isDragging) {
        updateSelectionBox(isDragging);
      } else {
        selectionBox.classList.add('hidden');
      }
    }

    function drawLayerPixels(pixels) {
      for (let y = 0; y < gridResolution; y++) {
        for (let x = 0; x < gridResolution; x++) {
          const color = pixels[y][x];
          if (color) {
            ctx.fillStyle = color;
            ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
          }
        }
      }
    }

    function getMousePos(evt) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
      const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
      return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY };
    }

    function drawOnActiveLayer(x, y) {
      const gridX = Math.floor(x / pixelSize);
      const gridY = Math.floor(y / pixelSize);
      if (gridX < 0 || gridX >= gridResolution || gridY < 0 || gridY >= gridResolution) return;
      const layer = layers[activeLayerIndex];
      if (!layer) return;
      layer.pixels[gridY][gridX] = (currentTool === 'eraser') ? null : currentColor;
      renderCanvas();
    }

    function handleStart(e) {
      e.preventDefault();
      const pos = getMousePos(e);
      if (currentTool === 'select') {
        if (selectedPixelData && pos.x >= selectionRect.x && pos.x <= selectionRect.x + selectionRect.w && pos.y >= selectionRect.y && pos.y <= selectionRect.y + selectionRect.h) {
          isDragging = true;
          dragStart = { x: pos.x - selectionRect.x, y: pos.y - selectionRect.y };
        } else {
          stampSelection();
          isSelecting = true;
          selectionRect.x = pos.x;
          selectionRect.y = pos.y;
          selectionRect.w = 0;
          selectionRect.h = 0;
        }
      } else {
        isDrawing = true;
        drawOnActiveLayer(pos.x, pos.y);
      }
    }

    function handleMove(e) {
      if (!isDrawing && !isSelecting && !isDragging) return;
      e.preventDefault();
      const pos = getMousePos(e);
      if (isDrawing) {
        drawOnActiveLayer(pos.x, pos.y);
      } else if (isSelecting) {
        selectionRect.w = pos.x - selectionRect.x;
        selectionRect.h = pos.y - selectionRect.y;
        updateSelectionBox();
      } else if (isDragging) {
        renderCanvas();
        selectionRect.x = pos.x - dragStart.x;
        selectionRect.y = pos.y - dragStart.y;
        // Preview floating selection
        const layer = layers[activeLayerIndex];
        if (layer && selectedPixelData) {
          ctx.globalAlpha = 0.7;
          for (const pixel of selectedPixelData) {
            ctx.fillStyle = pixel.color;
            const drawX = selectionRect.x + pixel.dx * pixelSize;
            const drawY = selectionRect.y + pixel.dy * pixelSize;
            ctx.fillRect(drawX, drawY, pixelSize, pixelSize);
          }
          ctx.globalAlpha = 1.0;
        }
        updateSelectionBox(true);
      }
    }

    function handleEnd(e) {
      e.preventDefault();
      isDrawing = false;
      if (isSelecting) {
        isSelecting = false;
        captureSelection();
      }
      if (isDragging) {
        isDragging = false;
        stampSelection();
      }
    }

    function updateSelectionBox(isDraggingBox = false) {
      const sx = Math.min(selectionRect.x, selectionRect.x + selectionRect.w);
      const sy = Math.min(selectionRect.y, selectionRect.y + selectionRect.h);
      const sw = Math.abs(selectionRect.w);
      const sh = Math.abs(selectionRect.h);
      selectionBox.classList.remove('hidden');
      selectionBox.style.left = `${sx}px`;
      selectionBox.style.top = `${sy}px`;
      selectionBox.style.width = `${sw}px`;
      selectionBox.style.height = `${sh}px`;
      selectionBox.classList.toggle('border-dashed', !isDraggingBox);
      selectionBox.classList.toggle('border-solid', isDraggingBox);
    }

    function captureSelection() {
      const startX = Math.floor(Math.min(selectionRect.x, selectionRect.x + selectionRect.w) / pixelSize);
      const startY = Math.floor(Math.min(selectionRect.y, selectionRect.y + selectionRect.h) / pixelSize);
      const endX = Math.ceil(Math.max(selectionRect.x, selectionRect.x + selectionRect.w) / pixelSize);
      const endY = Math.ceil(Math.max(selectionRect.y, selectionRect.y + selectionRect.h) / pixelSize);
      const layer = layers[activeLayerIndex];
      if (!layer) return;
      selectedPixelData = [];
      for (let y = startY; y < endY; y++) {
        for (let x = startX; x < endX; x++) {
          if (y >= 0 && y < gridResolution && x >= 0 && x < gridResolution && layer.pixels[y][x]) {
            selectedPixelData.push({ color: layer.pixels[y][x], dx: x - startX, dy: y - startY });
            layer.pixels[y][x] = null; // cut
          }
        }
      }
      if (selectedPixelData.length > 0) {
        selectionRect = { x: startX * pixelSize, y: startY * pixelSize, w: (endX - startX) * pixelSize, h: (endY - startY) * pixelSize };
        renderCanvas();
        updateSelectionBox(true);
      } else {
        resetSelection();
      }
    }

    function stampSelection() {
      if (!selectedPixelData) { resetSelection(); return; }
      const gridX = Math.round(selectionRect.x / pixelSize);
      const gridY = Math.round(selectionRect.y / pixelSize);
      const layer = layers[activeLayerIndex];
      if (!layer) { resetSelection(); return; }
      for (const pixel of selectedPixelData) {
        const finalX = gridX + pixel.dx;
        const finalY = gridY + pixel.dy;
        if (finalY >= 0 && finalY < gridResolution && finalX >= 0 && finalX < gridResolution) {
          layer.pixels[finalY][finalX] = pixel.color;
        }
      }
      resetSelection();
      renderCanvas();
    }

    function resetSelection() {
      selectedPixelData = null;
      selectionBox.classList.add('hidden');
    }

    // Grid resolution change
    document.getElementById('grid-resolution').addEventListener('change', (e) => {
      const newRes = parseInt(e.target.value, 10);
      gridResolution = newRes;
      layers.forEach(l => { l.pixels = Array(gridResolution).fill(0).map(() => Array(gridResolution).fill(null)); });
      resizeAndRender();
    });

    // Tools
    const toolButtons = document.querySelectorAll('.tool-btn');
    toolButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        toolButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentTool = btn.id.replace('-tool', '');
        if (currentTool !== 'select') resetSelection();
      });
    });

    // Layers controls
    document.getElementById('add-layer-btn').addEventListener('click', () => addLayer());

    // Playback controls
    document.getElementById('play-btn').addEventListener('click', () => {
      if (isPlaying || layers.length === 0) return;
      isPlaying = true;
      playIndex = 0;
      const frameMs = Math.max(50, parseInt(document.getElementById('frame-duration').value, 10) || 300);
      playTimer = setInterval(() => {
        playIndex = (playIndex + 1) % layers.length;
        renderCanvas();
      }, frameMs);
      renderCanvas();
    });
    document.getElementById('stop-btn').addEventListener('click', () => {
      isPlaying = false; if (playTimer) clearInterval(playTimer); playTimer = null; renderCanvas();
    });

    // Export helpers
    function renderLayerToCanvas(layer, exportSize) {
      const temp = document.createElement('canvas');
      temp.width = exportSize; temp.height = exportSize;
      const tctx = temp.getContext('2d');
      tctx.fillStyle = '#ffffff'; tctx.fillRect(0, 0, exportSize, exportSize);
      const exportPixel = exportSize / gridResolution;
      for (let y = 0; y < gridResolution; y++) {
        for (let x = 0; x < gridResolution; x++) {
          const color = layer.pixels[y][x];
          if (color) { tctx.fillStyle = color; tctx.fillRect(x * exportPixel, y * exportPixel, exportPixel, exportPixel); }
        }
      }
      return temp;
    }

    document.getElementById('export-active-btn').addEventListener('click', () => {
      const exportSize = parseInt(document.getElementById('export-size').value, 10) || 512;
      const layer = layers[activeLayerIndex];
      if (!layer) return;
      const c = renderLayerToCanvas(layer, exportSize);
      c.toBlob((blob) => { if (blob) saveAs(blob, `${layer.name.replace(/\s+/g, '_')}.png`); });
    });

    document.getElementById('export-all-btn').addEventListener('click', async () => {
      const exportSize = parseInt(document.getElementById('export-size').value, 10) || 512;
      const zip = new JSZip();
      for (let i = 0; i < layers.length; i++) {
        const layer = layers[i];
        const c = renderLayerToCanvas(layer, exportSize);
        // eslint-disable-next-line no-await-in-loop
        const blob = await new Promise(resolve => c.toBlob(resolve));
        if (blob) zip.file(`${String(i+1).padStart(2,'0')}_${layer.name.replace(/\s+/g, '_')}.png`, blob);
      }
      const zipBlob = await zip.generateAsync({ type: 'blob' });
      saveAs(zipBlob, 'pixel-sprint-layers.zip');
    });

    // Image import (palette quantization) into active layer
    function hexToRgb(hex) {
      const clean = hex.replace('#', '');
      const num = parseInt(clean, 16);
      return { r: (num >> 16) & 255, g: (num >> 8) & 255, b: num & 255 };
    }

    function nearestPaletteColor(r, g, b) {
      let best = colors[0];
      let bestDist = Infinity;
      for (const c of colors) {
        const rgb = hexToRgb(c);
        const dr = r - rgb.r; const dg = g - rgb.g; const db = b - rgb.b;
        const dist = dr * dr + dg * dg + db * db;
        if (dist < bestDist) { bestDist = dist; best = c; }
      }
      return best;
    }

    function importImageIntoActiveLayer(file) {
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => {
        const small = document.createElement('canvas');
        small.width = gridResolution; small.height = gridResolution;
        const sctx = small.getContext('2d');
        sctx.imageSmoothingEnabled = true;
        sctx.clearRect(0, 0, small.width, small.height);
        sctx.drawImage(img, 0, 0, small.width, small.height);
        const data = sctx.getImageData(0, 0, small.width, small.height).data;
        const layer = layers[activeLayerIndex]; if (!layer) { URL.revokeObjectURL(url); return; }
        for (let y = 0; y < gridResolution; y++) {
          for (let x = 0; x < gridResolution; x++) {
            const idx = (y * gridResolution + x) * 4;
            const r = data[idx], g = data[idx + 1], b = data[idx + 2], a = data[idx + 3];
            if (a < 8) layer.pixels[y][x] = null; else layer.pixels[y][x] = nearestPaletteColor(r, g, b);
          }
        }
        renderCanvas();
        URL.revokeObjectURL(url);
      };
      img.onerror = () => URL.revokeObjectURL(url);
      img.src = url;
    }

    const importBtn = document.getElementById('import-btn');
    const imageInput = document.getElementById('image-input');
    importBtn.addEventListener('click', () => imageInput.click());
    imageInput.addEventListener('change', (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      stampSelection();
      resetSelection();
      importImageIntoActiveLayer(file);
      imageInput.value = '';
    });

    // Canvas events
    canvas.addEventListener('mousedown', handleStart);
    canvas.addEventListener('mousemove', handleMove);
    canvas.addEventListener('mouseup', handleEnd);
    canvas.addEventListener('mouseleave', handleEnd);
    canvas.addEventListener('touchstart', handleStart, { passive: false });
    canvas.addEventListener('touchmove', handleMove, { passive: false });
    canvas.addEventListener('touchend', handleEnd, { passive: false });
    canvas.addEventListener('touchcancel', handleEnd, { passive: false });

    window.addEventListener('resize', resizeAndRender);

    // Init
    function init() {
      setLanguage('en');
      layers = [];
      addLayer();
      resizeAndRender();
    }
    init();
  </script>
</body>
</html>



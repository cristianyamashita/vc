<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Whiteboard</title>
  <link rel="stylesheet" href="../../assets/fontawesome/css/all.min.css" />
  <style>
    /* Ensure local Font Awesome webfonts are available to canvas */
 
    /* Aliases for FA7 family names to local fonts */
    @font-face {
      font-family: 'Font Awesome 7 Free';
      font-style: normal;
      font-weight: 900;
      src: url('../../assets/fontawesome/webfonts/fa-solid-900.woff2') format('woff2');
      font-display: swap;
    }
    @font-face {
      font-family: 'Font Awesome 7 Free';
      font-style: normal;
      font-weight: 400;
      src: url('../../assets/fontawesome/webfonts/fa-regular-400.woff2') format('woff2');
      font-display: swap;
    }
    @font-face {
      font-family: 'Font Awesome 7 Brands';
      font-style: normal;
      font-weight: 400;
      src: url('../../assets/fontawesome/webfonts/fa-brands-400.woff2') format('woff2');
      font-display: swap;
    }
    :root {
      --bg: #0f1220;
      --panel: #161a2e;
      --panel-2: #1e2342;
      --text: #e8ecff;
      --muted: #9aa4c7;
      --accent: #7c8cff;
      --accent-2: #4de2cf;
      --danger: #ff6b6b;
      --tool-size: 44px;
      --toolbar-width: 64px;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: radial-gradient(1200px 800px at 10% -10%, #1b1f3b 0%, #0f1220 60%), #0f1220;
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      overflow: hidden;
      user-select: none;
    }
    body.theme-light {
      background: #ffffff;
      color: #0f1220;
    }
    .app {
      display: grid;
      grid-template-columns: var(--toolbar-width) 1fr 320px;
      grid-template-rows: 42px 1fr 36px;
      grid-template-areas:
        "toolbar topbar topbar"
        "toolbar stage sidebar"
        "toolbar bottombar bottombar";
      height: 100vh;
      width: 100vw;
    }
    .toolbar {
      grid-area: toolbar;
      background: linear-gradient(180deg, var(--panel) 0%, var(--panel-2) 100%);
      border-right: 1px solid rgba(255,255,255,0.08);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 8px 6px;
      gap: 8px;
    }
    .tool-btn {
      width: var(--tool-size);
      height: var(--tool-size);
      border-radius: 12px;
      background: rgba(255,255,255,0.04);
      display: grid; place-items: center;
      color: var(--text);
      cursor: pointer;
      border: 1px solid rgba(255,255,255,0.06);
      transition: 120ms ease;
    }
    .tool-btn:hover { background: rgba(255,255,255,0.08); }
    .tool-btn.active { outline: 2px solid var(--accent); background: rgba(124,140,255,0.16); }
    .tool-divider { height: 1px; width: 100%; background: rgba(255,255,255,0.08); margin: 6px 0; }

    .topbar {
      grid-area: topbar;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 10px;
      padding: 6px 10px;
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }

    .bottombar {
      grid-area: bottombar;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.04));
      border-top: 1px solid rgba(255,255,255,0.08);
      display: flex; align-items: center; gap: 8px; padding: 6px 10px; overflow-x: auto;
    }
    .tab {
      display: inline-flex; align-items: center; gap: 6px; padding: 4px 8px; border-radius: 8px;
      background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); color: var(--text); cursor: pointer;
    }
    .tab.active { outline: 2px solid var(--accent); background: rgba(124,140,255,0.16); }
    .tab .close { background: transparent; border: none; color: inherit; cursor: pointer; }

    .sidebar {
      grid-area: sidebar;
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      border-left: 1px solid rgba(255,255,255,0.08);
      display: flex; flex-direction: column; gap: 12px;
      padding: 10px 12px; overflow: auto;
    }

    .stage {
      grid-area: stage;
      position: relative;
      background: radial-gradient(1200px 800px at 90% 110%, rgba(124,140,255,0.08), transparent 60%), transparent;
      overflow: hidden;
    }
    #viewport { position: absolute; inset: 0; transform-origin: 0 0; }
    canvas#grid { position: absolute; inset: 0; width: 100%; height: 100%; display: block; }
    canvas#board { position: absolute; inset: 0; width: 100%; height: 100%; display: block; }
    canvas#overlay { position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none; }
    body.theme-light .stage { background: #ffffff; }

    .floating-input {
      position: absolute; z-index: 20; background: transparent; color: var(--text);
      border: 1px dashed var(--accent);
      min-width: 80px; min-height: 28px; padding: 4px 6px; outline: none;
      font: 24px/1.2 "Helvetica Neue", Arial, sans-serif;
      user-select: text; pointer-events: auto; caret-color: var(--text);
      background: rgba(0,0,0,0.25);
      white-space: pre-wrap;
    }
    body.theme-light .floating-input { color: #0f1220; caret-color: #0f1220; background: rgba(0,0,0,0.06); border-color: #7c8cff; }

    .lang-select { margin-left: auto; }

    .hint { color: var(--muted); font-size: 12px; }

    .hidden { display: none !important; }

    .tooltip { position: relative; }
    .tooltip[data-title]::after {
      content: attr(data-title);
      position: absolute; left: calc(100% + 8px); top: 50%; transform: translateY(-50%);
      background: rgba(0,0,0,0.72); color: white; padding: 6px 8px; border-radius: 6px; font-size: 12px;
      white-space: nowrap; opacity: 0; pointer-events: none; transition: 120ms ease; border: 1px solid rgba(255,255,255,0.12);
    }
    .tooltip:hover::after { opacity: 1; }

    .icon-picker {
      position: absolute; left: calc(var(--toolbar-width) + 12px); top: 72px;
      background: var(--panel-2); border: 1px solid rgba(255,255,255,0.12); border-radius: 10px;
      padding: 8px; display: grid; grid-template-columns: repeat(6, 36px); gap: 8px; z-index: 15;
    }
    .icon-picker button { width: 36px; height: 36px; border-radius: 8px; display: grid; place-items: center; cursor: pointer; }

    .selection-rect { position: absolute; border: 1px dashed #fff; box-shadow: 0 0 0 1px rgba(124,140,255,0.6) inset; pointer-events: none; }
    .handle { position: absolute; width: 10px; height: 10px; background: #fff; border-radius: 2px; border: 1px solid #000; box-shadow: 0 0 0 1px rgba(124,140,255,0.6); pointer-events: auto; }
    .handle.nw { left: -5px; top: -5px; cursor: nwse-resize; }
    .handle.ne { right: -5px; top: -5px; cursor: nesw-resize; }
    .handle.sw { left: -5px; bottom: -5px; cursor: nesw-resize; }
    .handle.se { right: -5px; bottom: -5px; cursor: nwse-resize; }
    .handle.rot { left: 50%; top: -22px; transform: translateX(-50%); width: 12px; height: 12px; border-radius: 50%; cursor: grab; }
    
  </style>
</head>
<body>
  <div class="app">
    <aside class="toolbar" id="toolbar">
      <div class="tool-btn tooltip active" data-tool="pen" data-title="Pen">
        <i class="fa-solid fa-pen"></i>
      </div>
      <div class="tool-btn tooltip" data-tool="marker" data-title="Marker">
        <i class="fa-solid fa-highlighter"></i>
      </div>
      <div class="tool-btn tooltip" data-tool="eraser" data-title="Eraser">
        <i class="fa-solid fa-eraser"></i>
      </div>
      <div class="tool-divider"></div>
      <div class="tool-btn tooltip" data-tool="line" data-title="Line">
        <i class="fa-solid fa-slash"></i>
      </div>
      <div class="tool-btn tooltip" data-tool="rect" data-title="Rectangle">
        <i class="fa-regular fa-square"></i>
      </div>
      <div class="tool-btn tooltip" data-tool="ellipse" data-title="Ellipse">
        <i class="fa-regular fa-circle"></i>
      </div>
      <div class="tool-btn tooltip" data-tool="triangle" data-title="Triangle">
        <i class="fa-solid fa-caret-up"></i>
      </div>
      <div class="tool-btn tooltip" data-tool="polygon" data-title="Polygon">
        <i class="fa-solid fa-draw-polygon"></i>
      </div>
      <div class="tool-btn tooltip" data-tool="star" data-title="Star">
        <i class="fa-solid fa-star"></i>
      </div>
      <div class="tool-btn tooltip" data-tool="eyedropper" data-title="Eyedropper">
        <i class="fa-solid fa-eye-dropper"></i>
      </div>
      <div class="tool-divider"></div>
      <div class="tool-btn tooltip" data-tool="text" data-title="Text">
        <i class="fa-solid fa-font"></i>
      </div>
      <div class="tool-btn tooltip" data-tool="icon" data-title="Icons">
        <i class="fa-solid fa-icons"></i>
      </div>
      <div class="tool-btn tooltip" data-tool="hand" data-title="Hand/Pan">
        <i class="fa-solid fa-arrows-up-down-left-right"></i>
      </div>
      <div class="tool-btn tooltip" data-tool="select" data-title="Select/Move">
        <i class="fa-regular fa-object-group"></i>
      </div>
      <div class="tool-divider"></div>
      <div class="tool-btn tooltip" id="undoBtn" data-title="Undo">
        <i class="fa-solid fa-rotate-left"></i>
      </div>
      <div class="tool-btn tooltip" id="redoBtn" data-title="Redo">
        <i class="fa-solid fa-rotate-right"></i>
      </div>
      <div class="tool-btn tooltip" id="importBtn" data-title="Import">
        <i class="fa-solid fa-upload"></i>
      </div>
      <div class="tool-btn tooltip" id="exportBtn" data-title="Export">
        <i class="fa-solid fa-download"></i>
      </div>
      <div class="tool-btn tooltip" id="fullscreenBtn" data-title="Fullscreen">
        <i class="fa-solid fa-maximize"></i>
      </div>
      <input type="file" id="fileInput" accept="image/*" class="hidden" />
    </aside>

    <main class="stage" id="stage">
      <div id="viewport">
        <canvas id="grid"></canvas>
        <canvas id="board"></canvas>
        <canvas id="overlay"></canvas>
        <div id="selectionBox" class="selection-rect hidden">
          <div class="handle nw" data-dir="nw"></div>
          <div class="handle ne" data-dir="ne"></div>
          <div class="handle sw" data-dir="sw"></div>
          <div class="handle se" data-dir="se"></div>
          <div class="handle rot" data-dir="rot"></div>
        </div>
        <div id="iconPicker" class="icon-picker hidden">
          <button data-ic="fa-star" title="star"><i class="fa-solid fa-star"></i></button>
          <button data-ic="fa-heart" title="heart"><i class="fa-solid fa-heart"></i></button>
          <button data-ic="fa-check" title="check"><i class="fa-solid fa-check"></i></button>
          <button data-ic="fa-bolt" title="bolt"><i class="fa-solid fa-bolt"></i></button>
          <button data-ic="fa-face-smile" title="smile"><i class="fa-regular fa-face-smile"></i></button>
          <button data-ic="fa-circle" title="circle"><i class="fa-regular fa-circle"></i></button>
          <button data-ic="fa-square" title="square"><i class="fa-regular fa-square"></i></button>
          <button data-ic="fa-triangle-exclamation" title="warn"><i class="fa-solid fa-triangle-exclamation"></i></button>
          <button data-ic="fa-mug-hot" title="mug"><i class="fa-solid fa-mug-hot"></i></button>
          <button data-ic="fa-paper-plane" title="plane"><i class="fa-regular fa-paper-plane"></i></button>
          <button data-ic="fa-lightbulb" title="bulb"><i class="fa-regular fa-lightbulb"></i></button>
          <button data-ic="fa-arrow-right" title="arrow"><i class="fa-solid fa-arrow-right"></i></button>
        </div>
      </div>
    </main>

    <header class="topbar" id="topbar">
      <div class="group" id="themeGroup" style="margin-left:auto">
        <label id="lblTheme">Theme</label>
        <select id="theme">
          <option value="dark">Dark</option>
          <option value="light">Light</option>
        </select>
      </div>
      <div class="group" id="gridGroupTop">
        <label id="lblGrid">Grid</label>
        <input type="checkbox" id="gridToggle" />
        <label id="lblGridType">Grid</label>
        <select id="gridType"><option value="lines">Lines</option><option value="dots">Dots</option></select>
        <label id="lblGridSize">Size</label>
        <input type="range" id="gridSize" min="8" max="64" value="24" />
      </div>
      <div class="group" id="autosaveGroup">
        <label id="lblAutosave">Autosave</label>
        <input type="checkbox" id="autosaveToggle" />
        <button id="saveNowBtn">Save now</button>
      </div>
      <div class="group" id="clearGroup">
        <button id="clearBtn">Clear</button>
      </div>
      <div class="group" id="langGroup">
        <label>Lang</label>
        <select id="lang">
          <option value="en">English</option>
          <option value="ja">日本語</option>
          <option value="pt">Português</option>
        </select>
      </div>
    </header>

    <aside class="sidebar" id="sidebar">
      <div class="group" id="colorGroup">
        <label id="lblColor">Color</label>
        <input type="color" id="color" value="#4de2cf" />
        <button id="sw1" style="background:#ff6b6b" aria-label="Red"></button>
        <button id="sw2" style="background:#ffd166" aria-label="Yellow"></button>
        <button id="sw3" style="background:#06d6a0" aria-label="Green"></button>
        <button id="sw4" style="background:#7c8cff" aria-label="Blue"></button>
        <button id="sw5" style="background:#ffffff" aria-label="White"></button>
        <button id="sw6" style="background:#000000" aria-label="Black"></button>
        <div class="group" id="opacityGroup">
          <label id="lblOpacity">Opacity</label>
          <input type="range" id="opacity" min="0" max="1" value="1" step="0.05" />
        </div>
      </div>
      <div class="group" id="recentGroup">
        <label id="lblRecent">Recent</label>
        <div id="recentColors" style="display:flex;gap:6px"></div>
      </div>
      <div class="group" id="sizeGroup">
        <label id="lblSize">Size</label>
        <input type="range" id="size" min="1" max="80" value="8" />
        <span id="sizeVal" class="hint">8</span>
      </div>
      <div class="group" id="lineOpts" hidden>
        <label id="lblArrowheads">Arrowheads</label>
        <input type="checkbox" id="arrowheadsToggle" />
        <label id="lblArrowSize">Arrow Size</label>
        <input type="range" id="arrowSize" min="6" max="60" value="24" />
        <label id="lblDash">Dashed</label>
        <input type="checkbox" id="dashToggle" />
        <label id="lblDashLen">Dash</label>
        <input type="range" id="dashLen" min="2" max="40" value="8" />
      </div>
      <div class="group" id="shapeOpts" hidden>
        <label id="lblFill">Fill</label>
        <input type="checkbox" id="fillToggle" />
        <label id="lblRadius">Radius</label>
        <input type="range" id="cornerRadius" min="0" max="60" value="0" />
      </div>
      <div class="group" id="drawOpts" hidden>
        <label id="lblSmooth">Smooth</label>
        <input type="checkbox" id="smoothingToggle" checked />
      </div>
      <div class="group" id="textOpts" hidden>
        <label id="lblFont">Font</label>
        <select id="fontFamily">
          <option value="system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif">System UI</option>
          <option value="Arial, Helvetica, sans-serif">Arial</option>
          <option value="Times New Roman, Times, serif">Times New Roman</option>
          <option value="Georgia, serif">Georgia</option>
          <option value="Helvetica, Arial, sans-serif">Helvetica</option>
          <option value="Courier New, Courier, monospace">Courier New</option>
          <option value="&quot;Noto Sans JP&quot;, system-ui, sans-serif">日本語 (Noto Sans JP)</option>
        </select>
        <label id="lblAlign">Align</label>
        <select id="textAlign">
          <option value="left">Left</option>
          <option value="center">Center</option>
          <option value="right">Right</option>
        </select>
        <label id="lblBold">Bold</label>
        <input type="checkbox" id="textBold" />
        <label id="lblItalic">Italic</label>
        <input type="checkbox" id="textItalic" />
      </div>
      <div class="hint" id="status">Ready</div>
      <div class="group" id="polygonOpts">
        <label id="lblSides">Sides</label>
        <input type="range" id="polySides" min="3" max="12" value="5" />
      </div>
      <div class="group" id="starOpts">
        <label id="lblPoints">Points</label>
        <input type="range" id="starPoints" min="3" max="12" value="5" />
        <label id="lblInner">Inner</label>
        <input type="range" id="starInner" min="0.2" max="0.9" step="0.05" value="0.5" />
      </div>
      <div class="group" id="viewGroup">
        <label>Zoom</label>
        <button id="zoomOutBtn">-</button>
        <input type="range" id="zoom" min="0.25" max="4" step="0.05" value="1" />
        <button id="zoomInBtn">+</button>
        <button id="zoomResetBtn">Reset</button>
      </div>
    </aside>
    <footer class="bottombar" id="tabsBar">
      <div id="tabs" style="display:flex;gap:6px;align-items:center"></div>
      <button id="addTabBtn" style="margin-left:auto">＋</button>
    </footer>
  </div>

  <script>
    // i18n strings (EN, JA, PT)
    const STRINGS = {
      en: {
        Pen: 'Pen', Marker: 'Marker', Eraser: 'Eraser', Line: 'Line', Rectangle: 'Rectangle', Ellipse: 'Ellipse', Triangle: 'Triangle', Polygon: 'Polygon', Star: 'Star', Eyedropper: 'Eyedropper', Hand: 'Hand',
        Text: 'Text', Icons: 'Icons', SelectMove: 'Select/Move', Undo: 'Undo', Redo: 'Redo', Import: 'Import', Export: 'Export', Fullscreen: 'Fullscreen',
        Color: 'Color', Size: 'Size', Fill: 'Fill', Opacity: 'Opacity', Font: 'Font', Arrowheads: 'Arrowheads', Radius: 'Radius', Recent: 'Recent',
        Smooth: 'Smooth', Grid: 'Grid', GridSize: 'Grid Size', Align: 'Align', Bold: 'Bold', Italic: 'Italic', GridType: 'Grid Type', Sides: 'Sides', Points: 'Points', Inner: 'Inner',
        Theme: 'Theme', Dark: 'Dark', Light: 'Light', Autosave: 'Autosave', SaveNow: 'Save now', ArrowSize: 'Arrow Size', Dashed: 'Dashed', Dash: 'Dash'
      },
      ja: {
        Pen: 'ペン', Marker: 'マーカー', Eraser: '消しゴム', Line: '直線', Rectangle: '四角形', Ellipse: '楕円', Triangle: '三角形', Polygon: '多角形', Star: '星', Eyedropper: 'スポイト', Hand: 'ハンド',
        Text: 'テキスト', Icons: 'アイコン', SelectMove: '選択/移動', Undo: '元に戻す', Redo: 'やり直し', Import: 'インポート', Export: 'エクスポート', Fullscreen: '全画面',
        Color: '色', Size: 'サイズ', Fill: '塗り', Opacity: '不透明度', Font: 'フォント', Arrowheads: '矢じり', Radius: '角丸', Recent: '最近',
        Smooth: 'スムージング', Grid: 'グリッド', GridSize: 'グリッドサイズ', Align: '配置', Bold: '太字', Italic: '斜体', GridType: 'グリッドタイプ', Sides: '辺数', Points: '点数', Inner: '内側',
        Theme: 'テーマ', Dark: 'ダーク', Light: 'ライト', Autosave: '自動保存', SaveNow: '今すぐ保存', ArrowSize: '矢じりサイズ', Dashed: '破線', Dash: 'ダッシュ'
      },
      pt: {
        Pen: 'Caneta', Marker: 'Marcador', Eraser: 'Borracha', Line: 'Linha', Rectangle: 'Retângulo', Ellipse: 'Elipse', Triangle: 'Triângulo', Polygon: 'Polígono', Star: 'Estrela', Eyedropper: 'Conta-gotas', Hand: 'Mão',
        Text: 'Texto', Icons: 'Ícones', SelectMove: 'Selecionar/Mover', Undo: 'Desfazer', Redo: 'Refazer', Import: 'Importar', Export: 'Exportar', Fullscreen: 'Tela cheia',
        Color: 'Cor', Size: 'Tamanho', Fill: 'Preenchimento', Opacity: 'Opacidade', Font: 'Fonte', Arrowheads: 'Pontas de seta', Radius: 'Raio', Recent: 'Recentes',
        Smooth: 'Suavizar', Grid: 'Grade', GridSize: 'Tamanho da grade', Alinhar: 'Alinhar', Bold: 'Negrito', Italic: 'Itálico', GridType: 'Tipo de grade', Sides: 'Lados', Points: 'Pontos', Inner: 'Interno',
        Theme: 'Tema', Dark: 'Escuro', Light: 'Claro', Autosave: 'Auto salvar', SaveNow: 'Salvar agora', ArrowSize: 'Tam. seta', Dashed: 'Tracejado', Dash: 'Traço'
      }
    };

    const qs = (sel, el=document)=>el.querySelector(sel);
    const qsa = (sel, el=document)=>Array.from(el.querySelectorAll(sel));

    const grid = qs('#grid');
    const board = qs('#board');
    const overlay = qs('#overlay');
    const stage = qs('#stage');
    const viewport = qs('#viewport');
    const toolbar = qs('#toolbar');
    const selectionBox = qs('#selectionBox');
    const iconPicker = qs('#iconPicker');

    const colorEl = qs('#color');
    const sizeEl = qs('#size');
    const sizeVal = qs('#sizeVal');
    const fillToggle = qs('#fillToggle');
    const opacityEl = qs('#opacity');
    const fontFamilyEl = qs('#fontFamily');
    const langEl = qs('#lang');
    const recentColorsEl = qs('#recentColors');
    const arrowheadsToggle = qs('#arrowheadsToggle');
    const cornerRadiusEl = qs('#cornerRadius');
    const smoothingToggle = qs('#smoothingToggle');
    const gridToggle = qs('#gridToggle');
    const gridTypeEl = qs('#gridType');
    const gridSizeEl = qs('#gridSize');
    const textAlignEl = qs('#textAlign');
    const textBoldEl = qs('#textBold');
    const textItalicEl = qs('#textItalic');
    const statusEl = qs('#status');
    const themeEl = qs('#theme');
    const autosaveToggle = qs('#autosaveToggle');
    const saveNowBtn = qs('#saveNowBtn');
    const arrowSizeEl = qs('#arrowSize');
    const dashToggle = qs('#dashToggle');
    const dashLenEl = qs('#dashLen');
    // Polygon/Star and Zoom controls
    const polySidesInput = qs('#polySides');
    const starPointsInput = qs('#starPoints');
    const starInnerInput = qs('#starInner');
    const zoomInput = qs('#zoom');

    const undoBtn = qs('#undoBtn');
    const redoBtn = qs('#redoBtn');
    const importBtn = qs('#importBtn');
    const exportBtn = qs('#exportBtn');
    const fullscreenBtn = qs('#fullscreenBtn');
    const fileInput = qs('#fileInput');
    const clearBtn = qs('#clearBtn');
    const tabsBar = qs('#tabsBar');
    const tabsEl = qs('#tabs');
    const addTabBtn = qs('#addTabBtn');

    const PREF_THEME_KEY = 'whiteboard_pref_theme';
    const PREF_LANG_KEY = 'whiteboard_pref_lang';
    const PREF_AUTOSAVE_KEY = 'whiteboard_pref_autosave';
    const PREF_SIZE_KEY = 'whiteboard_pref_size';
    const PREF_COLOR_KEY = 'whiteboard_pref_color';
    const PREF_OPACITY_KEY = 'whiteboard_pref_opacity';
    const PREF_SMOOTH_KEY = 'whiteboard_pref_smooth';
    const PREF_GRID_KEY = 'whiteboard_pref_grid';
    const PREF_GRID_TYPE_KEY = 'whiteboard_pref_grid_type';
    const PREF_GRID_SIZE_KEY = 'whiteboard_pref_grid_size';
    const PREF_FONT_KEY = 'whiteboard_pref_font';
    const PREF_ALIGN_KEY = 'whiteboard_pref_align';
    const PREF_BOLD_KEY = 'whiteboard_pref_bold';
    const PREF_ITALIC_KEY = 'whiteboard_pref_italic';
    const PREF_FILL_KEY = 'whiteboard_pref_fill';
    const PREF_RADIUS_KEY = 'whiteboard_pref_radius';
    const PREF_ARROWHEADS_KEY = 'whiteboard_pref_arrowheads';
    const PREF_ARROW_SIZE_KEY = 'whiteboard_pref_arrow_size';
    const PREF_DASH_KEY = 'whiteboard_pref_dash';
    const PREF_DASH_LEN_KEY = 'whiteboard_pref_dash_len';
    const PREF_RECENT_COLORS_KEY = 'whiteboard_recent_colors';
    const PREF_ZOOM_KEY = 'whiteboard_pref_zoom';
    const TABS_META_KEY = 'whiteboard_tabs_meta';
    const TAB_PREFIX = 'whiteboard_tab_';
    let savedLang = localStorage.getItem(PREF_LANG_KEY);
    let lang = savedLang || ((navigator.language || 'en').startsWith('ja') ? 'ja' : (navigator.language || 'en').startsWith('pt') ? 'pt' : 'en');
    langEl.value = lang;

    // Canvas contexts
    const gctx = grid.getContext('2d');
    const ctx = board.getContext('2d');
    const octx = overlay.getContext('2d');

    // State
    let tool = 'pen';
    let drawing = false;
    let startX = 0, startY = 0;
    let lastX = 0, lastY = 0;
    let dpr = Math.max(1, window.devicePixelRatio || 1);
    let viewScale = 1;
    let viewOffsetX = 0;
    let viewOffsetY = 0;
    let tabs = [];
    let activeTabId = null;

    let history = [];
    let future = [];
    const HISTORY_LIMIT = 30;

    // Selection floating buffer
    let selection = null; // { x,y,w,h, canvas, offsetX, offsetY, moving, resizing, handle, rotating, rotation }
    let internalClipboard = null; // { canvas }

    // Recent colors state
    const recentColors = [];

    function setCanvasSize() {
      const rect = stage.getBoundingClientRect();
      [grid, board, overlay].forEach(c => {
        c.width = Math.floor(rect.width * dpr);
        c.height = Math.floor(rect.height * dpr);
        c.style.width = rect.width + 'px';
        c.style.height = rect.height + 'px';
      });
      gctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      octx.setTransform(dpr, 0, 0, dpr, 0, 0);
      drawGrid();
      redraw();
    }

    function drawGrid() {
      gctx.clearRect(0, 0, grid.width, grid.height);
      if (!gridToggle.checked) return;
      const size = parseInt(gridSizeEl.value, 10) || 24;
      const rect = stage.getBoundingClientRect();
      const isLight = document.body.classList.contains('theme-light');
      gctx.save();
      const color = isLight ? 'rgba(0,0,0,0.08)' : 'rgba(255,255,255,0.06)';
      gctx.strokeStyle = color;
      gctx.fillStyle = color;
      if (gridTypeEl.value === 'lines') {
        gctx.lineWidth = 1;
        for (let x = 0; x <= rect.width; x += size) {
          gctx.beginPath(); gctx.moveTo(x + 0.5, 0); gctx.lineTo(x + 0.5, rect.height); gctx.stroke();
        }
        for (let y = 0; y <= rect.height; y += size) {
          gctx.beginPath(); gctx.moveTo(0, y + 0.5); gctx.lineTo(rect.width, y + 0.5); gctx.stroke();
        }
      } else {
        const r = 1.2;
        for (let x = 0; x <= rect.width; x += size) {
          for (let y = 0; y <= rect.height; y += size) {
            gctx.beginPath(); gctx.arc(x, y, r, 0, Math.PI*2); gctx.fill();
          }
        }
      }
      gctx.restore();
    }

    function pushHistory() {
      try {
        const snapshot = ctx.getImageData(0, 0, board.width, board.height);
        history.push(snapshot);
        if (history.length > HISTORY_LIMIT) history.shift();
        future = [];
        updateUndoRedoButtons();
        if (autosaveToggle.checked) saveToStorage();
      } catch (e) { /* ignore if too large */ }
    }

    function undo() {
      if (!history.length) return;
      const current = ctx.getImageData(0, 0, board.width, board.height);
      future.push(current);
      const prev = history.pop();
      ctx.putImageData(prev, 0, 0);
      updateUndoRedoButtons();
      redraw();
    }
    function redo() {
      if (!future.length) return;
      const current = ctx.getImageData(0, 0, board.width, board.height);
      history.push(current);
      const next = future.pop();
      ctx.putImageData(next, 0, 0);
      updateUndoRedoButtons();
      redraw();
    }
    function updateUndoRedoButtons() {
      undoBtn.style.opacity = history.length ? 1 : 0.5;
      redoBtn.style.opacity = future.length ? 1 : 0.5;
    }

    function clearOverlay() { octx.clearRect(0, 0, overlay.width, overlay.height); }

    function redraw() {
      clearOverlay();
      if (selection) drawSelectionOverlay();
    }

    function setTool(newTool) {
      tool = newTool;
      qsa('.tool-btn', toolbar).forEach(b => b.classList.remove('active'));
      const btn = qsa('.tool-btn', toolbar).find(b => b.dataset.tool === tool);
      if (btn) btn.classList.add('active');
      iconPicker.classList.toggle('hidden', tool !== 'icon');
      if (tool !== 'select') hideSelectionBox();
      statusEl.textContent = `Tool: ${btn ? btn.getAttribute('data-title') : tool}`;
      updateOptionVisibility();
    }

    function show(el, visible) { if (!el) return; el.hidden = !visible; }
    function updateOptionVisibility() {
      const isBrush = tool === 'pen' || tool === 'marker' || tool === 'eraser';
      const isLine = tool === 'line';
      const isShape = tool === 'rect' || tool === 'ellipse' || tool === 'triangle' || tool === 'polygon' || tool === 'star';
      const isText = tool === 'text';
      const isIcon = tool === 'icon';
      const isSelect = tool === 'select';
      const isDropper = tool === 'eyedropper';
      const isHand = tool === 'hand';

      const showColorish = (isBrush && tool !== 'eraser') || isLine || isShape || isText || isIcon || isHand;
      show(qs('#colorGroup'), showColorish);
      show(qs('#opacityGroup'), showColorish);
      show(qs('#recentGroup'), showColorish);
      show(qs('#sizeGroup'), !isSelect && !isDropper && !isHand);
      show(qs('#lineOpts'), isLine);
      show(qs('#shapeOpts'), isShape);
      // Only show radius when rect tool
      const lblR = qs('#lblRadius'); const rEl = qs('#cornerRadius');
      if (lblR && rEl) { lblR.style.display = rEl.style.display = (tool === 'rect') ? '' : 'none'; }
      show(qs('#drawOpts'), tool === 'pen' || tool === 'marker');
      show(qs('#textOpts'), isText);
      // Always show grid/theme/autosave/lang (grid now in topbar)
    }

    function getPos(evt) {
      const rect = stage.getBoundingClientRect();
      const x = (evt.clientX - rect.left - viewOffsetX) / viewScale;
      const y = (evt.clientY - rect.top - viewOffsetY) / viewScale;
      return { x, y };
    }

    // Cursor preview
    function drawCursorPreview(x, y) {
      if (drawing) return;
      if (!['pen','marker','eraser'].includes(tool)) { return; }
      clearOverlay();
      const r = parseInt(sizeEl.value,10) / 2;
      octx.save();
      octx.beginPath();
      octx.arc(x, y, Math.max(2, r), 0, Math.PI*2);
      octx.strokeStyle = 'rgba(255,255,255,0.6)';
      octx.lineWidth = 1;
      octx.stroke();
      octx.restore();
    }

    function applyDash(context) {
      if (dashToggle.checked) {
        const dl = parseInt(dashLenEl.value,10); context.setLineDash([dl, dl]);
      } else {
        context.setLineDash([]);
      }
    }

    function linePreview(x0, y0, x1, y1) {
      clearOverlay();
      octx.save();
      octx.lineCap = 'round';
      octx.lineJoin = 'round';
      octx.strokeStyle = colorEl.value;
      octx.globalAlpha = parseFloat(opacityEl.value || '1');
      octx.lineWidth = parseInt(sizeEl.value, 10);
      applyDash(octx);
      octx.beginPath();
      octx.moveTo(x0, y0);
      octx.lineTo(x1, y1);
      octx.stroke();
      if (arrowheadsToggle.checked) drawArrowhead(octx, x0, y0, x1, y1, octx.lineWidth);
      octx.restore();
    }

    function shapePreviewRect(x0, y0, x1, y1) {
      clearOverlay();
      const w = x1 - x0, h = y1 - y0;
      const r = Math.max(0, parseInt(cornerRadiusEl.value || '0', 10));
      octx.save();
      octx.lineWidth = Math.max(1, parseInt(sizeEl.value, 10));
      octx.strokeStyle = colorEl.value;
      octx.globalAlpha = parseFloat(opacityEl.value || '1');
      octx.beginPath();
      if (r > 0) pathRoundRect(octx, x0, y0, w, h, r); else octx.rect(x0, y0, w, h);
      if (fillToggle.checked) {
        octx.fillStyle = colorEl.value;
        octx.globalAlpha = Math.min(1, parseFloat(opacityEl.value || '1'));
        octx.fill();
        octx.globalAlpha = parseFloat(opacityEl.value || '1');
      }
      octx.stroke();
      octx.restore();
    }

    function shapePreviewEllipse(x0, y0, x1, y1) {
      clearOverlay();
      const cx = (x0 + x1) / 2; const cy = (y0 + y1) / 2;
      const rx = Math.abs(x1 - x0) / 2; const ry = Math.abs(y1 - y0) / 2;
      octx.save();
      octx.lineWidth = Math.max(1, parseInt(sizeEl.value, 10));
      octx.strokeStyle = colorEl.value;
      octx.globalAlpha = parseFloat(opacityEl.value || '1');
      octx.beginPath();
      octx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
      if (fillToggle.checked) {
        octx.fillStyle = colorEl.value;
        octx.globalAlpha = Math.min(1, parseFloat(opacityEl.value || '1'));
        octx.fill();
        octx.globalAlpha = parseFloat(opacityEl.value || '1');
      }
      octx.stroke();
      octx.restore();
    }

    function shapePreviewTriangle(x0, y0, x1, y1) {
      clearOverlay();
      const p1 = { x: (x0 + x1) / 2, y: y0 };
      const p2 = { x: x0, y: y1 };
      const p3 = { x: x1, y: y1 };
      octx.save();
      octx.lineWidth = Math.max(1, parseInt(sizeEl.value, 10));
      octx.strokeStyle = colorEl.value;
      octx.globalAlpha = parseFloat(opacityEl.value || '1');
      applyDash(octx);
      octx.beginPath();
      octx.moveTo(p1.x, p1.y);
      octx.lineTo(p2.x, p2.y);
      octx.lineTo(p3.x, p3.y);
      octx.closePath();
      if (fillToggle.checked) {
        octx.fillStyle = colorEl.value;
        octx.globalAlpha = Math.min(1, parseFloat(opacityEl.value || '1'));
        octx.fill();
        octx.globalAlpha = parseFloat(opacityEl.value || '1');
      }
      octx.stroke();
      octx.restore();
    }

    function shapePreviewPolygon(x0, y0, x1, y1) {
      clearOverlay();
      const cx = (x0 + x1) / 2; const cy = (y0 + y1) / 2;
      const rx = Math.abs(x1 - x0) / 2; const ry = Math.abs(y1 - y0) / 2;
      const n = parseInt(polySidesInput.value, 10);
      octx.save();
      octx.lineWidth = Math.max(1, parseInt(sizeEl.value, 10));
      octx.strokeStyle = colorEl.value;
      octx.globalAlpha = parseFloat(opacityEl.value || '1');
      applyDash(octx);
      octx.beginPath();
      for (let i=0;i<n;i++) {
        const a = -Math.PI/2 + i * (2*Math.PI/n);
        const x = cx + rx * Math.cos(a);
        const y = cy + ry * Math.sin(a);
        if (i===0) octx.moveTo(x,y); else octx.lineTo(x,y);
      }
      octx.closePath();
      if (fillToggle.checked) { octx.fillStyle = colorEl.value; octx.fill(); }
      octx.stroke();
      octx.restore();
    }

    function shapePreviewStar(x0, y0, x1, y1) {
      clearOverlay();
      const cx = (x0 + x1) / 2; const cy = (y0 + y1) / 2;
      const R = Math.max(Math.abs(x1 - x0), Math.abs(y1 - y0)) / 2;
      const n = parseInt(starPointsInput.value, 10);
      const inner = parseFloat(starInnerInput.value || '0.5') * R;
      octx.save();
      octx.lineWidth = Math.max(1, parseInt(sizeEl.value, 10));
      octx.strokeStyle = colorEl.value;
      octx.globalAlpha = parseFloat(opacityEl.value || '1');
      applyDash(octx);
      octx.beginPath();
      for (let i = 0; i < 2*n; i++) {
        const r = i % 2 === 0 ? R : inner;
        const a = -Math.PI/2 + i * (Math.PI / n);
        const x = cx + r * Math.cos(a);
        const y = cy + r * Math.sin(a);
        if (i===0) octx.moveTo(x,y); else octx.lineTo(x,y);
      }
      octx.closePath();
      if (fillToggle.checked) { octx.fillStyle = colorEl.value; octx.fill(); }
      octx.stroke();
      octx.restore();
    }

    function drawArrowhead(context, x0, y0, x1, y1, lw) {
      const angle = Math.atan2(y1 - y0, x1 - x0);
      const size = Math.max(6, parseInt(arrowSizeEl.value, 10));
      context.save();
      context.fillStyle = colorEl.value;
      context.globalAlpha = parseFloat(opacityEl.value || '1');
      context.beginPath();
      context.moveTo(x1, y1);
      context.lineTo(x1 - size * Math.cos(angle - Math.PI/6), y1 - size * Math.sin(angle - Math.PI/6));
      context.lineTo(x1 - size * Math.cos(angle + Math.PI/6), y1 - size * Math.sin(angle + Math.PI/6));
      context.closePath();
      context.fill();
      context.restore();
    }

    function pathRoundRect(context, x, y, w, h, r) {
      const rr = Math.min(Math.abs(r), Math.abs(w)/2, Math.abs(h)/2);
      const signW = Math.sign(w) || 1; const signH = Math.sign(h) || 1;
      const x0 = x, y0 = y, x1 = x + w, y1 = y + h;
      context.moveTo(x0 + rr*signW, y0);
      context.lineTo(x1 - rr*signW, y0);
      context.quadraticCurveTo(x1, y0, x1, y0 + rr*signH);
      context.lineTo(x1, y1 - rr*signH);
      context.quadraticCurveTo(x1, y1, x1 - rr*signW, y1);
      context.lineTo(x0 + rr*signW, y1);
      context.quadraticCurveTo(x0, y1, x0, y1 - rr*signH);
      context.lineTo(x0, y0 + rr*signH);
      context.quadraticCurveTo(x0, y0, x0 + rr*signW, y0);
    }

    // Freehand smoothing
    let strokePoints = [];
    function smoothStroke(points) {
      if (!smoothingToggle.checked || points.length < 3) return points;
      const smoothed = [points[0]];
      for (let i = 1; i < points.length - 1; i++) {
        const prev = points[i - 1];
        const curr = points[i];
        const next = points[i + 1];
        const mx1 = (prev.x + curr.x) / 2; const my1 = (prev.y + curr.y) / 2;
        const mx2 = (curr.x + next.x) / 2; const my2 = (curr.y + next.y) / 2;
        smoothed.push({ cx: curr.x, cy: curr.y, x: mx2, y: my2, q: true, mx1, my1 });
      }
      smoothed.push(points[points.length - 1]);
      return smoothed;
    }

    function commitLine(x0, y0, x1, y1) {
      ctx.save();
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.strokeStyle = colorEl.value;
      ctx.globalAlpha = parseFloat(opacityEl.value || '1');
      ctx.lineWidth = parseInt(sizeEl.value, 10);
      applyDash(ctx);
      ctx.beginPath(); ctx.moveTo(x0, y0); ctx.lineTo(x1, y1); ctx.stroke();
      if (arrowheadsToggle.checked) drawArrowhead(ctx, x0, y0, x1, y1, ctx.lineWidth);
      ctx.restore();
      clearOverlay(); pushHistory();
    }

    function commitRect(x0, y0, x1, y1) {
      const w = x1 - x0, h = y1 - y0;
      const r = Math.max(0, parseInt(cornerRadiusEl.value || '0', 10));
      ctx.save();
      ctx.lineWidth = Math.max(1, parseInt(sizeEl.value, 10));
      ctx.strokeStyle = colorEl.value;
      ctx.globalAlpha = parseFloat(opacityEl.value || '1');
      ctx.beginPath();
      if (r > 0) pathRoundRect(ctx, x0, y0, w, h, r); else ctx.rect(x0, y0, w, h);
      if (fillToggle.checked) {
        ctx.fillStyle = colorEl.value;
        ctx.globalAlpha = Math.min(1, parseFloat(opacityEl.value || '1'));
        ctx.fill();
        ctx.globalAlpha = parseFloat(opacityEl.value || '1');
      }
      ctx.stroke();
      ctx.restore();
      clearOverlay(); pushHistory();
    }

    function commitEllipse(x0, y0, x1, y1) {
      const cx = (x0 + x1) / 2; const cy = (y0 + y1) / 2;
      const rx = Math.abs(x1 - x0) / 2; const ry = Math.abs(y1 - y0) / 2;
      ctx.save();
      ctx.lineWidth = Math.max(1, parseInt(sizeEl.value, 10));
      ctx.strokeStyle = colorEl.value;
      ctx.globalAlpha = parseFloat(opacityEl.value || '1');
      ctx.beginPath();
      ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
      if (fillToggle.checked) {
        ctx.fillStyle = colorEl.value;
        ctx.globalAlpha = Math.min(1, parseFloat(opacityEl.value || '1'));
        ctx.fill();
        ctx.globalAlpha = parseFloat(opacityEl.value || '1');
      }
      ctx.stroke();
      ctx.restore();
      clearOverlay(); pushHistory();
    }

    function commitTriangle(x0, y0, x1, y1) {
      const p1 = { x: (x0 + x1) / 2, y: y0 };
      const p2 = { x: x0, y: y1 };
      const p3 = { x: x1, y: y1 };
      ctx.save();
      ctx.lineWidth = Math.max(1, parseInt(sizeEl.value, 10));
      ctx.strokeStyle = colorEl.value;
      ctx.globalAlpha = parseFloat(opacityEl.value || '1');
      applyDash(ctx);
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.lineTo(p3.x, p3.y);
      ctx.closePath();
      if (fillToggle.checked) {
        ctx.fillStyle = colorEl.value;
        ctx.globalAlpha = Math.min(1, parseFloat(opacityEl.value || '1'));
        ctx.fill();
        ctx.globalAlpha = parseFloat(opacityEl.value || '1');
      }
      ctx.stroke();
      ctx.restore();
      clearOverlay(); pushHistory();
    }

    function commitPolygon(x0, y0, x1, y1) {
      const cx = (x0 + x1) / 2; const cy = (y0 + y1) / 2;
      const rx = Math.abs(x1 - x0) / 2; const ry = Math.abs(y1 - y0) / 2;
      const n = parseInt(polySidesInput.value, 10);
      ctx.save();
      ctx.lineWidth = Math.max(1, parseInt(sizeEl.value, 10));
      ctx.strokeStyle = colorEl.value;
      ctx.globalAlpha = parseFloat(opacityEl.value || '1');
      applyDash(ctx);
      ctx.beginPath();
      for (let i=0;i<n;i++) {
        const a = -Math.PI/2 + i * (2*Math.PI/n);
        const x = cx + rx * Math.cos(a);
        const y = cy + ry * Math.sin(a);
        if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath();
      if (fillToggle.checked) { ctx.fillStyle = colorEl.value; ctx.fill(); }
      ctx.stroke();
      ctx.restore();
      clearOverlay(); pushHistory();
    }

    function commitStar(x0, y0, x1, y1) {
      const cx = (x0 + x1) / 2; const cy = (y0 + y1) / 2;
      const R = Math.max(Math.abs(x1 - x0), Math.abs(y1 - y0)) / 2;
      const n = parseInt(starPointsInput.value, 10);
      const inner = parseFloat(starInnerInput.value || '0.5') * R;
      ctx.save();
      ctx.lineWidth = Math.max(1, parseInt(sizeEl.value, 10));
      ctx.strokeStyle = colorEl.value;
      ctx.globalAlpha = parseFloat(opacityEl.value || '1');
      applyDash(ctx);
      ctx.beginPath();
      for (let i = 0; i < 2*n; i++) {
        const r = i % 2 === 0 ? R : inner;
        const a = -Math.PI/2 + i * (Math.PI / n);
        const x = cx + r * Math.cos(a);
        const y = cy + r * Math.sin(a);
        if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath();
      if (fillToggle.checked) { ctx.fillStyle = colorEl.value; ctx.fill(); }
      ctx.stroke();
      ctx.restore();
      clearOverlay(); pushHistory();
    }

    function beginStroke(x, y) {
      startX = lastX = x; startY = lastY = y;
      if (tool === 'pen' || tool === 'marker' || tool === 'eraser') {
        drawing = true;
        if (tool !== 'eraser') strokePoints = [{ x, y }]; else strokePoints = [];
        ctx.save();
        ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        ctx.lineWidth = parseInt(sizeEl.value, 10);
        if (tool === 'eraser') {
          ctx.globalCompositeOperation = 'destination-out';
          ctx.strokeStyle = 'rgba(0,0,0,1)';
          ctx.globalAlpha = 1;
        } else if (tool === 'marker') {
          ctx.globalCompositeOperation = 'source-over';
          ctx.strokeStyle = colorEl.value; ctx.globalAlpha = Math.min(1, parseFloat(opacityEl.value || '1') * 0.4);
        } else { // pen
          ctx.globalCompositeOperation = 'source-over';
          ctx.strokeStyle = colorEl.value; ctx.globalAlpha = parseFloat(opacityEl.value || '1');
        }
        applyDash(ctx);
        ctx.beginPath(); ctx.moveTo(x, y);
      } else if (tool === 'line' || tool === 'rect' || tool === 'ellipse' || tool === 'triangle') {
        drawing = true; // previews will render until mouseup
      } else if (tool === 'text') {
        // handled by click event to ensure position is precise and focus works
      } else if (tool === 'icon') {
        // wait for icon click then place at x,y
        iconPlaceAt = { x, y };
      } else if (tool === 'select') {
        drawing = true;
        beginSelection(x, y);
      } else if (tool === 'eyedropper') {
        pickColorAt(x, y);
      } else if (tool === 'hand') {
        drawing = true; startX = x; startY = y;
      }
    }

    function moveStroke(x, y, evt) {
      if (!drawing) { drawCursorPreview(x, y); return; }
      if (tool === 'pen' || tool === 'marker' || tool === 'eraser') {
        ctx.lineTo(x, y); ctx.stroke();
        lastX = x; lastY = y;
        if (tool !== 'eraser') strokePoints.push({ x, y });
      } else if (tool === 'line') {
        const constraint = evt.shiftKey;
        let dx = x - startX, dy = y - startY;
        if (constraint) {
          const angle = Math.atan2(dy, dx);
          const snap = Math.round(angle / (Math.PI/4)) * (Math.PI/4);
          const len = Math.hypot(dx, dy);
          dx = Math.cos(snap) * len; dy = Math.sin(snap) * len;
          x = startX + dx; y = startY + dy;
        }
        linePreview(startX, startY, x, y);
      } else if (tool === 'rect') {
        shapePreviewRect(startX, startY, x, y);
      } else if (tool === 'ellipse') {
        shapePreviewEllipse(startX, startY, x, y);
      } else if (tool === 'triangle') {
        shapePreviewTriangle(startX, startY, x, y);
      } else if (tool === 'polygon') {
        shapePreviewPolygon(startX, startY, x, y);
      } else if (tool === 'star') {
        shapePreviewStar(startX, startY, x, y);
      } else if (tool === 'select' && selection?.moving) {
        moveSelection(x, y);
      } else if (tool === 'select' && selection && !selection.moving && !selection.resizing) {
        updateSelectionBox(startX, startY, x, y);
      } else if (tool === 'select' && selection?.resizing) {
        resizeSelection(x, y);
      } else if (tool === 'select' && selection?.rotating) {
        updateRotation(x, y);
      } else if (tool === 'hand') {
        const dx = (evt.movementX || (x - startX)) * 1; 
        const dy = (evt.movementY || (y - startY)) * 1;
        viewOffsetX += dx; viewOffsetY += dy;
        startX = x; startY = y;
        constrainViewport();
        updateViewportTransform();
      }
    }

    function endStroke(x, y, evt) {
      if (!drawing) return; drawing = false;
      if (tool === 'pen' || tool === 'marker' || tool === 'eraser') {
        ctx.closePath();
        // If smoothing enabled for pen/marker, redraw the stroke smoothed
        if (smoothingToggle.checked && tool !== 'eraser' && strokePoints.length > 2) {
          const pts = smoothStroke(strokePoints);
          ctx.restore();
          // redraw onto context
          ctx.save();
          ctx.globalCompositeOperation = 'source-over';
          ctx.strokeStyle = colorEl.value;
          ctx.globalAlpha = tool === 'marker' ? Math.min(1, parseFloat(opacityEl.value || '1') * 0.4) : parseFloat(opacityEl.value || '1');
          ctx.lineCap = 'round'; ctx.lineJoin = 'round';
          ctx.lineWidth = parseInt(sizeEl.value, 10);
          applyDash(ctx);
          ctx.beginPath();
          ctx.moveTo(pts[0].x, pts[0].y);
          for (let i = 1; i < pts.length; i++) {
            const p = pts[i];
            if (p.q) ctx.quadraticCurveTo(p.cx, p.cy, p.x, p.y); else ctx.lineTo(p.x, p.y);
          }
          ctx.stroke();
          ctx.restore();
        } else {
          ctx.restore();
        }
        pushHistory();
      } else if (tool === 'line') {
        commitLine(startX, startY, x, y);
      } else if (tool === 'rect') {
        commitRect(startX, startY, x, y);
      } else if (tool === 'ellipse') {
        commitEllipse(startX, startY, x, y);
      } else if (tool === 'triangle') {
        commitTriangle(startX, startY, x, y);
      } else if (tool === 'polygon') {
        commitPolygon(startX, startY, x, y);
      } else if (tool === 'star') {
        commitStar(startX, startY, x, y);
      } else if (tool === 'select' && selection && !selection.moving && !selection.resizing && !selection.rotating) {
        finalizeSelectionBox();
      } else if (tool === 'select' && selection && selection.resizing) {
        finalizeSelectionResize();
      } else if (tool === 'select' && selection && selection.rotating) {
        finalizeSelectionRotate();
      } else if (tool === 'hand') {
        constrainViewport();
        updateViewportTransform();
      }
    }

    function createTextInput(x, y) {
      const input = document.createElement('div');
      input.className = 'floating-input';
      input.contentEditable = 'true';
      input.style.left = x + 'px';
      input.style.top = y + 'px';
      const textPx = parseInt(sizeEl.value, 10);
      const weight = textBoldEl.checked ? 'bold' : 'normal';
      const style = textItalicEl.checked ? 'italic' : 'normal';
      input.style.font = `${style} ${weight} ${textPx}px/${Math.round(textPx*1.2)}px ${fontFamilyEl.value}`;
      input.style.textAlign = textAlignEl.value;
      // Adjust text color for theme
      if (document.body.classList.contains('theme-light')) {
        input.style.color = '#0f1220';
      }
      stage.appendChild(input);
      setTimeout(() => {
        input.focus();
        const sel = window.getSelection();
        const range = document.createRange();
        range.selectNodeContents(input);
        range.collapse(false);
        sel.removeAllRanges(); sel.addRange(range);
      }, 0);
      const finish = () => {
        const text = input.innerText.trim();
        const rect = input.getBoundingClientRect();
        const stageRect = stage.getBoundingClientRect();
        const ox = rect.left - stageRect.left; const oy = rect.top - stageRect.top;
        if (text) {
          ctx.save();
          ctx.fillStyle = colorEl.value; ctx.globalAlpha = parseFloat(opacityEl.value || '1');
          const textPx2 = parseInt(sizeEl.value, 10);
          const weight2 = textBoldEl.checked ? 'bold' : 'normal';
          const style2 = textItalicEl.checked ? 'italic' : 'normal';
          ctx.font = `${style2} ${weight2} ${textPx2}px ${fontFamilyEl.value}`;
          ctx.textBaseline = 'top';
          ctx.textAlign = textAlignEl.value;
          const lines = text.split('\n');
          const lh = Math.round(textPx2 * 1.2);
          lines.forEach((line, idx) => {
            let tx = ox;
            if (textAlignEl.value === 'center') tx = ox + rect.width / 2;
            if (textAlignEl.value === 'right') tx = ox + rect.width;
            ctx.fillText(line, tx, oy + idx * lh);
          });
          ctx.restore(); pushHistory();
        }
        input.remove();
      };
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); finish(); }
        if (e.key === 'Escape') { e.preventDefault(); input.remove(); }
      });
      input.addEventListener('blur', finish);
      return input;
    }

    // Icon placement
    let iconPlaceAt = null;
    const ICON_CODE_MAP = {
      'fa-star': 0xf005,
      'fa-heart': 0xf004,
      'fa-check': 0xf00c,
      'fa-bolt': 0xf0e7,
      'fa-face-smile': 0xf118,
      'fa-circle': 0xf111,
      'fa-square': 0xf0c8,
      'fa-triangle-exclamation': 0xf071,
      'fa-mug-hot': 0xf7b6,
      'fa-paper-plane': 0xf1d8,
      'fa-lightbulb': 0xf0eb,
      'fa-arrow-right': 0xf061
    };

    iconPicker.addEventListener('click', (e) => {
      const btn = e.target.closest('button'); if (!btn) return;
      const ic = btn.dataset.ic;
      const iEl = btn.querySelector('i') || e.target.closest('i');
      if (!iconPlaceAt) return;
      const isBrands = iEl?.classList.contains('fa-brands');
      const isRegular = iEl?.classList.contains('fa-regular');
      const weight = isBrands ? 400 : (isRegular ? 400 : 900);
      const px = Math.max(16, parseInt(sizeEl.value, 10) * 4);
      const families = isBrands
        ? ['"Font Awesome 7 Brands"', '"Font Awesome 6 Brands"']
        : ['"Font Awesome 7 Free"', '"Font Awesome 6 Free"'];
      const glyph = String.fromCodePoint(ICON_CODE_MAP[ic] || 0xf111);
      Promise.all([
        document.fonts.load(`${weight} ${px}px ${families[0]}`),
        document.fonts.load(`${weight} ${px}px ${families[1]}`)
      ]).then(() => {
        ctx.save();
        ctx.fillStyle = colorEl.value; ctx.globalAlpha = parseFloat(opacityEl.value || '1');
        // Prefer FA7, fallback FA6 using font-family list
        ctx.font = `${weight} ${px}px ${families.join(', ')}`;
        ctx.textBaseline = 'middle'; ctx.textAlign = 'center';
        const { x, y } = iconPlaceAt;
        ctx.fillText(glyph, x, y);
        ctx.restore(); pushHistory();
        iconPlaceAt = null;
      });
    });

    // Selection
    function beginSelection(x, y) {
      selection = { x, y, w: 0, h: 0, canvas: null, moving: false, resizing: false, rotating: false, rotation: 0, offsetX: 0, offsetY: 0 };
      showSelectionBox(x, y, 0, 0);
    }
    function updateSelectionBox(x0, y0, x1, y1) {
      showSelectionBox(Math.min(x0, x1), Math.min(y0, y1), Math.abs(x1-x0), Math.abs(y1-y0));
    }
    function showSelectionBox(x, y, w, h) {
      selectionBox.classList.remove('hidden');
      selectionBox.style.left = x + 'px';
      selectionBox.style.top = y + 'px';
      selectionBox.style.width = w + 'px';
      selectionBox.style.height = h + 'px';
    }
    function hideSelectionBox() { selectionBox.classList.add('hidden'); }

    function finalizeSelectionBox() {
      const rect = selectionBox.getBoundingClientRect();
      const stageRect = stage.getBoundingClientRect();
      const x = Math.round(rect.left - stageRect.left);
      const y = Math.round(rect.top - stageRect.top);
      const w = Math.round(rect.width);
      const h = Math.round(rect.height);
      if (w < 2 || h < 2) { selection = null; hideSelectionBox(); return; }
      const img = ctx.getImageData(x * dpr, y * dpr, w * dpr, h * dpr);
      // clear original area
      ctx.clearRect(x, y, w, h);
      const c = document.createElement('canvas'); c.width = w * dpr; c.height = h * dpr;
      const cctx = c.getContext('2d'); cctx.putImageData(img, 0, 0);
      selection = { x, y, w, h, canvas: c, moving: true, resizing: false, rotating: false, rotation: 0, offsetX: 0, offsetY: 0 };
      drawSelectionOverlay();
    }

    function drawSelectionOverlay() {
      clearOverlay();
      if (!selection || !selection.canvas) return;
      const dx = (selection.offsetX||0); const dy = (selection.offsetY||0);
      const w = Math.max(1, Math.round(selection.w + (selection.resizeW||0)));
      const h = Math.max(1, Math.round(selection.h + (selection.resizeH||0)));
      const angle = selection.rotation || 0;
      const cx = (selection.x + dx) + w/2;
      const cy = (selection.y + dy) + h/2;
      octx.save();
      octx.translate(cx * dpr, cy * dpr);
      octx.rotate(angle);
      octx.drawImage(selection.canvas, -w/2 * dpr, -h/2 * dpr, w * dpr, h * dpr);
      octx.restore();
      // update box
      selectionBox.classList.remove('hidden');
      selectionBox.style.left = (selection.x + dx) + 'px';
      selectionBox.style.top = (selection.y + dy) + 'px';
      selectionBox.style.width = w + 'px';
      selectionBox.style.height = h + 'px';
    }

    function moveSelection(mx, my) {
      selection.offsetX = mx - startX;
      selection.offsetY = my - startY;
      drawSelectionOverlay();
    }

    function commitSelectionMove() {
      if (!selection || !selection.canvas) return;
      const nx = Math.round(selection.x + (selection.offsetX||0));
      const ny = Math.round(selection.y + (selection.offsetY||0));
      const w = Math.max(1, Math.round(selection.w + (selection.resizeW||0)));
      const h = Math.max(1, Math.round(selection.h + (selection.resizeH||0)));
      const angle = selection.rotation || 0;
      ctx.save();
      ctx.translate((nx + w/2) * dpr, (ny + h/2) * dpr);
      ctx.rotate(angle);
      ctx.drawImage(selection.canvas, -w/2 * dpr, -h/2 * dpr, w * dpr, h * dpr);
      ctx.restore();
      selection = null; hideSelectionBox(); clearOverlay(); pushHistory();
    }

    // Resize handles
    selectionBox.addEventListener('pointerdown', (e) => {
      const handle = e.target.closest('.handle'); if (!handle) return;
      e.stopPropagation(); e.preventDefault();
      if (!selection) return;
      const dir = handle.dataset.dir;
      drawing = true; startX = e.clientX - stage.getBoundingClientRect().left; startY = e.clientY - stage.getBoundingClientRect().top;
      if (dir === 'rot') {
        selection.rotating = true; selection.handle = 'rot';
        const rect = selectionBox.getBoundingClientRect();
        const stageRect = stage.getBoundingClientRect();
        selection.cx = rect.left - stageRect.left + rect.width/2;
        selection.cy = rect.top - stageRect.top + rect.height/2;
        selection.startAngle = Math.atan2(startY - selection.cy, startX - selection.cx) - (selection.rotation || 0);
      } else {
        selection.resizing = true; selection.handle = dir; selection.orig = { x: selection.x, y: selection.y, w: selection.w, h: selection.h };
      }
    });
    function resizeSelection(x, y) {
      if (!selection || !selection.resizing) return;
      const dx = x - startX; const dy = y - startY;
      const dir = selection.handle;
      selection.resizeW = 0; selection.resizeH = 0; selection.offsetX = 0; selection.offsetY = 0;
      if (dir === 'se') { selection.resizeW = dx; selection.resizeH = dy; }
      if (dir === 'sw') { selection.resizeW = -dx; selection.resizeH = dy; selection.offsetX = dx; }
      if (dir === 'ne') { selection.resizeW = dx; selection.resizeH = -dy; selection.offsetY = dy; }
      if (dir === 'nw') { selection.resizeW = -dx; selection.resizeH = -dy; selection.offsetX = dx; selection.offsetY = dy; }
      drawSelectionOverlay();
    }
    function finalizeSelectionResize() {
      if (!selection) return;
      const nx = Math.round(selection.x + (selection.offsetX||0));
      const ny = Math.round(selection.y + (selection.offsetY||0));
      const nw = Math.max(1, Math.round(selection.w + (selection.resizeW||0)));
      const nh = Math.max(1, Math.round(selection.h + (selection.resizeH||0)));
      ctx.drawImage(selection.canvas, 0, 0, selection.canvas.width, selection.canvas.height, nx * dpr, ny * dpr, nw * dpr, nh * dpr);
      selection = null; hideSelectionBox(); clearOverlay(); pushHistory();
    }
    function updateRotation(x, y) {
      if (!selection || !selection.rotating) return;
      const ang = Math.atan2(y - selection.cy, x - selection.cx);
      selection.rotation = ang - (selection.startAngle || 0);
      drawSelectionOverlay();
    }
    function finalizeSelectionRotate() {
      if (!selection) return;
      commitSelectionMove();
    }

    // Eyedropper
    function pickColorAt(x, y) {
      try {
        const data = ctx.getImageData(Math.floor(x * dpr), Math.floor(y * dpr), 1, 1).data;
        const hex = rgbaToHex(data[0], data[1], data[2]);
        colorEl.value = hex; addRecentColor(hex);
      } catch {}
    }

    // Events
    function pointerDown(e) {
      const p = getPos(e);
      if (tool === 'select' && selection && (selection.moving || selection.resizing || selection.rotating)) {
        drawing = true; startX = p.x; startY = p.y;
      } else {
        beginStroke(p.x, p.y);
      }
    }
    function pointerMove(e) {
      const p = getPos(e);
      if (tool === 'select' && selection && selection.moving && drawing) {
        moveSelection(p.x, p.y);
      } else {
        moveStroke(p.x, p.y, e);
      }
    }
    function pointerUp(e) {
      const p = getPos(e);
      if (tool === 'select' && selection && selection.moving && drawing) {
        drawing = false; commitSelectionMove();
      } else {
        endStroke(p.x, p.y, e);
      }
    }

    // Attach listeners to the board canvas (overlay ignores pointer events)
    board.addEventListener('pointerdown', pointerDown);
    board.addEventListener('pointermove', pointerMove);
    window.addEventListener('pointerup', pointerUp);

    // For text tool, create the editor on precise click location
    board.addEventListener('click', (e) => {
      if (tool !== 'text') return;
      const p = getPos(e);
      createTextInput(p.x, p.y);
      e.stopPropagation();
    });

    // Prevent default gestures for smoother drawing
    ['touchstart','touchmove','gesturestart'].forEach(ev => {
      window.addEventListener(ev, e => e.preventDefault(), { passive: false });
    });

    // Toolbar clicks
    toolbar.addEventListener('click', (e) => {
      const btn = e.target.closest('.tool-btn'); if (!btn) return;
      if (btn.id === 'undoBtn') return undo();
      if (btn.id === 'redoBtn') return redo();
      if (btn.id === 'importBtn') { fileInput.click(); return; }
      if (btn.id === 'exportBtn') { doExport(); return; }
      if (btn.id === 'fullscreenBtn') { toggleFullscreen(); return; }
      if (btn.dataset.tool) setTool(btn.dataset.tool);
    });

    // Hex conversion helper for swatches
    function rgbToHex(rgb) {
      const m = rgb.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
      if (!m) return '#000000';
      const r = Number(m[1]).toString(16).padStart(2,'0');
      const g = Number(m[2]).toString(16).padStart(2,'0');
      const b = Number(m[3]).toString(16).padStart(2,'0');
      return `#${r}${g}${b}`;
    }
    function rgbaToHex(r,g,b) {
      return '#' + [r,g,b].map(v => v.toString(16).padStart(2,'0')).join('');
    }

    // Recent colors
    function addRecentColor(hex) {
      const h = hex.toLowerCase();
      const idx = recentColors.indexOf(h);
      if (idx !== -1) recentColors.splice(idx,1);
      recentColors.unshift(h);
      if (recentColors.length > 6) recentColors.pop();
      renderRecentColors();
      try { localStorage.setItem(PREF_RECENT_COLORS_KEY, JSON.stringify(recentColors)); } catch {}
    }
    function renderRecentColors() {
      recentColorsEl.innerHTML = '';
      recentColors.forEach((c, i) => {
        const btn = document.createElement('button');
        btn.style.width = '20px'; btn.style.height = '20px'; btn.style.borderRadius = '50%';
        btn.style.border = '1px solid rgba(255,255,255,0.3)';
        btn.style.background = c; btn.title = c;
        btn.addEventListener('click', () => { colorEl.value = c; });
        recentColorsEl.appendChild(btn);
      });
    }
    function loadRecentColors() {
      try {
        const s = localStorage.getItem(PREF_RECENT_COLORS_KEY);
        if (s) {
          const arr = JSON.parse(s);
          if (Array.isArray(arr)) {
            recentColors.splice(0, recentColors.length, ...arr);
            renderRecentColors();
          }
        }
      } catch {}
    }

    // Swatches and controls
    qsa('#sw1,#sw2,#sw3,#sw4,#sw5,#sw6').forEach(sw => sw.addEventListener('click', () => {
      const rgb = window.getComputedStyle(sw).backgroundColor;
      const hex = rgb.startsWith('#') ? rgb : rgbToHex(rgb);
      colorEl.value = hex; addRecentColor(hex);
      try { localStorage.setItem(PREF_COLOR_KEY, hex); } catch {}
    }));
    sizeEl.addEventListener('input', () => { sizeVal.textContent = sizeEl.value; try { localStorage.setItem(PREF_SIZE_KEY, sizeEl.value); } catch {} });
    colorEl.addEventListener('change', () => { addRecentColor(colorEl.value); try { localStorage.setItem(PREF_COLOR_KEY, colorEl.value); } catch {} });
    opacityEl.addEventListener('input', () => { try { localStorage.setItem(PREF_OPACITY_KEY, opacityEl.value); } catch {} });
    gridToggle.addEventListener('change', () => { try { localStorage.setItem(PREF_GRID_KEY, gridToggle.checked ? '1' : '0'); } catch {}; drawGrid(); });
    gridSizeEl.addEventListener('input', () => { try { localStorage.setItem(PREF_GRID_SIZE_KEY, gridSizeEl.value); } catch {}; drawGrid(); });
    gridTypeEl.addEventListener('change', () => { try { localStorage.setItem(PREF_GRID_TYPE_KEY, gridTypeEl.value); } catch {}; drawGrid(); });
    dashToggle.addEventListener('change', () => { try { localStorage.setItem(PREF_DASH_KEY, dashToggle.checked ? '1' : '0'); } catch {} });
    dashLenEl.addEventListener('input', () => { try { localStorage.setItem(PREF_DASH_LEN_KEY, dashLenEl.value); } catch {} });
    arrowSizeEl.addEventListener('input', () => { try { localStorage.setItem(PREF_ARROW_SIZE_KEY, arrowSizeEl.value); } catch {} });
    arrowheadsToggle.addEventListener('change', () => { try { localStorage.setItem(PREF_ARROWHEADS_KEY, arrowheadsToggle.checked ? '1' : '0'); } catch {} });
    fillToggle.addEventListener('change', () => { try { localStorage.setItem(PREF_FILL_KEY, fillToggle.checked ? '1' : '0'); } catch {} });
    cornerRadiusEl.addEventListener('input', () => { try { localStorage.setItem(PREF_RADIUS_KEY, cornerRadiusEl.value); } catch {} });
    smoothingToggle.addEventListener('change', () => { try { localStorage.setItem(PREF_SMOOTH_KEY, smoothingToggle.checked ? '1' : '0'); } catch {} });
    fontFamilyEl.addEventListener('change', () => { try { localStorage.setItem(PREF_FONT_KEY, fontFamilyEl.value); } catch {} });
    textAlignEl.addEventListener('change', () => { try { localStorage.setItem(PREF_ALIGN_KEY, textAlignEl.value); } catch {} });
    textBoldEl.addEventListener('change', () => { try { localStorage.setItem(PREF_BOLD_KEY, textBoldEl.checked ? '1' : '0'); } catch {} });
    textItalicEl.addEventListener('change', () => { try { localStorage.setItem(PREF_ITALIC_KEY, textItalicEl.checked ? '1' : '0'); } catch {} });
    autosaveToggle.addEventListener('change', () => { try { localStorage.setItem(PREF_AUTOSAVE_KEY, autosaveToggle.checked ? '1' : '0'); } catch {} });

    // Theme
    const DARK_DEFAULT = '#4de2cf';
    const LIGHT_DEFAULT = '#000000';
    themeEl.addEventListener('change', () => {
      const t = themeEl.value;
      document.body.classList.toggle('theme-light', t === 'light');
      if (t === 'light') colorEl.value = LIGHT_DEFAULT; else colorEl.value = DARK_DEFAULT;
      addRecentColor(colorEl.value);
      drawGrid();
      try { localStorage.setItem(PREF_THEME_KEY, t); } catch {}
    });

    // Autosave
    function saveToStorage() {
      try {
        const data = board.toDataURL('image/png');
        localStorage.setItem('whiteboard_autosave', data);
        if (activeTabId) {
          localStorage.setItem(TAB_PREFIX + activeTabId, data);
        }
        statusEl.textContent = 'Saved';
      } catch {}
    }
    function loadFromStorage() {
      const data = activeTabId ? localStorage.getItem(TAB_PREFIX + activeTabId) : localStorage.getItem('whiteboard_autosave');
      if (!data) return;
      const img = new Image(); img.onload = () => { ctx.drawImage(img, 0, 0, board.width, board.height); pushHistory(); }; img.src = data;
    }
    saveNowBtn.addEventListener('click', () => { saveToStorage(); });

    // Clear all
    clearBtn.addEventListener('click', () => {
      ctx.clearRect(0, 0, board.width, board.height);
      pushHistory();
      if (activeTabId) localStorage.removeItem(TAB_PREFIX + activeTabId);
    });

    // Import/export
    function drawImageOnBoard(img, x=0, y=0, scale=1) {
      const w = img.width / dpr * scale; const h = img.height / dpr * scale;
      ctx.drawImage(img, x, y, w, h); pushHistory();
    }

    fileInput.addEventListener('change', async () => {
      const file = fileInput.files[0]; if (!file) return;
      const url = URL.createObjectURL(file);
      const img = new Image(); img.onload = () => { drawImageOnBoard(img, 0, 0, 1); URL.revokeObjectURL(url); };
      img.src = url;
      fileInput.value = '';
    });

    function doExport() {
      const wantJPEG = false; // could add UI toggle
      const data = board.toDataURL(wantJPEG ? 'image/jpeg' : 'image/png');
      const a = document.createElement('a');
      const ts = new Date().toISOString().replace(/[:.]/g,'-');
      a.download = `whiteboard-${ts}.${wantJPEG ? 'jpg' : 'png'}`;
      a.href = data; a.click();
    }

    // Drag & drop
    stage.addEventListener('dragover', e => { e.preventDefault(); });
    stage.addEventListener('drop', e => {
      e.preventDefault();
      const file = e.dataTransfer.files && e.dataTransfer.files[0];
      if (file && file.type.startsWith('image/')) {
        const url = URL.createObjectURL(file);
        const img = new Image(); img.onload = () => { drawImageOnBoard(img, 0, 0, 1); URL.revokeObjectURL(url); };
        img.src = url;
      }
    });

    // Clipboard paste (images, files, URLs, and text)
    window.addEventListener('paste', async (e) => {
      const cd = e.clipboardData;
      if (!cd) return;

      // 1) Image files via clipboardData.files
      if (cd.files && cd.files.length) {
        for (const file of cd.files) {
          if (file.type && file.type.startsWith('image/')) {
            const url = URL.createObjectURL(file);
            const img = new Image();
            img.onload = () => { drawImageOnBoard(img, 20, 20, 1); URL.revokeObjectURL(url); };
            img.src = url; return;
          }
        }
      }

      // 2) Image items via clipboardData.items
      const items = cd.items || [];
      for (const it of items) {
        if (it.type && it.type.startsWith('image/')) {
          const file = it.getAsFile();
          if (file) {
            const url = URL.createObjectURL(file);
            const img = new Image();
            img.onload = () => { drawImageOnBoard(img, 20, 20, 1); URL.revokeObjectURL(url); };
            img.src = url; return;
          }
        }
      }

      // 3) URL that points to an image
      const possibleUrl = cd.getData('text/uri-list') || cd.getData('text/plain');
      if (possibleUrl && /^https?:\/\/.+\.(png|jpe?g|gif|webp|bmp)(\?.*)?$/i.test(possibleUrl.trim())) {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => { drawImageOnBoard(img, 20, 20, 1); };
        img.src = possibleUrl.trim();
        return;
      }

      // 4) HTML with <img>
      const html = cd.getData('text/html');
      if (html) {
        const m = html.match(/<img[^>]+src=["']([^"']+)["']/i);
        if (m && m[1]) {
          const imgUrl = m[1];
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => { drawImageOnBoard(img, 20, 20, 1); };
          img.src = imgUrl; return;
        }
        // data URL fallback
        const dm = html.match(/src=["'](data:image\/[^"']+)["']/i);
        if (dm && dm[1]) {
          const img = new Image();
          img.onload = () => { drawImageOnBoard(img, 20, 20, 1); };
          img.src = dm[1]; return;
        }
      }

      // 5) Plain text: create text element regardless of active tool
      const text = cd.getData('text');
      if (text) {
        const rect = stage.getBoundingClientRect();
        createTextInput(rect.width/2 - 40, rect.height/2 - 12);
        const el = qs('.floating-input');
        if (el) {
          el.innerText = text;
          setTimeout(() => el.focus(), 0);
        }
        return;
      }

      // 6) Fallback: async clipboard read (secure contexts only)
      try {
        if (navigator.clipboard && navigator.clipboard.read) {
          const items2 = await navigator.clipboard.read();
          for (const item of items2) {
            const types = item.types || [];
            const imgType = types.find(t => t.startsWith('image/'));
            if (imgType) {
              const blob = await item.getType(imgType);
              const url = URL.createObjectURL(blob);
              const img = new Image();
              img.onload = () => { drawImageOnBoard(img, 20, 20, 1); URL.revokeObjectURL(url); };
              img.src = url; return;
            }
          }
        }
      } catch {}
      statusEl.textContent = 'Nothing to paste (no image/text found)';
    });

    // Fullscreen
    function toggleFullscreen() {
      if (!document.fullscreenElement) stage.requestFullscreen?.(); else document.exitFullscreen?.();
    }

    // Keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      const active = document.activeElement;
      if (active && active.classList && active.classList.contains('floating-input')) {
        // Let typing go to the editor; editor handles Enter/Escape itself
        return;
      }
      const mod = e.metaKey || e.ctrlKey;
      if (mod && e.key.toLowerCase() === 'z') { e.preventDefault(); if (e.shiftKey) redo(); else undo(); return; }
      if (mod && e.key.toLowerCase() === 's') { e.preventDefault(); doExport(); return; }
      if (mod && e.key.toLowerCase() === 'c') { e.preventDefault(); copySelection(); return; }
      if (mod && e.key.toLowerCase() === 'x') { e.preventDefault(); cutSelection(); return; }
      if (mod && e.key.toLowerCase() === 'v') { e.preventDefault(); pasteSelection(); return; }

      if (!mod) {
        const k = e.key.toLowerCase();
        if (k === 'b') setTool('pen');
        if (k === 'e') setTool('eraser');
        if (k === 'v') setTool('select');
        if (k === 't') setTool('text');
        if (k === 'l') setTool('line');
        if (k === 'r') setTool('rect');
        if (k === 'o') setTool('ellipse');
        if (k === 'i') setTool('icon');
        if (k === 'y') setTool('eyedropper');
        if (k === 'g') setTool('triangle');
        if (k === '[') sizeEl.value = Math.max(1, parseInt(sizeEl.value,10)-1), sizeVal.textContent = sizeEl.value;
        if (k === ']') sizeEl.value = Math.min(80, parseInt(sizeEl.value,10)+1), sizeVal.textContent = sizeEl.value;
        if (/^[1-9]$/.test(k)) { sizeEl.value = String(parseInt(k,10) * 8); sizeVal.textContent = sizeEl.value; }
        if (k === 'escape' || k === 'esc') { selection = null; hideSelectionBox(); clearOverlay(); }
        if (k === 'delete' || k === 'backspace') {
          if (selection && selection.canvas) { selection = null; hideSelectionBox(); clearOverlay(); pushHistory(); }
        }
      }
    });

    function copySelection() {
      if (!selection || !selection.canvas) return;
      const c = document.createElement('canvas'); c.width = selection.canvas.width; c.height = selection.canvas.height;
      c.getContext('2d').drawImage(selection.canvas, 0, 0);
      internalClipboard = { canvas: c };
      statusEl.textContent = 'Copied selection';
    }
    function cutSelection() {
      if (!selection || !selection.canvas) return;
      copySelection();
      // Nothing on board to remove (original already cleared upon selection), so just finalize removal
      selection = null; hideSelectionBox(); clearOverlay(); pushHistory();
      statusEl.textContent = 'Cut selection';
    }
    function pasteSelection() {
      if (!internalClipboard) return;
      const c = internalClipboard.canvas;
      const rect = stage.getBoundingClientRect();
      const x = Math.round(rect.width/2 - c.width/(2*dpr));
      const y = Math.round(rect.height/2 - c.height/(2*dpr));
      // Create new selection from clipboard
      selection = { x, y, w: Math.round(c.width/dpr), h: Math.round(c.height/dpr), canvas: c, moving: true, resizing: false, rotating: false, rotation: 0, offsetX: 0, offsetY: 0 };
      drawSelectionOverlay();
      statusEl.textContent = 'Pasted selection';
    }

    // Language application
    function applyLang() {
      const S = STRINGS[lang];
      // Toolbar tooltips
      qsa('.tool-btn[data-tool="pen"]').forEach(b => { b.setAttribute('data-title', S.Pen); b.setAttribute('aria-label', S.Pen); });
      qsa('.tool-btn[data-tool="marker"]').forEach(b => { b.setAttribute('data-title', S.Marker); b.setAttribute('aria-label', S.Marker); });
      qsa('.tool-btn[data-tool="eraser"]').forEach(b => { b.setAttribute('data-title', S.Eraser); b.setAttribute('aria-label', S.Eraser); });
      qsa('.tool-btn[data-tool="line"]').forEach(b => { b.setAttribute('data-title', S.Line); b.setAttribute('aria-label', S.Line); });
      qsa('.tool-btn[data-tool="rect"]').forEach(b => { b.setAttribute('data-title', S.Rectangle); b.setAttribute('aria-label', S.Rectangle); });
      qsa('.tool-btn[data-tool="ellipse"]').forEach(b => { b.setAttribute('data-title', S.Ellipse); b.setAttribute('aria-label', S.Ellipse); });
      qsa('.tool-btn[data-tool="triangle"]').forEach(b => { b.setAttribute('data-title', S.Triangle); b.setAttribute('aria-label', S.Triangle); });
      qsa('.tool-btn[data-tool="polygon"]').forEach(b => { b.setAttribute('data-title', S.Polygon); b.setAttribute('aria-label', S.Polygon); });
      qsa('.tool-btn[data-tool="star"]').forEach(b => { b.setAttribute('data-title', S.Star); b.setAttribute('aria-label', S.Star); });
      qsa('.tool-btn[data-tool="eyedropper"]').forEach(b => { b.setAttribute('data-title', S.Eyedropper); b.setAttribute('aria-label', S.Eyedropper); });
      qsa('.tool-btn[data-tool="text"]').forEach(b => { b.setAttribute('data-title', S.Text); b.setAttribute('aria-label', S.Text); });
      qsa('.tool-btn[data-tool="icon"]').forEach(b => { b.setAttribute('data-title', S.Icons); b.setAttribute('aria-label', S.Icons); });
      qsa('.tool-btn[data-tool="hand"]').forEach(b => { b.setAttribute('data-title', S.Hand); b.setAttribute('aria-label', S.Hand); });
      qsa('.tool-btn[data-tool="select"]').forEach(b => { b.setAttribute('data-title', S.SelectMove); b.setAttribute('aria-label', S.SelectMove); });
      undoBtn.setAttribute('data-title', S.Undo); undoBtn.setAttribute('aria-label', S.Undo);
      redoBtn.setAttribute('data-title', S.Redo); redoBtn.setAttribute('aria-label', S.Redo);
      importBtn.setAttribute('data-title', S.Import); importBtn.setAttribute('aria-label', S.Import);
      exportBtn.setAttribute('data-title', S.Export); exportBtn.setAttribute('aria-label', S.Export);
      fullscreenBtn.setAttribute('data-title', S.Fullscreen); fullscreenBtn.setAttribute('aria-label', S.Fullscreen);
      // Labels
      qs('#lblColor').textContent = S.Color;
      qs('#lblSize').textContent = S.Size;
      qs('#lblFill').textContent = S.Fill;
      qs('#lblOpacity').textContent = S.Opacity;
      qs('#lblFont').textContent = S.Font;
      qs('#lblArrowheads').textContent = S.Arrowheads;
      qs('#lblArrowSize').textContent = S.ArrowSize;
      qs('#lblDash').textContent = S.Dashed;
      qs('#lblDashLen').textContent = S.Dash;
      qs('#lblRadius').textContent = S.Radius;
      qs('#lblRecent').textContent = S.Recent;
      qs('#lblSmooth').textContent = S.Smooth;
      qs('#lblGrid').textContent = S.Grid;
      qs('#lblGridType').textContent = S.GridType;
      qs('#lblGridSize').textContent = S.GridSize;
      qs('#lblAlign').textContent = S.Align;
      qs('#lblBold').textContent = S.Bold;
      qs('#lblItalic').textContent = S.Italic;
      qs('#lblTheme').textContent = S.Theme;
      qs('#theme').options[0].text = S.Dark; qs('#theme').options[1].text = S.Light;
      qs('#lblAutosave').textContent = S.Autosave;
      qs('#saveNowBtn').textContent = S.SaveNow;
      qs('#lblSides').textContent = S.Sides;
      qs('#lblPoints').textContent = S.Points;
      qs('#lblInner').textContent = S.Inner;
    }

    langEl.addEventListener('change', () => { lang = langEl.value; applyLang(); try { localStorage.setItem(PREF_LANG_KEY, lang); } catch {} });

    // Resize handling
    window.addEventListener('resize', setCanvasSize);

    // Init
    setCanvasSize();
    pushHistory();
    setTool('pen');
    applyLang();
    // Preload Font Awesome faces for better reliability
    document.fonts.load('900 48px "Font Awesome 7 Free"');
    document.fonts.load('400 48px "Font Awesome 7 Free"');
    document.fonts.load('400 48px "Font Awesome 7 Brands"');
    document.fonts.load('900 48px "Font Awesome 6 Free"');
    document.fonts.load('400 48px "Font Awesome 6 Free"');
    document.fonts.load('400 48px "Font Awesome 6 Brands"');
    // Apply saved theme or default
    const savedTheme = localStorage.getItem(PREF_THEME_KEY);
    if (savedTheme === 'light') {
      themeEl.value = 'light';
      document.body.classList.add('theme-light');
      colorEl.value = LIGHT_DEFAULT;
    } else {
      themeEl.value = 'dark';
      document.body.classList.remove('theme-light');
      colorEl.value = DARK_DEFAULT;
    }
    addRecentColor(colorEl.value);
    drawGrid();
    // Attempt to load autosave
    loadFromStorage();
    updateOptionVisibility();

    // Apply saved control prefs
    try {
      const vSize = localStorage.getItem(PREF_SIZE_KEY); if (vSize) { sizeEl.value = vSize; sizeVal.textContent = vSize; }
      const vColor = localStorage.getItem(PREF_COLOR_KEY); if (vColor) { colorEl.value = vColor; addRecentColor(vColor); }
      const vOpac = localStorage.getItem(PREF_OPACITY_KEY); if (vOpac) { opacityEl.value = vOpac; }
      const vSmooth = localStorage.getItem(PREF_SMOOTH_KEY); if (vSmooth) { smoothingToggle.checked = vSmooth === '1'; }
      const vGrid = localStorage.getItem(PREF_GRID_KEY); if (vGrid) { gridToggle.checked = vGrid === '1'; }
      const vGridType = localStorage.getItem(PREF_GRID_TYPE_KEY); if (vGridType) { gridTypeEl.value = vGridType; }
      const vGridSize = localStorage.getItem(PREF_GRID_SIZE_KEY); if (vGridSize) { gridSizeEl.value = vGridSize; }
      const vFont = localStorage.getItem(PREF_FONT_KEY); if (vFont) { fontFamilyEl.value = vFont; }
      const vAlign = localStorage.getItem(PREF_ALIGN_KEY); if (vAlign) { textAlignEl.value = vAlign; }
      const vBold = localStorage.getItem(PREF_BOLD_KEY); if (vBold) { textBoldEl.checked = vBold === '1'; }
      const vItalic = localStorage.getItem(PREF_ITALIC_KEY); if (vItalic) { textItalicEl.checked = vItalic === '1'; }
      const vFill = localStorage.getItem(PREF_FILL_KEY); if (vFill) { fillToggle.checked = vFill === '1'; }
      const vRadius = localStorage.getItem(PREF_RADIUS_KEY); if (vRadius) { cornerRadiusEl.value = vRadius; }
      const vArr = localStorage.getItem(PREF_ARROWHEADS_KEY); if (vArr) { arrowheadsToggle.checked = vArr === '1'; }
      const vArrSz = localStorage.getItem(PREF_ARROW_SIZE_KEY); if (vArrSz) { arrowSizeEl.value = vArrSz; }
      const vDash = localStorage.getItem(PREF_DASH_KEY); if (vDash) { dashToggle.checked = vDash === '1'; }
      const vDashLen = localStorage.getItem(PREF_DASH_LEN_KEY); if (vDashLen) { dashLenEl.value = vDashLen; }
      const vAutosave = localStorage.getItem(PREF_AUTOSAVE_KEY); if (vAutosave) { autosaveToggle.checked = vAutosave === '1'; }
      loadRecentColors();
      drawGrid();
    } catch {}

    // Viewport zoom controls
    function applyZoom(z) {
      viewScale = Math.max(0.25, Math.min(4, z));
      if (zoomInput) zoomInput.value = String(viewScale);
      constrainViewport(true);
      updateViewportTransform();
      try { localStorage.setItem(PREF_ZOOM_KEY, String(viewScale)); } catch {}
    }
    qs('#zoomInBtn').addEventListener('click', () => applyZoom(viewScale + 0.1));
    qs('#zoomOutBtn').addEventListener('click', () => applyZoom(viewScale - 0.1));
    qs('#zoomResetBtn').addEventListener('click', () => { viewOffsetX = 0; viewOffsetY = 0; applyZoom(1); });
    if (zoomInput) zoomInput.addEventListener('input', () => applyZoom(parseFloat(zoomInput.value)));
    stage.addEventListener('wheel', (e) => {
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        const rect = stage.getBoundingClientRect();
        const px = (e.clientX - rect.left - viewOffsetX) / viewScale;
        const py = (e.clientY - rect.top - viewOffsetY) / viewScale;
        const old = viewScale;
        const delta = -Math.sign(e.deltaY) * 0.1;
        const next = Math.max(0.25, Math.min(4, old + delta));
        const scale = next / old;
        viewOffsetX = viewOffsetX - px * (scale - 1) * viewScale;
        viewOffsetY = viewOffsetY - py * (scale - 1) * viewScale;
        applyZoom(next);
      }
    }, { passive: false });

    // Load saved zoom
    try { const zv = parseFloat(localStorage.getItem(PREF_ZOOM_KEY) || '1'); if (!Number.isNaN(zv)) applyZoom(zv); else applyZoom(1); } catch { applyZoom(1); }

    function updateViewportTransform() {
      viewport.style.transform = `translate(${Math.round(viewOffsetX)}px, ${Math.round(viewOffsetY)}px) scale(${viewScale})`;
    }

    function constrainViewport(recenter=false) {
      const rect = stage.getBoundingClientRect();
      const contentW = rect.width * viewScale;
      const contentH = rect.height * viewScale;
      const minX = -contentW + 50; // keep some margin
      const minY = -contentH + 50;
      const maxX = rect.width - 50;
      const maxY = rect.height - 50;
      if (recenter) {
        viewOffsetX = Math.min(Math.max(viewOffsetX, minX), maxX);
        viewOffsetY = Math.min(Math.max(viewOffsetY, minY), maxY);
      } else {
        viewOffsetX = Math.min(Math.max(viewOffsetX, minX), maxX);
        viewOffsetY = Math.min(Math.max(viewOffsetY, minY), maxY);
      }
    }

    // Tabs management
    function renderTabs() {
      tabsEl.innerHTML = '';
      tabs.forEach(t => {
        const el = document.createElement('div'); el.className = 'tab' + (t.id === activeTabId ? ' active' : ''); el.dataset.id = t.id;
        el.innerHTML = `<span>${t.name}</span><button class="close" title="Close">×</button>`;
        el.addEventListener('click', (e) => {
          if (e.target.classList.contains('close')) { closeTab(t.id); e.stopPropagation(); return; }
          switchTab(t.id);
        });
        tabsEl.appendChild(el);
      });
    }
    function persistTabs() {
      try { localStorage.setItem(TABS_META_KEY, JSON.stringify({ activeId: activeTabId, tabs })); } catch {}
    }
    function newTabName() {
      let idx = tabs.length + 1; let name = `Tab ${idx}`;
      const names = new Set(tabs.map(t => t.name));
      while (names.has(name)) { idx += 1; name = `Tab ${idx}`; }
      return name;
    }
    function addTab(loadExisting=false, id=null, name=null) {
      const tabId = id || (Date.now().toString(36) + Math.random().toString(36).slice(2,6));
      const tabName = name || newTabName();
      tabs.push({ id: tabId, name: tabName });
      switchTab(tabId, loadExisting);
      renderTabs(); persistTabs();
    }
    function closeTab(id) {
      const idx = tabs.findIndex(t => t.id === id); if (idx === -1) return;
      tabs.splice(idx, 1);
      localStorage.removeItem(TAB_PREFIX + id);
      if (activeTabId === id) {
        activeTabId = tabs[0]?.id || null;
        ctx.clearRect(0, 0, board.width, board.height);
        if (activeTabId) loadFromStorage();
      }
      renderTabs(); persistTabs();
    }
    function switchTab(id, loadExisting=true) {
      activeTabId = id;
      ctx.clearRect(0, 0, board.width, board.height);
      if (loadExisting) loadFromStorage();
      renderTabs(); persistTabs();
    }
    addTabBtn.addEventListener('click', () => addTab(false));
    function restoreTabs() {
      try {
        const m = JSON.parse(localStorage.getItem(TABS_META_KEY) || '{}');
        if (Array.isArray(m.tabs) && m.tabs.length) {
          tabs = m.tabs; activeTabId = m.activeId || tabs[0].id; renderTabs(); switchTab(activeTabId, true);
        } else {
          addTab(false);
        }
      } catch { addTab(false); }
    }
    restoreTabs();

  </script>
</body>
</html>

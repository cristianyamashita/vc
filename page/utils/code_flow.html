<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title data-i18n="pageTitle">Code → Flowchart (Monaco + Mermaid)</title>
  <style>
    html, body { height: 100%; margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    .app { display: grid; grid-template-rows: auto 1fr auto; height: 100%; }
    header { padding: 10px 14px; border-bottom: 1px solid #e5e7eb; display: flex; gap: 8px; align-items: center; }
    header h1 { font-size: 16px; margin: 0; font-weight: 600; }
    header .spacer { flex: 1; }
    button { padding: 8px 12px; border: 1px solid #e5e7eb; background: #111827; color: white; border-radius: 10px; cursor: pointer; }
    button.secondary { background: white; color: #111827; }
    .main { display: grid; grid-template-columns: 1fr 1fr; height: 100%; padding-top: 28px; }
    .left, .right { position: relative; }
    .left   { border-right: 1px solid #e5e7eb; }
    .panel-title { position: absolute; top: -28px; left: 12px; z-index: 2; background: rgba(255,255,255,0.9); padding: 4px 8px; border-radius: 8px; border: 1px solid #e5e7eb; font-size: 12px; }
    #editor { position: absolute; inset: 0; height: 95%;}
    #diagram { position: absolute; inset: 0; overflow: auto; padding: 16px; }
    #status { font-size: 12px; color: #374151; }
    .note { font-size: 12px; color: #6b7280; }
    .footer { padding: 16px 14px 0px 14px; border-top: 1px solid #e5e7eb; font-size: 12px; display: flex; gap: 16px; align-items: center; }
    .tests { border-top: 1px solid #e5e7eb; background: #fafafa; padding: 8px 14px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; }
    .tests .ok { color: #065f46; }
    .tests .fail { color: #991b1b; }
    .mermaid { background: #fff; border: 1px solid #e5e7eb; border-radius: 12px; padding: 16px; }
    .lang-selector { display: flex; gap: 8px; align-items: center; }
    .lang-selector a { color: #6b7280; text-decoration: none; font-size: 12px; font-weight: 600; padding: 4px 8px; border-radius: 6px; border: 1px solid transparent; cursor: pointer; }
    .lang-selector a:hover { border-color: #e5e7eb; }
    .lang-selector a.active { color: #111827; background: #f3f4f6; }
  </style>
  <!-- Mermaid -->
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <script>
    mermaid.initialize({ startOnLoad: false, securityLevel: 'loose', flowchart: { curve: 'basis' } });
  </script>
  <!-- Monaco Editor (AMD) + CSS -->
  <link rel="stylesheet" data-name="vs/editor/editor.main" href="https://unpkg.com/monaco-editor@0.52.0/min/vs/editor/editor.main.css">
  <script src="https://unpkg.com/monaco-editor@0.52.0/min/vs/loader.js"></script>
  <!-- Acorn via AMD -->
</head>
<body>
  <div class="app">
    <header>
      <h1 data-i18n="headerTitle">Code → Flowchart</h1>
      <div class="spacer"></div>
      <div class="lang-selector">
        <a href="#" data-lang="en" class="active">EN</a>
        <a href="#" data-lang="ja">JA</a>
        <a href="#" data-lang="pt">PT</a>
      </div>
      <button id="btn-diagram" data-i18n="generateDiagramBtn">Generate Diagram</button>
      <button id="btn-example" class="secondary" data-i18n="loadExampleBtn">Load Example</button>
      <button id="btn-loop-example" class="secondary" data-i18n="loadLoopExampleBtn">Load Loop Example</button>
      <button id="btn-tests" class="secondary" data-i18n="runTestsBtn">Run Tests</button>
      <span id="status"></span>
    </header>
    <div class="main">
      <div class="left">
        <div class="panel-title" data-i18n="editorPanelTitle">Editor (JavaScript)</div>
        <div id="editor"></div>
      </div>
      <div class="right">
        <div class="panel-title" data-i18n="diagramPanelTitle">Flowchart (Mermaid)</div>
        <div id="diagram"><div class="note" data-i18n="diagramNote">Click "Load Example" or write your JS code on the left and then click "Generate Diagram".</div></div>
      </div>
    </div>
    <div class="footer">
      <div data-i18n="footerSupport">Supports: sequential statements, <code>if/else</code>, blocks, function calls, loops (<code>while</code>, <code>for</code>, <code>for...in</code>, <code>for...of</code>, <code>do...while</code>) and <code>console.log</code> with text.</div>
      <div class="note" data-i18n="footerExample">Example: define variable → if → call <code>mA()</code> or <code>mB()</code> → <code>console.log('done')</code>.</div>
    </div>
    <div class="tests" id="tests"></div>
  </div>

  <script>
    // ------------------- i18n System -------------------
    const translations = {
      en: {
        pageTitle: "Code → Flowchart (Monaco + Mermaid)",
        headerTitle: "Code → Flowchart",
        generateDiagramBtn: "Generate Diagram",
        loadExampleBtn: "Load Example",
        loadLoopExampleBtn: "Load Loop Example",
        runTestsBtn: "Run Tests",
        editorPanelTitle: "Editor (JavaScript)",
        diagramPanelTitle: "Flowchart (Mermaid)",
        diagramNote: "Click \"Load Example\" or write your JS code on the left and then click \"Generate Diagram\".",
        footerSupport: "Supports: sequential statements, <code>if/else</code>, blocks, function calls, loops (<code>while</code>, <code>for</code>, <code>for...in</code>, <code>for...of</code>, <code>do...while</code>) and <code>console.log</code> with text.",
        footerExample: "Example: define variable → if → call <code>mA()</code> or <code>mB()</code> → <code>console.log('done')</code>.",
        statusReady: "Editor ready.",
        statusGenerating: "Generating diagram...",
        statusUpdated: "Diagram updated.",
        statusExampleLoaded: "Example loaded.",
        statusMermaidError: "Failed to render Mermaid.",
        statusUnknownError: "Unknown error.",
        statusInitError: "Failed to initialize Monaco/Acorn: ",
        statusDepsError: "Error loading dependencies. See console.",
        testAcornAvailable: "Acorn is available",
        testAcornMissing: "acorn.parse missing",
        testMermaidStartEnd: "Mermaid contains Start/End and let x",
        testMermaidMissing: "graph TD missing",
        testLabelMissing: "label let x missing",
        testStartEndMissing: "Start/End missing",
        testIfElseBranches: "If/else generates Yes/No branches and calls",
        testBranchesMissing: "Yes/No branches missing",
        testCallLabelsMissing: "call labels missing",
        testEmptyCode: "Empty code still produces Start→End",
        testStartEndIncorrect: "Start/End incorrect for empty",
        testConsoleLogText: "console.log displays literal text",
        testConsoleLogNoText: "console.log without text",
        testMemberCalls: "call obj.method() labeled correctly",
        testMemberCallMissing: "member call label missing",
        testTemplateLiteral: "console.log with template literal simplified",
        testTemplateNotSimplified: "template literal not simplified",
        testNoLineJoining: "No improper line joining between nodes",
        testLineJoiningDetected: "node joining detected",
        testComplexCondition: "Complex condition preserves parentheses",
        testConditionNoParentheses: "condition without parentheses",
        testSummary: "Summary: {pass} passed, {fail} failed.",
        errorAcornNotLoaded: "Acorn library not loaded (acorn is not defined).",
        errorParseJS: "Error parsing JS: ",
        errorUnknown: "Unknown error.",
        // Mermaid diagram terms
        diagramStart: "Start",
        diagramEnd: "End",
        diagramCall: "call",
        diagramMerge: "merge",
        diagramNoop: "noop",
        diagramYes: "Yes",
        diagramNo: "No",
        diagramExpression: "expression",
        diagramReturn: "return",
        diagramVariable: "var"
      },
      ja: {
        pageTitle: "コード → フローチャート (Monaco + Mermaid)",
        headerTitle: "コード → フローチャート",
        generateDiagramBtn: "図表を生成",
        loadExampleBtn: "例を読み込み",
        loadLoopExampleBtn: "ループ例を読み込み",
        runTestsBtn: "テストを実行",
        editorPanelTitle: "エディタ (JavaScript)",
        diagramPanelTitle: "フローチャート (Mermaid)",
        diagramNote: "\"例を読み込み\"をクリックするか、左側にJSコードを書いてから\"図表を生成\"をクリックしてください。",
        footerSupport: "サポート：順次文、<code>if/else</code>、ブロック、関数呼び出し、ループ（<code>while</code>、<code>for</code>、<code>for...in</code>、<code>for...of</code>、<code>do...while</code>）、テキスト付き<code>console.log</code>。",
        footerExample: "例：変数を定義 → if → <code>mA()</code>または<code>mB()</code>を呼び出し → <code>console.log('完了')</code>。",
        statusReady: "エディタの準備完了。",
        statusGenerating: "図表を生成中...",
        statusUpdated: "図表が更新されました。",
        statusExampleLoaded: "例が読み込まれました。",
        statusMermaidError: "Mermaidのレンダリングに失敗しました。",
        statusUnknownError: "不明なエラー。",
        statusInitError: "Monaco/Acornの初期化に失敗しました：",
        statusDepsError: "依存関係の読み込みエラー。コンソールを確認してください。",
        testAcornAvailable: "Acornが利用可能",
        testAcornMissing: "acorn.parseが不足",
        testMermaidStartEnd: "MermaidにStart/Endとlet xが含まれている",
        testMermaidMissing: "graph TDが不足",
        testLabelMissing: "ラベルlet xが不足",
        testStartEndMissing: "Start/Endが不足",
        testIfElseBranches: "If/elseがはい/いいえの分岐と呼び出しを生成",
        testBranchesMissing: "はい/いいえの分岐が不足",
        testCallLabelsMissing: "呼び出しラベルが不足",
        testEmptyCode: "空のコードでもStart→Endを生成",
        testStartEndIncorrect: "空の場合のStart/Endが不正",
        testConsoleLogText: "console.logがリテラルテキストを表示",
        testConsoleLogNoText: "テキストなしのconsole.log",
        testMemberCalls: "call obj.method()が正しくラベル付けされている",
        testMemberCallMissing: "メンバー呼び出しラベルが不足",
        testTemplateLiteral: "テンプレートリテラル付きconsole.logが簡略化されている",
        testTemplateNotSimplified: "テンプレートリテラルが簡略化されていない",
        testNoLineJoining: "ノード間の不適切な行結合なし",
        testLineJoiningDetected: "ノード結合が検出された",
        testComplexCondition: "複雑な条件が括弧を保持",
        testConditionNoParentheses: "括弧なしの条件",
        testSummary: "要約：{pass}個合格、{fail}個不合格。",
        errorAcornNotLoaded: "Acornライブラリが読み込まれていません（acornが定義されていません）。",
        errorParseJS: "JSの解析エラー：",
        errorUnknown: "不明なエラー。",
        // Mermaid diagram terms
        diagramStart: "開始",
        diagramEnd: "終了",
        diagramCall: "呼び出し",
        diagramMerge: "結合",
        diagramNoop: "何もしない",
        diagramYes: "はい",
        diagramNo: "いいえ",
        diagramExpression: "式",
        diagramReturn: "戻り",
        diagramVariable: "変数"
      },
      pt: {
        pageTitle: "Código → Fluxograma (Monaco + Mermaid)",
        headerTitle: "Código → Fluxograma",
        generateDiagramBtn: "Gerar diagrama",
        loadExampleBtn: "Carregar exemplo",
        loadLoopExampleBtn: "Carregar exemplo de loop",
        runTestsBtn: "Rodar testes",
        editorPanelTitle: "Editor (JavaScript)",
        diagramPanelTitle: "Fluxograma (Mermaid)",
        diagramNote: "Clique em \"Carregar exemplo\" ou escreva seu código JS à esquerda e depois clique em \"Gerar diagrama\".",
        footerSupport: "Suporta: declarações sequenciais, <code>if/else</code>, blocos, chamadas de função, loops (<code>while</code>, <code>for</code>, <code>for...in</code>, <code>for...of</code>, <code>do...while</code>) e <code>console.log</code> com texto.",
        footerExample: "Exemplo: define variável → if → chama <code>mA()</code> ou <code>mB()</code> → <code>console.log('feito')</code>.",
        statusReady: "Editor pronto.",
        statusGenerating: "Gerando diagrama...",
        statusUpdated: "Diagrama atualizado.",
        statusExampleLoaded: "Exemplo carregado.",
        statusMermaidError: "Falha ao renderizar Mermaid.",
        statusUnknownError: "Erro desconhecido.",
        statusInitError: "Falha ao inicializar Monaco/Acorn: ",
        statusDepsError: "Erro ao carregar dependências. Veja o console.",
        testAcornAvailable: "Acorn está disponível",
        testAcornMissing: "acorn.parse ausente",
        testMermaidStartEnd: "Mermaid contém Start/End e let x",
        testMermaidMissing: "graph TD ausente",
        testLabelMissing: "label let x ausente",
        testStartEndMissing: "Start/End ausentes",
        testIfElseBranches: "If/else gera ramos Sim/Não e chamadas",
        testBranchesMissing: "ramos Sim/Não ausentes",
        testCallLabelsMissing: "labels de chamadas ausentes",
        testEmptyCode: "Código vazio ainda produz Start→End",
        testStartEndIncorrect: "Start/End incorretos para vazio",
        testConsoleLogText: "console.log exibe o texto literal",
        testConsoleLogNoText: "console.log sem texto",
        testMemberCalls: "call obj.metodo() rotulado corretamente",
        testMemberCallMissing: "label de chamada membro ausente",
        testTemplateLiteral: "console.log com template literal simplificado",
        testTemplateNotSimplified: "template literal não simplificado",
        testNoLineJoining: "Sem junção indevida entre nós",
        testLineJoiningDetected: "junção de nós detectada",
        testComplexCondition: "Condição complexa preserva parênteses",
        testConditionNoParentheses: "condição sem parênteses",
        testSummary: "Resumo: {pass} passado(s), {fail} falhou(aram).",
        errorAcornNotLoaded: "Biblioteca Acorn não carregada (acorn is not defined).",
        errorParseJS: "Erro ao parsear JS: ",
        errorUnknown: "Erro desconhecido.",
        // Mermaid diagram terms
        diagramStart: "Início",
        diagramEnd: "Fim",
        diagramCall: "chamada",
        diagramMerge: "mesclar",
        diagramNoop: "nada",
        diagramYes: "Sim",
        diagramNo: "Não",
        diagramExpression: "expressão",
        diagramReturn: "retorno",
        diagramVariable: "variável"
      }
    };

    const setLanguage = (lang) => {
      document.querySelectorAll('[data-i18n]').forEach(element => {
        const key = element.getAttribute('data-i18n');
        if (translations[lang] && translations[lang][key]) {
          if (element.tagName === 'TITLE') {
            element.textContent = translations[lang][key];
          } else {
            element.innerHTML = translations[lang][key];
          }
        } else {
          // Fallback to English if translation is missing
          if (element.tagName === 'TITLE') {
            element.textContent = translations['en'][key];
          } else {
            element.innerHTML = translations['en'][key];
          }
        }
      });
      document.documentElement.lang = lang;
      localStorage.setItem('code_flow_lang', lang);

      document.querySelectorAll('.lang-selector a').forEach(a => {
        a.classList.remove('active');
        if (a.getAttribute('data-lang') === lang) {
          a.classList.add('active');
        }
      });

      // Update editor content and regenerate diagram if editor is ready
      if (editor) {
        editor.setValue(getDefaultExample());
        // Regenerate diagram with new language
        setTimeout(() => {
          try {
            const code = editor.getValue();
            const mer = jsToFlowMermaid(code);
            renderMermaid(mer).then(() => setStatus(getCurrentTranslation('statusUpdated'))).catch(err => {
              console.error(err); setStatus(getCurrentTranslation('statusMermaidError'));
            });
          } catch (e) {
            console.error(e);
            setStatus(e.message || getCurrentTranslation('statusUnknownError'));
          }
        }, 100);
      }
    };

    // ------------------- Helpers UI -------------------
    function setStatus(msg) { document.getElementById('status').textContent = msg || ''; }
    function escHtml(s){ return String(s).replace(/[&<>]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }

    // Remove caracteres estruturais do Mermaid e normaliza whitespace
    function sanitizeLabel(s){
      return String(s)
        .replace(/[\r\n\t]+/g, ' ')
        .replace(/[\[\]{}|]/g, '') // evita quebrar o shape
        .trim();
    }

    // Escolhe aspas seguras para o Mermaid; se contiver ambos tipos, converte em entidades
    function quoteForMermaid(text, prefer) {
      const s0 = sanitizeLabel(text);
      const want = prefer || '"';
      const alt = want === '"' ? "'" : '"';
      if (!s0.includes(want)) return want + s0 + want;
      if (!s0.includes(alt))  return alt + s0 + alt;
      // contém ambos: converte aspas em entidades HTML
      const ent = s0.replace(/\"/g, '"').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
      return want + ent + want;
    }

    // ------------------- AST → Mermaid -------------------
    function jsToFlowMermaid(jsCode) {
      if (typeof window.acorn === 'undefined' || !acorn || !acorn.parse) {
        throw new Error(getCurrentTranslation('errorAcornNotLoaded'));
      }

      let ast;
      try {
        ast = acorn.parse(jsCode, { ecmaVersion: 2022, sourceType: 'script' });
      } catch (err) {
        throw new Error(getCurrentTranslation('errorParseJS') + err.message);
      }

      let nodeId = 0;
      const nodes = [];
      const edges = [];

      function newId() { return 'N' + (++nodeId); }

      function addNode(id, label, kind) {
        const safe = sanitizeLabel(label);
        if (kind === 'start') nodes.push(`${id}([${safe}])`);                 // mantém formato dos testes
        else if (kind === 'end') nodes.push(`${id}([${safe}])`);
        else if (kind === 'cond') nodes.push(`${id}{${quoteForMermaid(safe, '"')}}`); // decisão com aspas seguras
        else nodes.push(`${id}[${quoteForMermaid(safe, '"')}]`);              // nós comuns com aspas seguras
      }

      function isConsoleLogCall(expr) {
        if (!expr || expr.type !== 'CallExpression') return false;
        const cal = expr.callee;
        return cal && cal.type === 'MemberExpression'
          && cal.object && cal.object.type === 'Identifier' && cal.object.name === 'console'
          && cal.property && ((cal.property.type === 'Identifier' && cal.property.name === 'log') || (cal.property === 'log'));
      }

      function exprToShortText(node) {
        if (!node) return '';
        switch (node.type) {
          case 'Identifier': return node.name;
          case 'Literal': {
            if (typeof node.value === 'string') {
              // Use aspas simples para evitar conflito com wrapper de rótulo
              return '\'' + String(node.value).replace(/'/g, "\\'") + '\'';
            }
            return JSON.stringify(node.value);
          }
          case 'TemplateLiteral': {
            const parts = [];
            for (let i = 0; i < node.quasis.length; i++) {
              parts.push(node.quasis[i].value.cooked ?? node.quasis[i].value.raw ?? '');
              if (i < (node.expressions || []).length) parts.push('…');
            }
            return '`' + parts.join('') + '`';
          }
          case 'BinaryExpression': return `${exprToShortText(node.left)} ${node.operator} ${exprToShortText(node.right)}`;
          case 'LogicalExpression': return `${exprToShortText(node.left)} ${node.operator} ${exprToShortText(node.right)}`;
          case 'UnaryExpression': return `${node.operator}${exprToShortText(node.argument)}`;
          case 'MemberExpression': return `${exprToShortText(node.object)}.${exprToShortText(node.property)}`;
          case 'CallExpression': return `${exprToShortText(node.callee)}(...)`;
          default: return node.type;
        }
      }

      function argsToLabel(args) {
        const text = (args || []).map(exprToShortText).join(', ');
        return text.length > 80 ? text.slice(0, 77) + '…' : text;
      }

      function stmtLabel(stmt) {
        switch (stmt.type) {
          case 'VariableDeclaration': {
            const d = (stmt.declarations || [])[0];
            const name = d && d.id && d.id.name ? d.id.name : getCurrentTranslation('diagramVariable');
            return `${stmt.kind} ${name}`;
          }
          case 'ExpressionStatement': {
            const ex = stmt.expression;
            if (ex && ex.type === 'CallExpression') {
              if (isConsoleLogCall(ex)) {
                return `console.log(${argsToLabel(ex.arguments)})`;
              }
              const cal = ex.callee;
              if (cal && cal.type === 'Identifier') return `${getCurrentTranslation('diagramCall')} ${cal.name}()`;
              if (cal && cal.type === 'MemberExpression') return `${getCurrentTranslation('diagramCall')} ${exprToShortText(cal)}()`;
              return getCurrentTranslation('diagramCall');
            }
            return getCurrentTranslation('diagramExpression');
          }
          case 'ReturnStatement':
            return getCurrentTranslation('diagramReturn');
          default:
            return stmt.type;
        }
      }

      function processBlock(statements) {
        let first = null, last = null;
        for (const s of statements) {
          const seg = processStatement(s);
          if (!seg) continue;
          if (!first) first = seg.first;
          if (last) edges.push(`${last} --> ${seg.first}`);
          last = seg.last;
        }
        return first ? { first, last } : null;
      }

      function processStatement(stmt) {
        if (!stmt) return null;
        switch (stmt.type) {
          case 'BlockStatement': {
            return processBlock(stmt.body || []);
          }
          case 'IfStatement': {
            const condId = newId();
            addNode(condId, generateCondText(stmt.test), 'cond');

            const consSeg = (stmt.consequent && stmt.consequent.type === 'BlockStatement')
              ? processBlock(stmt.consequent.body)
              : processStatement(stmt.consequent);

            const altSeg = stmt.alternate
              ? (stmt.alternate.type === 'BlockStatement'
                  ? processBlock(stmt.alternate.body)
                  : processStatement(stmt.alternate))
              : null;

            let consFirst = consSeg ? consSeg.first : null;
            let consLast  = consSeg ? consSeg.last  : null;
            let altFirst  = altSeg  ? altSeg.first  : null;
            let altLast   = altSeg  ? altSeg.last   : null;

            if (!consFirst) { consFirst = newId(); addNode(consFirst, getCurrentTranslation('diagramNoop'), 'op'); consLast = consFirst; }
            if (!altFirst)  { altFirst  = newId(); addNode(altFirst,  getCurrentTranslation('diagramNoop'), 'op'); altLast  = altFirst; }

            edges.push(`${condId} -- ${getCurrentTranslation('diagramYes')} --> ${consFirst}`);
            edges.push(`${condId} -- ${getCurrentTranslation('diagramNo')} --> ${altFirst}`);

            const mergeId = newId();
            addNode(mergeId, getCurrentTranslation('diagramMerge'), 'op');
            edges.push(`${consLast} --> ${mergeId}`);
            edges.push(`${altLast} --> ${mergeId}`);

            return { first: condId, last: mergeId };
          }
          case 'WhileStatement': {
            const condId = newId();
            addNode(condId, generateCondText(stmt.test), 'cond');

            const bodySeg = (stmt.body && stmt.body.type === 'BlockStatement')
              ? processBlock(stmt.body.body)
              : processStatement(stmt.body);

            let bodyFirst = bodySeg ? bodySeg.first : null;
            let bodyLast  = bodySeg ? bodySeg.last  : null;

            if (!bodyFirst) { bodyFirst = newId(); addNode(bodyFirst, getCurrentTranslation('diagramNoop'), 'op'); bodyLast = bodyFirst; }

            // Loop back to condition
            edges.push(`${condId} -- ${getCurrentTranslation('diagramYes')} --> ${bodyFirst}`);
            edges.push(`${bodyLast} --> ${condId}`);

            // Exit loop
            edges.push(`${condId} -- ${getCurrentTranslation('diagramNo')} --> ${condId}`);

            return { first: condId, last: condId };
          }
          case 'ForStatement': {
            const initId = stmt.init ? newId() : null;
            const condId = newId();
            const updateId = stmt.update ? newId() : null;

            // Initialize
            if (initId) {
              addNode(initId, stmtLabel(stmt.init), 'op');
              edges.push(`${initId} --> ${condId}`);
            }

            // Condition
            addNode(condId, generateCondText(stmt.test || 'true'), 'cond');

            // Body
            const bodySeg = (stmt.body && stmt.body.type === 'BlockStatement')
              ? processBlock(stmt.body.body)
              : processStatement(stmt.body);

            let bodyFirst = bodySeg ? bodySeg.first : null;
            let bodyLast  = bodySeg ? bodySeg.last  : null;

            if (!bodyFirst) { bodyFirst = newId(); addNode(bodyFirst, getCurrentTranslation('diagramNoop'), 'op'); bodyLast = bodyFirst; }

            // Loop flow
            edges.push(`${condId} -- ${getCurrentTranslation('diagramYes')} --> ${bodyFirst}`);
            
            if (updateId) {
              addNode(updateId, stmtLabel(stmt.update), 'op');
              edges.push(`${bodyLast} --> ${updateId}`);
              edges.push(`${updateId} --> ${condId}`);
            } else {
              edges.push(`${bodyLast} --> ${condId}`);
            }

            // Exit loop
            edges.push(`${condId} -- ${getCurrentTranslation('diagramNo')} --> ${condId}`);

            return { first: initId || condId, last: condId };
          }
          case 'ForInStatement': {
            const initId = newId();
            const condId = newId();

            // Initialize
            addNode(initId, `for...in ${stmtLabel(stmt.left)}`, 'op');
            addNode(condId, `has next ${stmtLabel(stmt.right)}?`, 'cond');

            // Body
            const bodySeg = (stmt.body && stmt.body.type === 'BlockStatement')
              ? processBlock(stmt.body.body)
              : processStatement(stmt.body);

            let bodyFirst = bodySeg ? bodySeg.first : null;
            let bodyLast  = bodySeg ? bodySeg.last  : null;

            if (!bodyFirst) { bodyFirst = newId(); addNode(bodyFirst, getCurrentTranslation('diagramNoop'), 'op'); bodyLast = bodyFirst; }

            // Loop flow
            edges.push(`${initId} --> ${condId}`);
            edges.push(`${condId} -- ${getCurrentTranslation('diagramYes')} --> ${bodyFirst}`);
            edges.push(`${bodyLast} --> ${condId}`);

            // Exit loop
            edges.push(`${condId} -- ${getCurrentTranslation('diagramNo')} --> ${condId}`);

            return { first: initId, last: condId };
          }
          case 'ForOfStatement': {
            const initId = newId();
            const condId = newId();

            // Initialize
            addNode(initId, `for...of ${stmtLabel(stmt.left)}`, 'op');
            addNode(condId, `has next ${stmtLabel(stmt.right)}?`, 'cond');

            // Body
            const bodySeg = (stmt.body && stmt.body.type === 'BlockStatement')
              ? processBlock(stmt.body.body)
              : processStatement(stmt.body);

            let bodyFirst = bodySeg ? bodySeg.first : null;
            let bodyLast  = bodySeg ? bodySeg.last  : null;

            if (!bodyFirst) { bodyFirst = newId(); addNode(bodyFirst, getCurrentTranslation('diagramNoop'), 'op'); bodyLast = bodyFirst; }

            // Loop flow
            edges.push(`${initId} --> ${condId}`);
            edges.push(`${condId} -- ${getCurrentTranslation('diagramYes')} --> ${bodyFirst}`);
            edges.push(`${bodyLast} --> ${condId}`);

            // Exit loop
            edges.push(`${condId} -- ${getCurrentTranslation('diagramNo')} --> ${condId}`);

            return { first: initId, last: condId };
          }
          case 'DoWhileStatement': {
            const bodySeg = (stmt.body && stmt.body.type === 'BlockStatement')
              ? processBlock(stmt.body.body)
              : processStatement(stmt.body);

            let bodyFirst = bodySeg ? bodySeg.first : null;
            let bodyLast  = bodySeg ? bodySeg.last  : null;

            if (!bodyFirst) { bodyFirst = newId(); addNode(bodyFirst, getCurrentTranslation('diagramNoop'), 'op'); bodyLast = bodyFirst; }

            const condId = newId();
            addNode(condId, generateCondText(stmt.test), 'cond');

            // Do-while flow: body first, then condition
            edges.push(`${bodyLast} --> ${condId}`);
            edges.push(`${condId} -- ${getCurrentTranslation('diagramYes')} --> ${bodyFirst}`);
            edges.push(`${condId} -- ${getCurrentTranslation('diagramNo')} --> ${condId}`);

            return { first: bodyFirst, last: condId };
          }
          default: {
            const id = newId();
            addNode(id, stmtLabel(stmt), 'op');
            return { first: id, last: id };
          }
        }
      }

      function generateCondText(test) {
        try {
          return acornToString(test);
        } catch {
          return getCurrentTranslation('diagramExpression');
        }
      }

      function acornToString(node) {
        if (!node) return '';
        switch (node.type) {
          case 'Identifier': return node.name;
          case 'Literal': {
            if (typeof node.value === 'string') return '\'' + String(node.value).replace(/'/g, "\\'") + '\'';
            return JSON.stringify(node.value);
          }
          case 'BinaryExpression': return `${acornToString(node.left)} ${node.operator} ${acornToString(node.right)}`;
          case 'LogicalExpression': return `${acornToString(node.left)} ${node.operator} ${acornToString(node.right)}`;
          case 'UnaryExpression': return `${node.operator}${acornToString(node.argument)}`;
          case 'MemberExpression': return `${acornToString(node.object)}.${acornToString(node.property)}`;
          case 'CallExpression': return `${acornToString(node.callee)}(...)`;
          case 'ConditionalExpression': return `${acornToString(node.test)} ? ... : ...`;
          default: return node.type;
        }
      }

      const startId = newId();
      addNode(startId, getCurrentTranslation('diagramStart'), 'start');

      const flow = processBlock(ast.body || []);
      const endId = newId();
      addNode(endId, getCurrentTranslation('diagramEnd'), 'end');

      if (flow) {
        edges.push(`${startId} --> ${flow.first}`);
        edges.push(`${flow.last} --> ${endId}`);
      } else {
        edges.push(`${startId} --> ${endId}`);
      }

      const lines = ['graph TD'];
      for (const n of nodes) lines.push('  ' + n);
      for (const e of edges) lines.push('  ' + e);
      return lines.join('\n') + '\n';
    }

    async function renderMermaid(code) {
      const container = document.getElementById('diagram');
      container.innerHTML = '';
      const { svg } = await mermaid.render('graph' + Math.random().toString(36).slice(2), code);
      const wrap = document.createElement('div');
      wrap.className = 'mermaid';
      wrap.innerHTML = svg;
      container.appendChild(wrap);
    }

    // ------------------- Monaco + RequireJS + Acorn -------------------
    let editor;
    
    function getDefaultExample() {
      const callLabel = getCurrentTranslation('diagramCall');
      const doneText = document.documentElement.lang === 'pt' ? 'feito' : 
                      document.documentElement.lang === 'ja' ? '完了' : 'done';
      return `// ${getCurrentTranslation('footerExample')}\nlet x = 12;\nif (x > 10) {\n  metodoA();\n} else {\n  metodoB();\n}\nconsole.log('${doneText}');`;
    }

    function getLoopExample() {
      return `// Loop example: while, for, for...of
let i = 0;
while (i < 5) {
  console.log('count:', i);
  i++;
}

for (let j = 0; j < 3; j++) {
  if (j % 2 === 0) {
    console.log('even:', j);
  } else {
    console.log('odd:', j);
  }
}

const items = ['a', 'b', 'c'];
for (const item of items) {
  console.log('item:', item);
}`;
    }

    const defaultExample = `// Exemplo: variável + if/else + chamadas de função\nlet x = 12;\nif (x > 10) {\n  metodoA();\n} else {\n  metodoB();\n}\nconsole.log('feito');`;

    function getCurrentTranslation(key) {
      const currentLang = document.documentElement.lang || 'en';
      return translations[currentLang]?.[key] || translations['en'][key] || key;
    }

    function loadExample() {
      editor.setValue(getDefaultExample());
      setStatus(getCurrentTranslation('statusExampleLoaded'));
    }

    function loadLoopExample() {
      editor.setValue(getLoopExample());
      setStatus(getCurrentTranslation('statusExampleLoaded'));
    }

    function generateDiagram() {
      setStatus(getCurrentTranslation('statusGenerating'));
      try {
        const code = editor.getValue();
        const mer = jsToFlowMermaid(code);
        renderMermaid(mer).then(() => setStatus(getCurrentTranslation('statusUpdated'))).catch(err => {
          console.error(err); setStatus(getCurrentTranslation('statusMermaidError'));
        });
      } catch (e) {
        console.error(e);
        setStatus(e.message || getCurrentTranslation('statusUnknownError'));
        const container = document.getElementById('diagram');
        container.innerHTML = `<pre class="mermaid">${escHtml(e.message||getCurrentTranslation('statusUnknownError'))}</pre>`;
      }
    }

    function line(msg, cls){
      const el = document.createElement('div');
      el.className = cls||''; el.textContent = msg; return el;
    }

    function runTests(){
      const out = document.getElementById('tests');
      out.innerHTML = '';
      let pass = 0, fail = 0;
      function t(name, fn){
        try { fn(); out.appendChild(line('✔ ' + name, 'ok')); pass++; }
        catch(e){ out.appendChild(line('✘ ' + name + ' → ' + e.message, 'fail')); fail++; }
      }

      // Teste 1: Acorn carregado
      t(getCurrentTranslation('testAcornAvailable'), () => {
        if (!window.acorn || typeof acorn.parse !== 'function') throw new Error(getCurrentTranslation('testAcornMissing'));
      });

      // Teste 2: Declaração simples
      t(getCurrentTranslation('testMermaidStartEnd'), () => {
        const m = jsToFlowMermaid('let x = 1;');
        if (!/graph TD/.test(m)) throw new Error(getCurrentTranslation('testMermaidMissing'));
        if (!/\blet x\b/.test(m)) throw new Error(getCurrentTranslation('testLabelMissing'));
        if (!new RegExp(getCurrentTranslation('diagramStart')).test(m) || !new RegExp(getCurrentTranslation('diagramEnd')).test(m)) throw new Error(getCurrentTranslation('testStartEndMissing'));
      });

      // Teste 3: If/else com chamadas (espera ramos Sim/Não)
      t(getCurrentTranslation('testIfElseBranches'), () => {
        const code = 'let x=12; if(x>10){metodoA();} else {metodoB();}';
        const m = jsToFlowMermaid(code);
        const yesLabel = getCurrentTranslation('diagramYes');
        const noLabel = getCurrentTranslation('diagramNo');
        if (!new RegExp(`-- ${yesLabel} -->`).test(m) || !new RegExp(`-- ${noLabel} -->`).test(m)) throw new Error(getCurrentTranslation('testBranchesMissing'));
        const callLabel = getCurrentTranslation('diagramCall');
        if (!new RegExp(`${callLabel} metodoA\\(\\)`).test(m) || !new RegExp(`${callLabel} metodoB\\(\\)`).test(m)) throw new Error(getCurrentTranslation('testCallLabelsMissing'));
      });

      // Teste 4: Vazio → apenas Start->End
      t(getCurrentTranslation('testEmptyCode'), () => {
        const m = jsToFlowMermaid('');
        const startLabel = getCurrentTranslation('diagramStart');
        const endLabel = getCurrentTranslation('diagramEnd');
        const countStart = (m.match(new RegExp(`\\(\\[${startLabel}\\]\\)`, 'g')) || []).length; // nó Start
        const countEnd = (m.match(new RegExp(`\\(\\[${endLabel}\\]\\)`, 'g')) || []).length;     // nó End
        if (countStart !== 1 || countEnd !== 1) throw new Error(getCurrentTranslation('testStartEndIncorrect'));
      });

      // Teste 5: console.log com texto literal aparece no label
      t(getCurrentTranslation('testConsoleLogText'), () => {
        const m = jsToFlowMermaid("console.log('hello');");
        if (!/console\.log\('hello'\)/.test(m)) throw new Error(getCurrentTranslation('testConsoleLogNoText'));
      });

      // Teste 6: chamadas membro
      t(getCurrentTranslation('testMemberCalls'), () => {
        const m = jsToFlowMermaid('obj.metodo();');
        const callLabel = getCurrentTranslation('diagramCall');
        if (!new RegExp(`${callLabel} obj\\.metodo\\(\\)`).test(m)) throw new Error(getCurrentTranslation('testMemberCallMissing'));
      });

      // Teste 7: template literal no console.log
      t(getCurrentTranslation('testTemplateLiteral'), () => {
        const m = jsToFlowMermaid('console.log(`Oi ${nome}`);');
        if (!/console\.log\(`Oi .*`\)/.test(m)) throw new Error(getCurrentTranslation('testTemplateNotSimplified'));
      });

      // Teste 8: não deve haver junção de linhas entre nós
      t(getCurrentTranslation('testNoLineJoining'), () => {
        const code = 'let x=12; if(x>10){metodoA();} else {metodoB();}';
        const m = jsToFlowMermaid(code);
        if (/}N\d+\[/.test(m) || /\]N\d+\[/.test(m)) throw new Error(getCurrentTranslation('testLineJoiningDetected'));
      });

      // Teste 9: condição complexa (aceita aspas simples ou duplas)
      t(getCurrentTranslation('testComplexCondition'), () => {
        const m = jsToFlowMermaid('if(a && (b || c)){x=1}else{x=2}');
        if (!/\{["']a && \(b \|\| c\)["']\}/.test(m)) throw new Error(getCurrentTranslation('testConditionNoParentheses'));
      });

      // Teste 10: while loop
      t('While loop generates correct flow', () => {
        const m = jsToFlowMermaid('while(x > 0) { x--; }');
        if (!/while/.test(m)) throw new Error('while loop not detected');
      });

      // Teste 11: for loop
      t('For loop generates correct flow', () => {
        const m = jsToFlowMermaid('for(let i=0; i<5; i++) { console.log(i); }');
        if (!/for/.test(m)) throw new Error('for loop not detected');
      });

      // Teste 12: for...of loop
      t('For...of loop generates correct flow', () => {
        const m = jsToFlowMermaid('for(const item of items) { console.log(item); }');
        if (!/for\.\.\.of/.test(m)) throw new Error('for...of loop not detected');
      });

      const summary = getCurrentTranslation('testSummary').replace('{pass}', pass).replace('{fail}', fail);
      out.appendChild(line(summary));
    }

    // Configure RequireJS paths e carregue Monaco + Acorn via AMD
    require.config({
      paths: {
        'vs': 'https://unpkg.com/monaco-editor@0.52.0/min/vs',
        'acorn': 'https://cdn.jsdelivr.net/npm/acorn@8.12.1/dist/acorn.min'
      }
    });

    // Carrega Monaco e Acorn; vincula Acorn ao escopo global para as funções que esperam window.acorn
    require(['vs/editor/editor.main', 'acorn'], function (_ignored, acornModule) {
      try {
        if (acornModule) { window.acorn = acornModule; }
        // Inicializa editor
        editor = monaco.editor.create(document.getElementById('editor'), {
          value: getDefaultExample(),
          language: 'javascript',
          theme: 'vs-dark',
          automaticLayout: true,
          minimap: { enabled: false },
          fontSize: 14,
        });
        setStatus(getCurrentTranslation('statusReady'));
      } catch (e) {
        console.error('Falha ao inicializar Monaco/Acorn:', e);
        setStatus(getCurrentTranslation('statusInitError') + e.message);
      }
    }, function(err){
      console.error('Erro no RequireJS:', err);
      setStatus(getCurrentTranslation('statusDepsError'));
    });

    // Initialize i18n system
    document.addEventListener('DOMContentLoaded', () => {
      const langSelector = document.querySelector('.lang-selector');
      langSelector.addEventListener('click', (event) => {
        event.preventDefault();
        const lang = event.target.getAttribute('data-lang');
        if (lang) {
          setLanguage(lang);
        }
      });

      const savedLang = localStorage.getItem('code_flow_lang');
      const browserLang = navigator.language.split('-')[0];
      const initialLang = savedLang || (translations[browserLang] ? browserLang : 'en');
      setLanguage(initialLang);
    });

    // UI handlers
    document.getElementById('btn-example').addEventListener('click', loadExample);
    document.getElementById('btn-loop-example').addEventListener('click', loadLoopExample);
    document.getElementById('btn-diagram').addEventListener('click', generateDiagram);
    document.getElementById('btn-tests').addEventListener('click', runTests);
  </script>
</body>
</html>

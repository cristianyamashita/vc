<!DOCTYPE html>
<html lang="pt">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Cave Runner</title>
<style>
  html, body { height: 100%; margin: 0; background: #0b1020; color: #e8ecf1; font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
  canvas { display: block; width: 100vw; height: 100vh; background: radial-gradient(ellipse at 50% 40%, #0f1633 0%, #0b1020 60%, #070b16 100%); }
  #ui { position: absolute; inset: 0; pointer-events: none; }
  .topbar { position: absolute; left: 12px; top: 8px; display: flex; gap: 12px; align-items: center; }
  .stat { pointer-events: auto; padding: 6px 10px; border-radius: 8px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); font-size: 12px; }
  .rightbar { position: absolute; right: 12px; top: 8px; display: flex; gap: 8px; align-items: center; }
  button { pointer-events: auto; background: #121a33; color: #e8ecf1; border: 1px solid #2b385f; border-radius: 8px; padding: 6px 10px; font-size: 14px; }
  button.primary { background: #2a5fff; border-color: #5b86ff; }
  button.ghost { background: transparent; }
  .center { position: absolute; inset: 0; display: grid; place-items: center; pointer-events: none; }
  .panel { pointer-events: auto; background: rgba(1,4,12,0.75); border: 1px solid rgba(255,255,255,0.12); border-radius: 14px; padding: 18px; width: min(620px, 92vw); box-shadow: 0 15px 40px rgba(0,0,0,0.5); }
  .title { font-size: 28px; font-weight: 800; letter-spacing: 0.5px; margin-bottom: 6px; }
  .subtitle { font-size: 14px; opacity: 0.85; margin-bottom: 14px; }
  .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 10px; }
  .card { background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.12); border-radius: 12px; padding: 10px; }
  .muted { opacity: 0.7; font-size: 12px; }
  .toast { position: absolute; left: 50%; transform: translateX(-50%); top: 64px; background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.12); padding: 6px 10px; border-radius: 999px; font-size: 12px; pointer-events: none; }
  .hud { position: absolute; left: 12px; bottom: 10px; right: 12px; display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; pointer-events: none; }
  .bar { height: 10px; background: rgba(255,255,255,0.08); border-radius: 6px; overflow: hidden; border: 1px solid rgba(255,255,255,0.12); }
  .bar > div { height: 100%; }
  .hp    { background: linear-gradient(90deg, #ff4d6d, #ff8fa3); }
  .xp    { background: linear-gradient(90deg, #94d82d, #b2f669); }
  .hidden { display: none; }
  #tests { position: absolute; left: 12px; bottom: 12px; background: rgba(0,0,0,.4); border: 1px solid rgba(255,255,255,.12); border-radius: 8px; padding: 8px 10px; font-size: 11px; max-width: 40vw; pointer-events: none; }
  .legend { position: absolute; right: 12px; bottom: 12px; background: rgba(0,0,0,.35); border: 1px solid rgba(255,255,255,.12); border-radius: 8px; padding: 8px 10px; font-size: 12px; pointer-events: none; }
  .pill { background: rgba(0,0,0,0.35); backdrop-filter: blur(3px); border: 1px solid rgba(255,255,255,0.12); border-radius: 999px; padding: 6px 10px; font-size: 12px; }
  .mini { font-size: 11px; opacity: .85 }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="ui">
  <div class="topbar">
    <div id="levelStat" class="stat">Fase 1</div>
    <div id="timeStat" class="stat">00:00</div>
    <div id="hint" class="pill mini">WASD/↑↓←→: mover · Espaço: tiro · E: mísseis teleguiados · P: Pausar · R: Reiniciar</div>
  </div>
  <div class="rightbar">
    <button id="pauseBtn" class="ghost">⏸</button>
  </div>
  <div id="startPanel" class="center">
    <div class="panel">
      <div class="title">Cave Runner</div>
      <div class="subtitle">Nave com inércia atravessando cavernas. Chegue ao <b>Goal</b> sem bater nas paredes. Evite (ou destrua) torres inimigas.</div>
      <div class="grid" style="margin:12px 0">
        <div class="card">
          <b>Controles</b>
          <div class="muted">W/↑ acelera, S/↓ freia, A/D ou ←/→ giram. Espaço atira. P: Pausa. R: Reinicia.</div>
        </div>
        <div class="card">
          <b>Objetivo</b>
          <div class="muted">Vá do ponto de início até o <b>Goal</b> sem tocar nas paredes. Torres podem atirar em você.</div>
        </div>
        <div class="card">
          <b>Dicas</b>
          <div class="muted">Controle a velocidade; pequenos toques ajudam. Dispare para destruir torres em passagens apertadas.</div>
        </div>
      </div>
      <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap">
        <label class="mini">Dificuldade</label>
        <select id="difficulty">
          <option value="0.9">Fácil</option>
          <option value="1" selected>Normal</option>
          <option value="1.2">Difícil</option>
          <option value="1.4">Insano</option>
        </select>
        <button id="startBtn" class="primary">Iniciar</button>
      </div>
      <div class="muted mini" style="margin-top:8px">Projeto single-file (HTML/CSS/JS) — roda direto no navegador.</div>
    </div>
  </div>
  <div id="levelClearPanel" class="center hidden">
    <div class="panel">
      <div class="title">Fase Concluída!</div>
      <div id="clearStats" class="subtitle">—</div>
      <div style="display:flex; gap:8px">
        <button id="nextBtn" class="primary">Próxima Fase</button>
        <button id="menuBtn" class="ghost">Menu</button>
      </div>
    </div>
  </div>
  <div id="gameOverPanel" class="center hidden">
    <div class="panel">
      <div class="title">Fim de jogo</div>
      <div id="finalStats" class="subtitle">—</div>
      <div style="display:flex; gap:8px">
        <button id="retryBtn" class="primary">Tentar novamente</button>
        <button id="menuBtn2" class="ghost">Menu</button>
      </div>
    </div>
  </div>
  <div class="hud">
    <div class="bar"><div id="hpBar" class="hp" style="width:100%"></div></div>
    <div class="bar"><div id="xpBar" class="xp" style="width:0%"></div></div>
    <div class="bar"><div id="dummy" style="width:0%"></div></div>
  </div>
  <div id="toast" class="toast hidden">—</div>
  <div id="tests" class="hidden"></div>
  <div class="legend mini">Azul: Start · Verde: Goal · Vermelho: Inimigos/Torres</div>
  
</div>
<script>
// ===== Helpers =====
const clamp = (v,a,b)=> Math.max(a, Math.min(b, v));
const lerp = (a,b,t)=> a+(b-a)*t;
const dist2 = (ax,ay,bx,by)=>{const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy;};
const angleTo = (ax,ay,bx,by)=> Math.atan2(by-ay, bx-ax);
const now = ()=> performance.now();

// ===== Canvas & UI =====
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W = innerWidth, H = innerHeight; canvas.width=W; canvas.height=H;
addEventListener('resize', ()=>{ W=innerWidth; H=innerHeight; canvas.width=W; canvas.height=H; });

const UI = {
  startPanel: document.getElementById('startPanel'),
  levelClearPanel: document.getElementById('levelClearPanel'),
  gameOverPanel: document.getElementById('gameOverPanel'),
  clearStats: document.getElementById('clearStats'),
  finalStats: document.getElementById('finalStats'),
  startBtn: document.getElementById('startBtn'),
  nextBtn: document.getElementById('nextBtn'),
  retryBtn: document.getElementById('retryBtn'),
  menuBtn: document.getElementById('menuBtn'),
  menuBtn2: document.getElementById('menuBtn2'),
  pauseBtn: document.getElementById('pauseBtn'),
  diff: document.getElementById('difficulty'),
  levelStat: document.getElementById('levelStat'),
  timeStat: document.getElementById('timeStat'),
  hpBar: document.getElementById('hpBar'),
  xpBar: document.getElementById('xpBar'),
  toast: document.getElementById('toast'),
  tests: document.getElementById('tests'),
};

function showToast(msg, ms=1200){
  if(!msg){ UI.toast.classList.add('hidden'); return; }
  UI.toast.textContent = msg; UI.toast.classList.remove('hidden');
  clearTimeout(showToast._t); showToast._t = setTimeout(()=> UI.toast.classList.add('hidden'), ms);
}

// ===== Input =====
const keys = new Set();
addEventListener('keydown', e=>{
  const k = e.key.toLowerCase();
  keys.add(k);
  if(k==='p'){ togglePause(); }
  if(k==='r'){ if(state && !state.running){ startRun(); } }
  if(e.key===' ') e.preventDefault();
});
addEventListener('keyup', e=> keys.delete(e.key.toLowerCase()));

// ===== State =====
let state = null; // set in startRun()

function defaultState(){
  return {
    running:false, paused:false,
    t0: now(), dt:0, time:0,
    level: 1,
    difficulty: +UI.diff.value,
    worldW: 2000, worldH: 1200,
    tile: 26,
    gridW: 0, gridH: 0,
    grid: [], // 0 open, 1 wall
    start: {x:0,y:0},
    goal: {x:0,y:0,r:18},
    player: {
      x: 0, y:0, r: 14, a: 0,
      vx: 0, vy:0, thrust: 0.09, turn: 0.12, friction: 0.992,
      fireCd: 0, fireDelay: 120, hp: 100, maxHp:100
    },
    bullets: [],
    missiles: [],
    enemyBullets: [],
    turrets: [],
    enemies: [],
    xp: 0, nextXp: 30, // simple progress bar for fun
    cam: {x:0,y:0},
    missileCd: 0, missileDelay: 1400,
  };
}

function startRun(){
  const prevLevel = state?.level || 1;
  state = defaultState();
  state.level = Math.max(1, prevLevel);
  generateLevel();
  state.player.x = state.start.x; state.player.y = state.start.y; state.player.a = 0; state.player.vx=0; state.player.vy=0; state.player.hp = state.player.maxHp;
  state.running = true; state.paused=false;
  UI.startPanel.classList.add('hidden');
  UI.levelClearPanel.classList.add('hidden');
  UI.gameOverPanel.classList.add('hidden');
  UI.pauseBtn.textContent='⏸';
  gameLoop();
}

function levelClear(){
  state.running=false;
  UI.clearStats.textContent = `Tempo: ${formatTime(state.time)} · Fase ${state.level}`;
  UI.levelClearPanel.classList.remove('hidden');
}

function gameOver(reason='Colisão!'){
  state.running=false;
  UI.finalStats.textContent = `${reason} · Fase ${state.level} · Tempo ${formatTime(state.time)}`;
  UI.gameOverPanel.classList.remove('hidden');
}

function togglePause(){
  if(!state?.running) return;
  state.paused = !state.paused; UI.pauseBtn.textContent = state.paused? '▶':'⏸';
  showToast(state.paused? 'Pausado': '');
}

// ===== Maze / Cave generation =====
function generateLevel(){
  // Scale with level+difficulty
  const L = state.level;
  const diff = state.difficulty;
  const baseW = 43 + Math.floor(L*3*diff);
  const baseH = 25 + Math.floor(L*2*diff);
  // ensure odd sizes for maze algorithm
  const gw = Math.max(21, baseW|1);
  const gh = Math.max(15, baseH|1);
  state.gridW = gw; state.gridH = gh;
  state.tile = clamp(Math.floor(Math.min(W/(Math.min(36, gw)*0.8), H/(Math.min(24, gh)*0.8))), 18, 36);
  state.worldW = gw * state.tile; state.worldH = gh * state.tile;

  // Initialize all walls
  const grid = Array.from({length: gh}, ()=> Array(gw).fill(1));
  const visited = Array.from({length: gh}, ()=> Array(gw).fill(false));
  function isCell(x,y){ return x>0 && y>0 && x<gw-1 && y<gh-1 && (x%2===1) && (y%2===1); }
  // carve grid using DFS
  const stack = [];
  const startX = 1, startY = (Math.floor(Math.random()*((gh-2)/2))*2+1);
  visited[startY][startX] = true; grid[startY][startX]=0; stack.push([startX,startY]);
  const dirs = [[2,0],[-2,0],[0,2],[0,-2]];
  while(stack.length){
    const [cx,cy] = stack[stack.length-1];
    const neigh = [];
    for(const [dx,dy] of dirs){ const nx=cx+dx, ny=cy+dy; if(isCell(nx,ny) && !visited[ny][nx]) neigh.push([nx,ny, dx,dy]); }
    if(neigh.length===0){ stack.pop(); continue; }
    const [nx,ny,dx,dy] = neigh[(Math.random()*neigh.length)|0];
    visited[ny][nx]=true; grid[ny][nx]=0; grid[cy+dy/2][cx+dx/2]=0; stack.push([nx,ny]);
  }
  // widen corridors a bit (dilation)
  const widen = 1 + Math.floor(0.5*state.difficulty);
  for(let k=0;k<widen;k++){
    const next = grid.map(row=> row.slice());
    for(let y=1;y<gh-1;y++) for(let x=1;x<gw-1;x++){
      if(grid[y][x]===0){
        for(let yy=y-1;yy<=y+1;yy++) for(let xx=x-1;xx<=x+1;xx++) next[yy][xx]=0;
      }
    }
    for(let y=0;y<gh;y++) for(let x=0;x<gw;x++) grid[y][x]=next[y][x];
  }

  // pick start (leftmost open) and goal (rightmost open)
  let startCell = null, goalCell = null;
  for(let y=1;y<gh-1;y++) if(grid[y][1]===0){ startCell = {x:1,y}; break; }
  for(let y=gh-2;y>=1;y--) if(grid[y][gw-2]===0){ goalCell = {x:gw-2,y}; break; }
  if(!startCell){ startCell = {x:1,y:1}; grid[1][1]=0; }
  if(!goalCell){ goalCell = {x:gw-2,y:gh-2}; grid[gh-2][gw-2]=0; }

  state.grid = grid;
  state.start.x = (startCell.x+0.5)*state.tile; state.start.y = (startCell.y+0.5)*state.tile;
  state.goal.x = (goalCell.x+0.5)*state.tile; state.goal.y = (goalCell.y+0.5)*state.tile; state.goal.r = Math.max(16, Math.floor(state.tile*0.5));

  // place turrets near walls
  state.turrets.length = 0;
  const turretTarget = Math.floor((gw*gh)/450 * state.difficulty * (1 + state.level*0.2));
  const candidates = [];
  for(let y=1;y<gh-1;y++) for(let x=1;x<gw-1;x++){
    if(grid[y][x]===0){
      let walls=0; for(const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]) if(grid[y+dy][x+dx]===1) walls++;
      if(walls>=2) candidates.push({x,y});
    }
  }
  shuffle(candidates);
  for(let i=0;i<turretTarget && i<candidates.length;i++){
    const c = candidates[i];
    const tx = (c.x+0.5)*state.tile, ty=(c.y+0.5)*state.tile;
    // avoid placing too close to start/goal
    if(dist2(tx,ty,state.start.x,state.start.y) < 200*200) continue;
    if(dist2(tx,ty,state.goal.x,state.goal.y) < 200*200) continue;
    state.turrets.push({x:tx,y:ty,r:12,hp:30, maxHp:30, fireCd: 1000*Math.random(), range: 360+state.level*12, alive:true});
  }

  // place enemy ships (red)
  state.enemies.length = 0;
  const enemyTarget = Math.floor(2 + (gw*gh)/2400 * (0.8 + state.level*0.6) * state.difficulty);
  const openCells = [];
  for(let y=2;y<gh-2;y++) for(let x=2;x<gw-2;x++) if(grid[y][x]===0) openCells.push({x,y});
  shuffle(openCells);
  for(const c of openCells){
    if(state.enemies.length>=enemyTarget) break;
    const ex = (c.x+0.5)*state.tile, ey=(c.y+0.5)*state.tile;
    if(dist2(ex,ey,state.start.x,state.start.y) < 260*260) continue;
    if(dist2(ex,ey,state.goal.x,state.goal.y) < 260*260) continue;
    // ensure local area open
    let ok=true; for(let yy=-1;yy<=1;yy++) for(let xx=-1;xx<=1;xx++){ if(grid[c.y+yy]?.[c.x+xx]===1) ok=false; }
    if(!ok) continue;
    state.enemies.push(makeEnemyShip(ex,ey));
  }
}

function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } }

// ===== Main loop =====
function gameLoop(){
  if(!state || !state.running) return;
  requestAnimationFrame(gameLoop);
  const t = now();
  state.dt = clamp(t - (state.t0||t), 0, 50); state.t0 = t;
  if(state.paused){ draw(); return; }
  state.time += state.dt/1000;
  update();
  draw();
}

// ===== Update =====
function update(){
  const p = state.player;
  // Input & physics (same feel as game5)
  const left = keys.has('a')||keys.has('arrowleft');
  const right= keys.has('d')||keys.has('arrowright');
  const up   = keys.has('w')||keys.has('arrowup');
  const down = keys.has('s')||keys.has('arrowdown');
  const shoot= keys.has(' ');
  const shootMissile = keys.has('e');

  if(left) p.a -= p.turn * (state.dt/16.6667);
  if(right) p.a += p.turn * (state.dt/16.6667);
  if(up){ p.vx += Math.cos(p.a)*p.thrust*(state.dt/16.6667); p.vy += Math.sin(p.a)*p.thrust*(state.dt/16.6667); }
  if(down){ p.vx *= 0.985; p.vy *= 0.985; }
  p.vx *= Math.pow(p.friction, state.dt/16.6667); p.vy *= Math.pow(p.friction, state.dt/16.6667);

  // Shooting
  p.fireCd -= state.dt; if(shoot && p.fireCd<=0){
    state.bullets.push(makeBullet(p.x+Math.cos(p.a)*18, p.y+Math.sin(p.a)*18, p.a, 8));
    p.fireCd = p.fireDelay;
  }

  // Missile firing (limited homing, cooldown)
  state.missileCd -= state.dt; if(shootMissile && state.missileCd<=0){
    const target = nearestTarget(p.x,p.y);
    if(target){ state.missiles.push(makeMissile(p.x, p.y, target)); state.missileCd = state.missileDelay; }
  }

  // Move and collide with walls
  const nx = p.x + p.vx*(state.dt/16.6667);
  const ny = p.y + p.vy*(state.dt/16.6667);
  p.x = nx; p.y = ny;
  // bounds clamp to world, but walls will handle solidness
  p.x = clamp(p.x, p.r, state.worldW - p.r);
  p.y = clamp(p.y, p.r, state.worldH - p.r);
  if(collidesWithWalls(p.x,p.y,p.r)){
    makeExplosion(p.x,p.y,'#ff8fa3', 18);
    gameOver('Colisão com a parede');
    return;
  }

  // Player bullets
  for(const b of state.bullets){
    b.life -= state.dt; if(b.life<=0) b.dead=true;
    b.x += b.vx*(state.dt/16.6667); b.y += b.vy*(state.dt/16.6667);
    if(collidesBulletWall(b)){ b.dead=true; makeExplosion(b.x,b.y,'#e5f2ff',6); }
  }

  // Turrets
  for(const t of state.turrets){ if(!t.alive) continue; t.fireCd -= state.dt; if(t.fireCd<=0){
      const d2 = dist2(t.x,t.y,p.x,p.y);
      if(d2 < t.range*t.range){ const a = angleTo(t.x,t.y,p.x,p.y); state.enemyBullets.push(makeEnemyBullet(t.x+Math.cos(a)*14, t.y+Math.sin(a)*14, a, 5.2)); t.fireCd = 1000 + Math.random()*800; }
    }
  }
  // Enemy bullets
  for(const b of state.enemyBullets){
    b.life -= state.dt; if(b.life<=0) b.dead=true;
    b.x += b.vx*(state.dt/16.6667); b.y += b.vy*(state.dt/16.6667);
    if(collidesBulletWall(b)) b.dead=true;
    if(circleHit({x:b.x,y:b.y,r:b.r}, {x:p.x,y:p.y,r:p.r})){
      b.dead=true; makeExplosion(p.x,p.y,'#ff8fa3', 10); damagePlayer(24, 'Atingido por projétil'); if(!state.running) return;
    }
  }

  // Bullets vs turrets
  for(const t of state.turrets){ if(!t.alive) continue; for(const b of state.bullets){ if(b.dead) continue; if(circleHit({x:b.x,y:b.y,r:b.r},{x:t.x,y:t.y,r:t.r})){ b.dead=true; t.hp -= 12; makeExplosion(b.x,b.y,'#e5f2ff',6); if(t.hp<=0){ t.alive=false; makeExplosion(t.x,t.y,'#ff6b6b', 14); state.xp = Math.min(state.nextXp, state.xp+8); }
    } } }

  // Enemies AI & combat
  for(const e of state.enemies){ if(e.dead) continue;
    // steer: chase if in range else wander
    const chaseR2 = e.detect*e.detect;
    const d2p = dist2(e.x,e.y,p.x,p.y);
    if(d2p < chaseR2){
      const desired = angleTo(e.x,e.y,p.x,p.y);
      e.a = turnTowards(e.a, desired, e.turn*(state.dt/16.6667));
      e.speedTarget = e.speedMax;
      // shoot if in FOV and LoS
      const da = shortestAngleDiff(e.a, Math.atan2(p.y-e.y, p.x-e.x));
      if(Math.abs(da) < 0.35 && e.fireCd<=0 && !lineHitsWall(e.x,e.y,p.x,p.y)){
        state.enemyBullets.push(makeEnemyBullet(e.x+Math.cos(e.a)*14, e.y+Math.sin(e.a)*14, e.a, 6.0));
        e.fireCd = 800 + Math.random()*400;
      }
    } else {
      e.speedTarget = e.speedCruise;
      e.wanderT -= state.dt; if(e.wanderT<=0){ e.wanderT = 600 + Math.random()*800; e.wanderA = (Math.random()*0.6-0.3); }
      e.a += e.wanderA*(state.dt/16.6667);
    }
    e.fireCd -= state.dt;
    // move
    e.speed = lerp(e.speed, e.speedTarget, 0.02*(state.dt/16.6667));
    const nx = e.x + Math.cos(e.a)*e.speed*(state.dt/16.6667);
    const ny = e.y + Math.sin(e.a)*e.speed*(state.dt/16.6667);
    // wall avoidance: look ahead
    if(collidesWithWalls(nx,ny,e.r)){
      e.a += (Math.random()<0.5? 1:-1)*0.9; e.speed *= 0.5;
    } else { e.x = nx; e.y = ny; }
  }

  // Player bullets vs enemies
  for(const e of state.enemies){ if(e.dead) continue; for(const b of state.bullets){ if(b.dead) continue; if(circleHit({x:b.x,y:b.y,r:b.r},{x:e.x,y:e.y,r:e.r})){ b.dead=true; e.hp -= 18; makeExplosion(b.x,b.y,'#e5f2ff',6); if(e.hp<=0){ e.dead=true; makeExplosion(e.x,e.y,'#ff6b6b', 16); state.xp = Math.min(state.nextXp, state.xp+10); } } } }

  // Missiles steering and collisions
  for(const m of state.missiles){
    m.life -= state.dt; if(m.life<=0){ m.dead=true; makeExplosion(m.x,m.y,'#b3d1ff',10); continue; }
    // target refresh if lost/dead
    let target = getTargetById(m.targetType, m.targetId) || nearestTarget(m.x,m.y);
    if(target){
      m.targetType = target.type; m.targetId = target.id;
      const desired = angleTo(m.x,m.y,target.x,target.y);
      const cur = Math.atan2(m.vy, m.vx);
      const da = clampAngle(desired - cur);
      const newA = cur + clamp(da, -m.turn*(state.dt/16.6667), m.turn*(state.dt/16.6667));
      m.vx = Math.cos(newA)*m.speed; m.vy = Math.sin(newA)*m.speed; m.a = newA;
    }
    m.x += m.vx*(state.dt/16.6667); m.y += m.vy*(state.dt/16.6667);
    if(collidesBulletWall(m)){ m.dead=true; makeExplosion(m.x,m.y,'#b3d1ff',12); continue; }
    // hit enemies
    for(const e of state.enemies){ if(e.dead||m.dead) continue; if(circleHit({x:m.x,y:m.y,r:m.r},{x:e.x,y:e.y,r:e.r})){ m.dead=true; e.hp -= 28; makeExplosion(e.x,e.y,'#b3d1ff',14); if(e.hp<=0){ e.dead=true; makeExplosion(e.x,e.y,'#ff6b6b', 16); state.xp = Math.min(state.nextXp, state.xp+10); } } }
    // hit turrets
    for(const t of state.turrets){ if(!t.alive||m.dead) continue; if(circleHit({x:m.x,y:m.y,r:m.r},{x:t.x,y:t.y,r:t.r})){ m.dead=true; t.hp -= 28; makeExplosion(t.x,t.y,'#b3d1ff',12); if(t.hp<=0){ t.alive=false; makeExplosion(t.x,t.y,'#ff6b6b', 14); state.xp = Math.min(state.nextXp, state.xp+8); } }
    }
  }

  // Enemy ship collide with player
  for(const e of state.enemies){ if(e.dead) continue; if(circleHit({x:e.x,y:e.y,r:e.r},{x:p.x,y:p.y,r:p.r})){ damagePlayer(40, 'Colisão com inimigo'); if(!state.running) return; } }

  // cleanup
  state.bullets = state.bullets.filter(o=> !o.dead);
  state.enemyBullets = state.enemyBullets.filter(o=> !o.dead);
  state.missiles = state.missiles.filter(o=> !o.dead);
  state.enemies = state.enemies.filter(o=> !o.dead);

  // XP bar fake progress to next level (from turrets destroyed)
  if(state.xp>=state.nextXp){ state.xp=0; state.nextXp = Math.round(state.nextXp*1.2+10); state.player.maxHp = Math.min(160, state.player.maxHp+10); state.player.hp = state.player.maxHp; showToast('HP +10'); }

  // Camera follow
  state.cam.x = clamp(p.x - W/2, 0, Math.max(0, state.worldW - W));
  state.cam.y = clamp(p.y - H/2, 0, Math.max(0, state.worldH - H));

  // HUD
  UI.levelStat.textContent = `Fase ${state.level}`;
  UI.timeStat.textContent = formatTime(state.time);
  UI.hpBar.style.width = `${(state.player.hp/state.player.maxHp)*100}%`;
  UI.xpBar.style.width = `${(state.xp/state.nextXp)*100}%`;

  // Goal reach
  if(circleHit({x:p.x,y:p.y,r:p.r},{x:state.goal.x,y:state.goal.y,r:state.goal.r*0.8})){
    levelClear();
  }
}

// ===== Entities =====
function makeBullet(x,y,a,speed){ return {x,y,r:3,vx:Math.cos(a)*speed, vy:Math.sin(a)*speed, life: 1600}; }
function makeEnemyBullet(x,y,a,speed){ return {x,y,r:3,vx:Math.cos(a)*speed, vy:Math.sin(a)*speed, life: 2400}; }
function makeExplosion(x,y,color,count=12){
  state._particles = state._particles||[];
  for(let i=0;i<count;i++) state._particles.push({x,y, vx:(Math.random()*2-1)*1.2, vy:(Math.random()*2-1)*1.2, life: 400+Math.random()*600, born: now(), r: 1.5+Math.random()*2.5, color});
}

function damagePlayer(amount, reason){
  state.player.hp -= amount;
  if(state.player.hp<=0){ state.player.hp = 0; makeExplosion(state.player.x,state.player.y,'#ff8fa3', 24); gameOver(reason||'Destruído'); }
}

function makeEnemyShip(x,y){
  return { x,y, r:12, a: Math.random()*Math.PI*2, speed:0, speedTarget:1.6, speedCruise:1.4, speedMax:2.5, turn:0.06, fireCd: 800+Math.random()*600, detect: 420, hp: 42, dead:false, wanderT: 600, wanderA: 0 };
}
function shortestAngleDiff(a,b){ let d = b-a; while(d>Math.PI) d-=Math.PI*2; while(d<-Math.PI) d+=Math.PI*2; return d; }
function turnTowards(a, target, maxStep){ const d = shortestAngleDiff(a,target); const step = clamp(d, -maxStep, maxStep); return a+step; }
function lineHitsWall(x1,y1,x2,y2){
  // grid stepping (Bresenham-like)
  const t = state.tile; const dx = x2-x1, dy=y2-y1; const steps = Math.ceil(Math.max(Math.abs(dx), Math.abs(dy))/ (t*0.5));
  for(let i=0;i<=steps;i++){
    const x = x1 + dx*i/steps, y = y1 + dy*i/steps; const tx = clamp(Math.floor(x/t),0,state.gridW-1), ty=clamp(Math.floor(y/t),0,state.gridH-1);
    if(state.grid[ty][tx]===1) return true;
  }
  return false;
}

// Missiles helpers
function makeMissile(x,y,target){
  return { x,y, r:4.5, vx:Math.cos(target?angleTo(x,y,target.x,target.y):0)*5.5, vy:Math.sin(target?angleTo(x,y,target.x,target.y):0)*5.5, speed:5.5, turn:0.08, a:0, targetType: target?.type||null, targetId: target?.id||null, life: 3000 };
}
function nearestTarget(x,y){
  let best=null, bestD=1e12;
  for(const e of state.enemies){ if(e.dead) continue; const d=dist2(x,y,e.x,e.y); if(d<bestD){ bestD=d; best={type:'enemy', id: idOf(e), x:e.x, y:e.y}; } }
  for(const t of state.turrets){ if(!t.alive) continue; const d=dist2(x,y,t.x,t.y); if(d<bestD){ bestD=d; best={type:'turret', id: idOf(t), x:t.x, y:t.y}; } }
  return best;
}
function getTargetById(type,id){ if(!type||id==null) return null; if(type==='enemy'){ const e = state.enemies.find(o=> !o.dead && idOf(o)===id); return e? {type, id, x:e.x, y:e.y}: null; } if(type==='turret'){ const t = state.turrets.find(o=> o.alive && idOf(o)===id); return t? {type, id, x:t.x, y:t.y}: null; } return null; }
function idOf(obj){ if(obj._id==null) obj._id = (++idOf._seq)|| (idOf._seq=1); return obj._id; }
function clampAngle(a){ while(a>Math.PI) a-=Math.PI*2; while(a<-Math.PI) a+=Math.PI*2; return a; }

// ===== Collisions =====
function circleHit(a,b){ const r=a.r+b.r; return dist2(a.x,a.y,b.x,b.y) <= r*r; }
function circleRectHit(cx,cy,cr, rx,ry,rw,rh){
  const nx = clamp(cx, rx, rx+rw); const ny = clamp(cy, ry, ry+rh);
  return dist2(cx,cy,nx,ny) <= cr*cr;
}
function collidesWithWalls(x,y,r){
  const t = state.tile;
  const minX = clamp(Math.floor((x-r)/t), 0, state.gridW-1);
  const maxX = clamp(Math.floor((x+r)/t), 0, state.gridW-1);
  const minY = clamp(Math.floor((y-r)/t), 0, state.gridH-1);
  const maxY = clamp(Math.floor((y+r)/t), 0, state.gridH-1);
  for(let ty=minY; ty<=maxY; ty++){
    for(let tx=minX; tx<=maxX; tx++){
      if(state.grid[ty][tx]===1){ const rx=tx*t, ry=ty*t; if(circleRectHit(x,y,r, rx,ry,t,t)) return true; }
    }
  }
  return false;
}
function collidesBulletWall(b){
  const t = state.tile;
  const tx = clamp(Math.floor(b.x/t), 0, state.gridW-1);
  const ty = clamp(Math.floor(b.y/t), 0, state.gridH-1);
  if(state.grid[ty][tx]===1){ const rx=tx*t, ry=ty*t; return circleRectHit(b.x,b.y,b.r, rx,ry,t,t); }
  return false;
}

// ===== Draw =====
const stars = Array.from({length: 240}, ()=> ({x:Math.random()*1, y:Math.random()*1, r: Math.random()*1.2, a: Math.random()*Math.PI*2}));
function draw(){
  // background stars parallax
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = '#0a0f1e'; ctx.fillRect(0,0,W,H);
  const sWorldW = state? state.worldW : W;
  const sWorldH = state? state.worldH : H;
  const sCamX = state? state.cam.x : 0;
  const sCamY = state? state.cam.y : 0;
  for(const s of stars){ s.a += 0.015; const tw = 0.5+Math.sin(s.a)*0.5; ctx.globalAlpha=0.35+tw*0.35; ctx.fillStyle = '#cde1ff'; const px = (s.x*sWorldW - sCamX*0.3) % W; const py = (s.y*sWorldH - sCamY*0.3) % H; circle(px<0?px+W:px, py<0?py+H:py, s.r); ctx.globalAlpha=1; }

  if(!state) return;

  const camX = state.cam.x|0, camY = state.cam.y|0, t=state.tile;
  const visMinX = clamp(Math.floor(camX/t)-1, 0, state.gridW-1);
  const visMaxX = clamp(Math.floor((camX+W)/t)+1, 0, state.gridW-1);
  const visMinY = clamp(Math.floor(camY/t)-1, 0, state.gridH-1);
  const visMaxY = clamp(Math.floor((camY+H)/t)+1, 0, state.gridH-1);

  // Draw cave tiles
  for(let y=visMinY; y<=visMaxY; y++){
    for(let x=visMinX; x<=visMaxX; x++){
      if(state.grid[y][x]===1){
        ctx.fillStyle = '#9ca1a8';
        ctx.fillRect(x*t - camX, y*t - camY, t, t);
      } else {
        // floor tint
        ctx.fillStyle = 'rgba(255,255,255,0.02)';
        ctx.fillRect(x*t - camX, y*t - camY, t, t);
      }
    }
  }

  // Wall edge outlines for visibility
  ctx.strokeStyle = '#e8e8ea';
  ctx.lineWidth = 3;
  ctx.lineJoin = 'round';
  ctx.beginPath();
  for(let y=visMinY; y<=visMaxY; y++){
    for(let x=visMinX; x<=visMaxX; x++){
      if(state.grid[y][x]!==1) continue;
      const sx = x*t - camX, sy = y*t - camY;
      // left edge
      if(x-1>=0 && state.grid[y][x-1]===0){ ctx.moveTo(sx, sy); ctx.lineTo(sx, sy+t); }
      // right edge
      if(x+1<state.gridW && state.grid[y][x+1]===0){ ctx.moveTo(sx+t, sy); ctx.lineTo(sx+t, sy+t); }
      // top edge
      if(y-1>=0 && state.grid[y-1][x]===0){ ctx.moveTo(sx, sy); ctx.lineTo(sx+t, sy); }
      // bottom edge
      if(y+1<state.gridH && state.grid[y+1][x]===0){ ctx.moveTo(sx, sy+t); ctx.lineTo(sx+t, sy+t); }
    }
  }
  ctx.stroke();

  // Goal
  ctx.save(); ctx.translate(state.goal.x - camX, state.goal.y - camY);
  const glow = 0.6 + 0.4*Math.sin(now()*0.003);
  ctx.globalAlpha = 0.2+0.3*glow; ctx.fillStyle = '#b2f669'; circle(0,0,state.goal.r*1.3);
  ctx.globalAlpha = 1; ctx.strokeStyle = '#94d82d'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(0,0,state.goal.r,0,Math.PI*2); ctx.stroke(); ctx.restore();

  // Start marker
  ctx.save(); ctx.translate(state.start.x - camX, state.start.y - camY);
  ctx.globalAlpha=0.25; ctx.fillStyle='#6ef3ff'; circle(0,0,16); ctx.globalAlpha=1; ctx.strokeStyle='#6ef3ff'; ctx.beginPath(); ctx.arc(0,0,12,0,Math.PI*2); ctx.stroke(); ctx.restore();

  // Turrets
  for(const t1 of state.turrets){ if(!t1.alive) continue; ctx.save(); ctx.translate(t1.x - camX, t1.y - camY); ctx.fillStyle='#ff6b6b'; circle(0,0,t1.r); // hp
    const w= t1.r*2, h=4; ctx.fillStyle='rgba(0,0,0,.5)'; ctx.fillRect(-w/2,-t1.r-10,w,h); ctx.fillStyle='#ff8787'; ctx.fillRect(-w/2,-t1.r-10, w*(t1.hp/t1.maxHp), h); ctx.restore(); }

  // Enemy bullets
  ctx.fillStyle = '#ffd166'; for(const b of state.enemyBullets){ circle(b.x - camX, b.y - camY, b.r); }

  // Player bullets
  ctx.fillStyle = '#e5f2ff'; for(const b of state.bullets){ circle(b.x - camX, b.y - camY, b.r); }
  // Missiles
  ctx.fillStyle = '#b3d1ff'; for(const m of state.missiles){ circle(m.x - camX, m.y - camY, m.r); }

  // Enemy ships (red)
  for(const e of state.enemies){ if(e.dead) continue; ctx.save(); ctx.translate(e.x - camX, e.y - camY); ctx.rotate(e.a); ctx.strokeStyle='#ff4d2e'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(14,0); ctx.lineTo(-10,8); ctx.lineTo(-10,-8); ctx.closePath(); ctx.stroke(); ctx.restore(); }

  // Particles
  if(state._particles){ for(const p of state._particles){ const k=(now()-p.born)/p.life; if(k>=1){ p.dead=true; continue; } ctx.globalAlpha=1-k; ctx.fillStyle=p.color; circle(p.x - camX, p.y - camY, p.r); ctx.globalAlpha=1; } state._particles = state._particles.filter(p=>!p.dead); }

  // Ship
  drawShip(state.player, camX, camY);
}

function circle(x,y,r){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); }
function drawShip(p, camX, camY){
  ctx.save(); ctx.translate(p.x - camX, p.y - camY); ctx.rotate(p.a);
  ctx.strokeStyle = '#9cc2ff'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(16,0); ctx.lineTo(-10,8); ctx.lineTo(-6,0); ctx.lineTo(-10,-8); ctx.closePath(); ctx.stroke();
  if(keys.has('w')||keys.has('arrowup')){ ctx.fillStyle='#ffd166'; ctx.beginPath(); ctx.moveTo(-14,0); ctx.lineTo(-8,4); ctx.lineTo(-8,-4); ctx.closePath(); ctx.fill(); }
  ctx.restore();
}

// ===== UI events =====
UI.startBtn.onclick = ()=> { startRun(); };
UI.nextBtn.onclick = ()=> { state.level++; startRun(); };
UI.retryBtn.onclick = ()=> { startRun(); };
UI.menuBtn.onclick = ()=> { UI.levelClearPanel.classList.add('hidden'); UI.startPanel.classList.remove('hidden'); };
UI.menuBtn2.onclick = ()=> { UI.gameOverPanel.classList.add('hidden'); UI.startPanel.classList.remove('hidden'); };
UI.pauseBtn.onclick = ()=> togglePause();

// ===== Utils =====
function formatTime(s){ const m=Math.floor(s/60), ss=Math.floor(s%60); return `${String(m).padStart(2,'0')}:${String(ss).padStart(2,'0')}`; }

// ===== Lightweight tests =====
(function tests(){
  const out = [];
  const log = (ok, name, err)=> out.push(`${ok? 'TEST ✓':'TEST ✗'} ${name}${err? ' — '+err:''}`);
  try { if(!circleRectHit(10,10,5, 30,30,10,10)) log(true,'CircleRect basic'); else log(false,'CircleRect basic','unexpected hit'); } catch(e){ log(false,'CircleRect basic',e.message); }
  try { const s = defaultState(); state = s; generateLevel(); if(!state.grid||!state.grid.length) throw new Error('grid'); log(true,'Maze generation'); } catch(e){ log(false,'Maze generation', e.message); }
  UI.tests.textContent = out.join('\n');
})();

// ===== Boot =====
// keep panels; no auto-start

</script>
</body>
</html>



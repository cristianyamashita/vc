<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Gin Rummy</title>
  <link rel="stylesheet" href="../assets/fontawesome/css/all.min.css">
  <style>
    :root{
      --bg:#0b0e14; --fg:#e6e6e6; --muted:#9aa4b2; --card:#101521; --border:#1e2636;
      --accent:#2c5894; --accent-2: color-mix(in oklch, var(--accent), white 15%);
      --ok:#10b981; --warn:#f59e0b; --err:#ef4444; --ring: color-mix(in oklch, var(--accent), white 35%);
      --shadow: 0 14px 36px -18px rgba(0,0,0,.55); --radius:.9rem;
      --surface-1: color-mix(in oklch, var(--card), black 6%);
      --surface-2: color-mix(in oklch, var(--card), black 12%);
      --card-w: 72px; --card-h: 104px;
      /* Card face/back theme variables */
      --paper:#0d1422; --paper-border:#2a3450; --back-a:#0e1526; --back-b:#0c1220;
    }
    [data-theme="light"]{
      --bg:#f7fafc; --fg:#0f172a; --muted:#475569; --card:#ffffff; --border:#e5e7eb;
      --accent:#418ffd; --accent-2: color-mix(in oklch, var(--accent), black 5%);
      --ok:#16a34a; --warn:#d97706; --err:#dc2626;
      --ring: color-mix(in oklch, var(--accent), white 30%);
      --shadow: 0 10px 25px -14px rgba(2,6,23,.25);
      --surface-1: color-mix(in oklch, var(--card), black 2%);
      --surface-2: color-mix(in oklch, var(--card), black 6%);
      --paper:#ffffff; --paper-border:#e5e7eb; --back-a:#f3f4f6; --back-b:#e9eef5;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--fg);
      font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
    }
    header{
      position:sticky; top:0; z-index:5;
      background: color-mix(in oklch, var(--card), transparent 18%);
      -webkit-backdrop-filter: saturate(160%) blur(8px);
      backdrop-filter: saturate(160%) blur(8px);
      border-bottom:1px solid var(--border);
    }
    .bar{ max-width:1100px; margin:0 auto; padding:.6rem 1rem; display:flex; align-items:center; gap:.6rem; flex-wrap:wrap }
    .title{font-weight:800; letter-spacing:.2px}
    .spacer{flex:1}
    .btn{
      appearance:none; border:1px solid var(--border); background:var(--surface-1); color:var(--fg);
      padding:.5rem .75rem; border-radius:calc(var(--radius) - .25rem); cursor:pointer;
      display:inline-flex; align-items:center; gap:.45rem; font-weight:650;
    }
    .btn:hover{border-color: color-mix(in oklch, var(--border), var(--fg) 20%); background:var(--surface-2)}
    .btn:focus-visible{outline:2px solid var(--ring); outline-offset:2px}
    .btn.primary{background: linear-gradient(180deg, var(--accent-2), var(--accent)); color:#fff; border-color: color-mix(in oklch, var(--accent), black 10%); box-shadow: var(--shadow)}
    .select{
      padding:.5rem .6rem; border-radius:calc(var(--radius) - .25rem); border:1px solid var(--border);
      background:var(--surface-1); color:var(--fg);
    }
    .select:focus{outline:2px solid var(--ring); outline-offset:2px}
    label.switch{display:inline-flex; align-items:center; gap:.35rem}

    main{max-width:1100px; margin:1rem auto; padding:0 1rem 1rem; display:grid; gap:.8rem}

    .row{ display:flex; gap:.8rem; flex-wrap:wrap; align-items:center }
    .info{ color:var(--muted) }

    .table{ display:grid; gap:.8rem; }
    .top, .mid, .bottom{ display:flex; align-items:center; gap:.8rem; flex-wrap:wrap; justify-content:center }

    .panel{
      border:1px solid var(--border); border-radius:var(--radius); background:var(--card); box-shadow: var(--shadow);
      padding:.8rem;
    }

    .pile{ display:grid; gap:.35rem; align-items:center; justify-items:center }
    .pile .name{ color:var(--muted); font-size:.9rem }

    .stacks{ display:flex; gap:1rem; align-items:center; justify-content:center }

    .melds{ display:flex; gap:.6rem; flex-wrap:wrap; justify-content:center }
    .meld{ display:flex; gap:.25rem; align-items:center; padding:.35rem; border:1px dashed #2c3855; border-radius:.6rem; background:var(--surface-1) }
    .meld .meta{ color:var(--muted); font-size:.85rem; margin-right:.35rem }
    .meld .act{ margin-left:.25rem }

    .hand{ display:flex; gap:.35rem; flex-wrap:wrap; justify-content:center }
    .card{
      width:var(--card-w); height:var(--card-h); border-radius:.6rem; border:1px solid var(--paper-border); background:var(--paper);
      display:grid; grid-template-rows:auto 1fr auto; padding:.3rem .35rem; cursor:pointer;
      box-shadow: 0 8px 24px rgba(0,0,0,.35);
      transition: transform .1s ease, border-color .15s ease, box-shadow .15s ease;
      user-select:none;
    }
    .card:hover{ transform: translateY(-2px); border-color:#3a4d7a }
    .card.sel{ outline:2px solid var(--ring); outline-offset:2px; box-shadow: 0 10px 28px rgba(0,0,0,.45) }
    .card .rank{ font-weight:800 }
    .card .suit{ font-size:18px }
    .card .center{ place-self:center; font-size:28px; opacity:.9 }
    .red{ color:#ff7a7a }

    .back{ background: repeating-linear-gradient(135deg, var(--back-a), var(--back-a) 8px, var(--back-b) 8px, var(--back-b) 16px); border-color: var(--paper-border) }

    .actions{ display:flex; align-items:center; gap:.5rem; justify-content:center; flex-wrap:wrap }
    .stat{ background:var(--surface-1); border:1px solid var(--border); border-radius:.5rem; padding:.35rem .55rem; color: color-mix(in oklch, var(--fg), var(--muted) 20%) }

    .toast{
      position:fixed; bottom:16px; left:50%; transform:translateX(-50%);
      background:#0b1324; border:1px solid #1f2a3f; padding:.5rem .7rem; border-radius:.6rem; box-shadow:var(--shadow);
      display:none; align-items:center; gap:.45rem; color:#cfe2ff;
    }
    .toast.show{ display:inline-flex }

    /* Drag-reorder slots */
    .slot{ width:10px; height:var(--card-h); align-self:center; border-radius:6px; border:2px dashed transparent; transition:border-color .15s ease, background .15s ease }
    .slot.over{ border-color: var(--ring); background: var(--surface-2) }

    /* Highlight newly drawn card */
    .newcard{ box-shadow: 0 0 0 3px color-mix(in oklch, var(--ok), white 35%) inset, 0 0 22px color-mix(in oklch, var(--ok), black 10%); animation: flash 1.3s ease-out }
    @keyframes flash{ 0%{ filter:brightness(1.25) } 100%{ filter:brightness(1) } }
  </style>
</head>
<body>
  <header>
    <div class="bar">
      <div class="title" data-i18n="title">Gin Rummy</div>
      <button id="btnNew" class="btn primary"><i class="fa-solid fa-plus"></i><span data-i18n="new">New Game</span></button>
      <label class="switch">
        <input id="optJokers" type="checkbox">
        <span data-i18n="jokers">Jokers</span>
      </label>
      <div class="spacer"></div>
      <label class="switch">
        <span data-i18n="theme">Theme</span>
        <select id="theme" class="select">
          <option value="dark" data-i18n="dark">Dark</option>
          <option value="light" data-i18n="light">Light</option>
        </select>
      </label>
      <select id="lang" class="select">
        <option value="en">English</option>
        <option value="pt">Português</option>
        <option value="ja">日本語</option>
      </select>
    </div>
  </header>

  <main>
    <div class="panel table">
      <div class="top">
        <div class="info"><i class="fa-solid fa-robot"></i> <span data-i18n="ai">AI</span> — <span data-i18n="cards">Cards</span>: <span id="aiCount">0</span></div>
      </div>

      <div class="mid">
        <div class="stacks">
          <div class="pile">
            <div class="name"><i class="fa-solid fa-layer-group"></i> <span data-i18n="stock">Stock</span> (<span id="stockCount">0</span>)</div>
            <div id="stock" class="card back" title="Draw from Stock"></div>
          </div>
          <div class="pile">
            <div class="name"><i class="fa-solid fa-recycle"></i> <span data-i18n="discard">Discard</span></div>
            <div id="discard" class="hand"></div>
          </div>
        </div>
      </div>

      <div class="mid">
        <div class="melds" id="melds"></div>
      </div>

      <div class="bottom">
        <div class="info"><i class="fa-solid fa-user"></i> <span data-i18n="you">You</span></div>
      </div>
      <div class="bottom">
        <div class="hand" id="yourHand"></div>
      </div>

      <div class="bottom actions">
        <button id="btnDrawStock" class="btn"><i class="fa-solid fa-layer-group"></i><span data-i18n="drawS">Draw Stock</span></button>
        <button id="btnDrawDiscard" class="btn"><i class="fa-solid fa-recycle"></i><span data-i18n="drawD">Draw Discard</span></button>
        <button id="btnLay" class="btn ok"><i class="fa-solid fa-table-cells"></i><span data-i18n="lay">Lay Meld</span></button>
        <button id="btnDiscard" class="btn warn"><i class="fa-solid fa-arrow-up-from-bracket"></i><span data-i18n="discardB">Discard</span></button>
        <span class="stat"><i class="fa-regular fa-clock"></i> <span data-i18n="round">Round</span> <span id="roundNo">1</span></span>
        <span class="stat"><i class="fa-solid fa-ranking-star"></i> <span data-i18n="score">Score</span>: <span id="scoreYou">0</span> — <span id="scoreAi">0</span></span>
      </div>
    </div>

    <div class="panel info" id="help">
      <strong data-i18n="rulesH">Rules</strong> — <span data-i18n="rules">Draw from stock or discard, optionally lay melds (3+ same-rank or same-suit runs; A low or high; jokers wild), then discard one card. First to go out ends round; opponent counts points in hand.</span>
    </div>
  </main>

  <div class="toast" id="toast"><i class="fa-solid fa-circle-info"></i><span id="toastMsg"></span></div>

  <script>
    const i18n = {
      en: {
        title:'Gin Rummy', new:'New Game', jokers:'Jokers', hand:'Cards', ai:'AI', cards:'Cards', stock:'Stock', discard:'Discard', you:'You',
        drawS:'Draw Stock', drawD:'Draw Discard', lay:'Lay Meld', discardB:'Discard', round:'Round', score:'Score',
        rulesH:'Rules', rules:'Draw from stock or discard, optionally lay melds (3+ same-rank or same-suit runs; A low or high; jokers wild), then discard one card. First to go out ends round; opponent counts points in hand.',
        theme:'Theme', dark:'Dark', light:'Light',
        mustDraw:'You must draw first.',
        mustSelectForDiscard:'Select one card to discard.',
        invalidMeld:'Selected cards do not form a valid meld.',
        tookFromDiscard:'You drew the discard.',
        drewFromStock:'You drew from stock.',
        yourTurn:'Your turn.',
        aiTurn:'AI is thinking…',
        youWinRound:'You went out! AI counts points: ',
        aiWinRound:'AI went out! You count points: ',
        gameOver:'Game over.'
      },
      pt: {
        title:'Rummy (Pife)', new:'Novo Jogo', jokers:'Coringas', hand:'Cartas', ai:'IA', cards:'Cartas', stock:'Monte', discard:'Descarte', you:'Você',
        drawS:'Comprar do Monte', drawD:'Pegar do Descarte', lay:'Baixar Jogo', discardB:'Descartar', round:'Rodada', score:'Placar',
        rulesH:'Regras', rules:'Compre do monte ou do descarte, opcionalmente baixe jogos (3+ do mesmo valor ou sequência do mesmo naipe; A baixo ou alto; coringa é curinga), depois descarte uma carta. Quem termina primeiro encerra a rodada; o oponente conta pontos na mão.',
        theme:'Tema', dark:'Escuro', light:'Claro',
        mustDraw:'Você precisa comprar primeiro.',
        mustSelectForDiscard:'Selecione uma carta para descartar.',
        invalidMeld:'As cartas selecionadas não formam um jogo válido.',
        tookFromDiscard:'Você pegou do descarte.',
        drewFromStock:'Você comprou do monte.',
        yourTurn:'Sua vez.',
        aiTurn:'IA pensando…',
        youWinRound:'Você terminou! IA conta pontos: ',
        aiWinRound:'IA terminou! Você conta pontos: ',
        gameOver:'Fim de jogo.'
      },
      ja: {
        title:'ジン・ラミー', new:'新しいゲーム', jokers:'ジョーカー', hand:'枚数', ai:'AI', cards:'枚', stock:'山札', discard:'捨て札', you:'あなた',
        drawS:'山札から引く', drawD:'捨て札を取る', lay:'役を出す', discardB:'捨てる', round:'ラウンド', score:'スコア',
        rulesH:'ルール', rules:'山札または捨て札から引き、必要なら役（同ランク3枚以上 or 同スート連続）を出し、1枚捨てる。先に上がった方で終了。相手は手札の点数を数える。Aは低/高、ジョーカーはワイルド。',
        theme:'テーマ', dark:'ダーク', light:'ライト',
        mustDraw:'先に引いてください。',
        mustSelectForDiscard:'捨てるカードを1枚選んでください。',
        invalidMeld:'選択したカードは有効な役ではありません。',
        tookFromDiscard:'捨て札を取りました。',
        drewFromStock:'山札から引きました。',
        yourTurn:'あなたの番です。',
        aiTurn:'AIが考えています…',
        youWinRound:'あなたが上がりました！ AIの残り点数: ',
        aiWinRound:'AIが上がりました！ あなたの残り点数: ',
        gameOver:'ゲーム終了。'
      }
    };

    const els = {
      btnNew: document.getElementById('btnNew'),
      optJokers: document.getElementById('optJokers'),
      theme: document.getElementById('theme'),
      lang: document.getElementById('lang'),
      stock: document.getElementById('stock'),
      discard: document.getElementById('discard'),
      melds: document.getElementById('melds'),
      yourHand: document.getElementById('yourHand'),
      stockCount: document.getElementById('stockCount'),
      aiCount: document.getElementById('aiCount'),
      roundNo: document.getElementById('roundNo'),
      scoreYou: document.getElementById('scoreYou'),
      scoreAi: document.getElementById('scoreAi'),
      btnDrawStock: document.getElementById('btnDrawStock'),
      btnDrawDiscard: document.getElementById('btnDrawDiscard'),
      btnLay: document.getElementById('btnLay'),
      btnDiscard: document.getElementById('btnDiscard'),
      toast: document.getElementById('toast'),
      toastMsg: document.getElementById('toastMsg')
    };

    const LS = { lang:'rummy.v1.lang', score:'rummy.v1.score', theme:'rummy.v1.theme' };

    const SUITS = ['S','H','D','C'];
    const SUIT_SYMBOL = { S:'♠', H:'♥', D:'♦', C:'♣' };
    const RED = new Set(['H','D']);

    let state = {
      round: 1,
      turn: 'you', // 'you' | 'ai'
      mustDraw: true,
      deck: [],
      stock: [],
      discard: [],
      you: [],
      ai: [],
      melds: [], // {owner:'you'|'ai', cards:[Card], type:'set'|'run'}
      jokers: false,
      handSize: 9,
      selected: new Set(),
      score: { you:0, ai:0 },
      highlightId: null
    };

    function t(key){ const lang = els.lang.value || 'en'; return (i18n[lang] && i18n[lang][key]) || i18n.en[key] || key; }
    function applyI18n(){ document.querySelectorAll('[data-i18n]').forEach(e=>{ const k=e.getAttribute('data-i18n'); e.textContent = t(k); }); document.title=t('title'); }
    function toast(msg){ els.toastMsg.textContent = msg; els.toast.classList.add('show'); setTimeout(()=>els.toast.classList.remove('show'), 1800); }

    function buildDeck(jokers){
      const deck = [];
      let uid = 1;
      for(let d=0; d<2; d++){
        for(const s of SUITS){ for(let r=1;r<=13;r++){ deck.push({ id: uid++, rank:r, suit:s }); } }
      }
      if(jokers){ for(let j=0;j<4;j++){ deck.push({ id: uid++, rank:0, suit:'J', joker:true }); } }
      return deck;
    }
    function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } return a; }

    function cardPoints(card){ if(card.joker) return 15; if(card.rank>=10) return 10; if(card.rank===1) return 1; return card.rank; }
    function handPoints(cards){ return cards.reduce((s,c)=>s+cardPoints(c),0); }

    function startGame(){
      state.jokers = !!els.optJokers.checked;
      state.handSize = 9;
      state.deck = shuffle(buildDeck(state.jokers));
      state.stock = state.deck.slice();
      state.discard = [];
      state.you = [];
      state.ai = [];
      state.melds = [];
      state.selected = new Set();
      // deal
      for(let i=0;i<state.handSize;i++) state.you.push(state.stock.pop());
      for(let i=0;i<state.handSize;i++) state.ai.push(state.stock.pop());
      // flip one to discard
      state.discard.push(state.stock.pop());
      state.turn = 'you';
      state.mustDraw = true;
      renderAll();
      toast(t('yourTurn'));
    }

    function renderAll(){
      renderStock(); renderDiscard(); renderMelds(); renderHands(); renderMeta(); applyI18n();
    }

    function renderMeta(){
      els.stockCount.textContent = String(state.stock.length);
      els.aiCount.textContent = String(state.ai.length);
      els.roundNo.textContent = String(state.round);
      els.scoreYou.textContent = String(state.score.you);
      els.scoreAi.textContent = String(state.score.ai);
    }

    function renderStock(){
      els.stock.className = 'card back';
    }

    function renderDiscard(){
      els.discard.innerHTML = '';
      const top = state.discard[state.discard.length-1];
      if(!top){ return; }
      const c = createCardEl(top, true);
      c.title = 'Top of Discard';
      els.discard.appendChild(c);
    }

    function renderMelds(){
      els.melds.innerHTML = '';
      state.melds.forEach((m, idx)=>{
        const wrap = document.createElement('div');
        wrap.className = 'meld';
        const meta = document.createElement('div');
        meta.className = 'meta';
        meta.textContent = `${m.owner==='you'?t('you'):t('ai')} • ${m.type}`;
        wrap.appendChild(meta);
        m.cards.forEach(card => wrap.appendChild(createCardEl(card, false)));
        if(state.turn==='you'){
          const btn = document.createElement('button'); btn.className = 'btn act'; btn.innerHTML = `<i class="fa-solid fa-plus"></i> add`;
          btn.addEventListener('click', ()=>{
            const card = getSingleSelectedFrom(state.you);
            if(!card){ toast(t('mustSelectForDiscard')); return; }
            if(tryAddToMeld(m, card)){
              removeFromHand(state.you, card.id);
              clearSelection();
              collapseMeld(m);
              renderAll();
              persistScore();
            } else {
              toast(t('invalidMeld'));
            }
          });
          wrap.appendChild(btn);
        }
        els.melds.appendChild(wrap);
      });
    }

    function renderHands(){
      els.yourHand.innerHTML='';
      addSlot(0);
      state.you.forEach((card, i)=>{
        const el = createCardEl(card, true);
        el.setAttribute('draggable','true');
        el.dataset.id = String(card.id);
        if(state.selected.has(card.id)) el.classList.add('sel');
        if(state.highlightId === card.id) el.classList.add('newcard');
        el.addEventListener('click', ()=>{ toggleSelect(card.id); el.classList.toggle('sel'); });
        el.addEventListener('dragstart', (e)=>{ e.dataTransfer.setData('text/plain', String(card.id)); });
        els.yourHand.appendChild(el);
        addSlot(i+1);
      });
    }

    function addSlot(index){
      const slot = document.createElement('div');
      slot.className = 'slot';
      slot.dataset.index = String(index);
      slot.addEventListener('dragover', (e)=>{ e.preventDefault(); slot.classList.add('over'); });
      slot.addEventListener('dragleave', ()=>{ slot.classList.remove('over'); });
      slot.addEventListener('drop', (e)=>{
        e.preventDefault(); slot.classList.remove('over');
        const fromId = parseInt(e.dataTransfer.getData('text/plain')||'-1',10);
        const toIndex = parseInt(slot.dataset.index, 10);
        reorderToIndex(fromId, toIndex);
      });
      els.yourHand.appendChild(slot);
    }

    function reorderToIndex(fromId, toIndex){
      const fromIdx = state.you.findIndex(c=>c.id===fromId);
      if(fromIdx<0) return;
      const [card] = state.you.splice(fromIdx,1);
      let insertIdx = toIndex;
      if(fromIdx < toIndex) insertIdx = toIndex - 1;
      insertIdx = Math.max(0, Math.min(state.you.length, insertIdx));
      state.you.splice(insertIdx, 0, card);
      renderHands();
    }

    function createCardEl(card, show){
      const div = document.createElement('div');
      div.className = 'card' + (!show ? ' back' : '');
      if(!show) return div;
      const red = card.joker ? false : RED.has(card.suit);
      const sym = card.joker ? '★' : SUIT_SYMBOL[card.suit];
      const rankText = card.joker ? 'JOKER' : rankToText(card.rank);
      const top = document.createElement('div'); top.className = 'rank' + (red?' red':''); top.textContent = rankText;
      const mid = document.createElement('div'); mid.className = 'center' + (red?' red':''); mid.textContent = sym;
      const bot = document.createElement('div'); bot.className = 'suit' + (red?' red':''); bot.textContent = sym;
      div.appendChild(top); div.appendChild(mid); div.appendChild(bot);
      return div;
    }

    function rankToText(r){ if(r===1) return 'A'; if(r===11) return 'J'; if(r===12) return 'Q'; if(r===13) return 'K'; return String(r); }

    function toggleSelect(id){ if(state.selected.has(id)) state.selected.delete(id); else state.selected.add(id); }
    function clearSelection(){ state.selected.clear(); }
    function getSelectedFrom(arr){ const ids = new Set(state.selected); return arr.filter(c=>ids.has(c.id)); }
    function getSingleSelectedFrom(arr){ const pick = getSelectedFrom(arr); return pick.length===1 ? pick[0] : null; }

    // Actions
    els.btnDrawStock.addEventListener('click', ()=>{
      if(state.turn!=='you') return;
      if(!state.mustDraw){ toast(t('aiTurn')); return; }
      drawFromStock('you');
      toast(t('drewFromStock'));
    });
    els.stock.addEventListener('click', ()=>{ if(state.turn==='you' && state.mustDraw) els.btnDrawStock.click(); });

    els.btnDrawDiscard.addEventListener('click', ()=>{
      if(state.turn!=='you') return;
      if(!state.mustDraw){ toast(t('aiTurn')); return; }
      if(state.discard.length===0) return;
      drawFromDiscard('you');
      toast(t('tookFromDiscard'));
    });

    els.btnLay.addEventListener('click', ()=>{
      if(state.turn!=='you') return;
      const cards = getSelectedFrom(state.you);
      if(cards.length<3){ toast(t('invalidMeld')); return; }
      const md = validateMeld(cards);
      if(!md.valid){ toast(t('invalidMeld')); return; }
      // remove from hand
      cards.forEach(c=>removeFromHand(state.you, c.id));
      state.melds.push({ owner:'you', cards:[...cards].sort(sortByRank), type: md.type });
      clearSelection();
      collapseMeld(state.melds[state.melds.length-1]);
      renderAll();
      persistScore();
    });

    els.btnDiscard.addEventListener('click', ()=>{
      if(state.turn!=='you') return;
      if(state.mustDraw){ toast(t('mustDraw')); return; }
      const card = getSingleSelectedFrom(state.you);
      if(!card){ toast(t('mustSelectForDiscard')); return; }
      // Discard
      removeFromHand(state.you, card.id);
      state.discard.push(card);
      clearSelection(); renderAll();
      // Check go out
      if(state.you.length===0){ endRound('you'); return; }
      endTurn();
    });

    function removeFromHand(hand, id){ const i = hand.findIndex(c=>c.id===id); if(i>=0) hand.splice(i,1); }

    function endTurn(){ state.turn = (state.turn==='you') ? 'ai' : 'you'; state.mustDraw = true; renderAll(); if(state.turn==='ai') aiTurn(); else toast(t('yourTurn')); }

    // Meld validation
    function sortByRank(a,b){ return (a.rank||0) - (b.rank||0); }
    function validateMeld(cards){
      const nonJ = cards.filter(c=>!c.joker);
      const jokers = cards.filter(c=>c.joker);
      // Set: same rank, different suits
      if(nonJ.length>=1){
        const rank = nonJ[0].rank; if(nonJ.every(c=>c.rank===rank)){
          const suits = new Set(nonJ.map(c=>c.suit));
          if(suits.size === nonJ.length){
            return { valid: cards.length>=3, type:'set' };
          }
        }
      }
      // Run: same suit, consecutive, A low or high, allow jokers to fill gaps
      if(nonJ.length>=1){
        const suit = nonJ[0].suit; if(nonJ.every(c=>c.suit===suit)){
          const ranks = nonJ.map(c=>c.rank).sort((a,b)=>a-b);
          // Try build sequence by allowing jokers to fill holes
          let needed = 0; for(let i=1;i<ranks.length;i++){ const gap = ranks[i]-ranks[i-1]; needed += Math.max(0, gap-1); }
          // Handle A as high: translate A(1) to 14 option if it helps
          let best = needed;
          if(ranks[0]===1){
            const r2 = ranks.slice(); r2[0]=14; r2.sort((a,b)=>a-b);
            let need2=0; for(let i=1;i<r2.length;i++){ const gap=r2[i]-r2[i-1]; need2 += Math.max(0,gap-1); }
            best = Math.min(best, need2);
          }
          if(best <= jokers.length){
            return { valid: cards.length>=3, type:'run' };
          }
        }
      }
      return { valid:false };
    }

    function tryAddToMeld(meld, card){
      if(meld.type==='set'){
        if(card.joker) { meld.cards.push(card); return true; }
        const ranksEqual = meld.cards.filter(c=>!c.joker).every(c=>c.rank===card.rank);
        const suits = new Set(meld.cards.filter(c=>!c.joker).map(c=>c.suit));
        if(ranksEqual && !suits.has(card.suit)) { meld.cards.push(card); return true; }
        return false;
      } else { // run
        const suit = meld.cards.find(c=>!c.joker)?.suit || card.suit;
        if(!card.joker && card.suit!==suit) return false;
        const vals = meld.cards.map(c=> c.joker ? null : c.rank);
        // consider A high
        const useHighA = vals.includes(13) && (card.rank===1 || vals.includes(1));
        const ranks = meld.cards.map(c=> c.joker? null : (useHighA && c.rank===1 ? 14 : c.rank));
        const addRank = card.joker ? null : (useHighA && card.rank===1 ? 14 : card.rank);
        const filled = ranks.filter(x=>x!=null).sort((a,b)=>a-b);
        let canAttach = false;
        if(addRank!=null){
          canAttach = (addRank === filled[0]-1) || (addRank === filled[filled.length-1]+1) || filled.indexOf(addRank)<0;
          if(!canAttach) return false;
          meld.cards.push(card); return true;
        } else {
          // joker always allowed
          meld.cards.push(card); return true;
        }
      }
    }

    function collapseMeld(m){
      // Sort set by suit order; run by rank
      if(m.type==='set'){
        const order = { S:0,H:1,D:2,C:3 };
        m.cards.sort((a,b)=>{
          if(a.joker && !b.joker) return 1; if(b.joker && !a.joker) return -1;
          if(a.suit===b.suit) return (a.rank)-(b.rank);
          return (order[a.suit]??9) - (order[b.suit]??9);
        });
      } else {
        const useHighA = m.cards.some(c=>!c.joker && c.rank===13) && m.cards.some(c=>!c.joker && c.rank===1);
        m.cards.sort((a,b)=>{
          const ra = a.joker ? 999 : (useHighA && a.rank===1 ? 14 : a.rank);
          const rb = b.joker ? 999 : (useHighA && b.rank===1 ? 14 : b.rank);
          return ra-rb;
        });
      }
    }

    function drawFromStock(who){
      if(state.stock.length===0){ // recycle discard (keep top?)
        if(state.discard.length>1){
          const top = state.discard.pop();
          state.stock = shuffle(state.discard.splice(0));
          state.discard = [top];
        } else {
          // stalemate
          endRound('none'); return;
        }
      }
      const card = state.stock.pop();
      if(who==='you'){
        state.you.push(card);
        state.highlightId = card.id;
        setTimeout(()=>{ if(state.highlightId===card.id){ state.highlightId=null; renderHands(); } }, 2000);
      } else state.ai.push(card);
      state.mustDraw = false; renderAll();
    }

    function drawFromDiscard(who){
      const c = state.discard.pop();
      if(!c) return;
      if(who==='you'){
        state.you.push(c);
        state.highlightId = c.id;
        setTimeout(()=>{ if(state.highlightId===c.id){ state.highlightId=null; renderHands(); } }, 2000);
      } else state.ai.push(c);
      state.mustDraw = false; renderAll();
    }

    function aiTurn(){
      toast(t('aiTurn'));
      setTimeout(()=>{
        // 1) draw decision
        const top = state.discard[state.discard.length-1];
        let tookDiscard = false;
        if(top && aiWants(top)){
          state.ai.push(state.discard.pop()); tookDiscard = true;
        } else {
          drawFromStock('ai');
        }
        // 2) try lay melds
        let progress = true;
        while(progress){
          progress = false;
          const m = findAnyMeld(state.ai);
          if(m){
            m.cards.forEach(c=>removeFromHand(state.ai, c.id));
            state.melds.push({ owner:'ai', cards:m.cards, type:m.type });
            collapseMeld(state.melds[state.melds.length-1]);
            progress = true;
          }
        }
        // 3) try add to table
        outer: for(let i=0;i<state.ai.length;i++){
          const c = state.ai[i];
          for(const m of state.melds){ if(tryAddToMeld(m, c)){ state.ai.splice(i,1); i--; collapseMeld(m); break outer; } }
        }
        // 4) discard least useful
        if(state.ai.length>0){
          const idx = pickLeastUseful(state.ai);
          state.discard.push(state.ai.splice(idx,1)[0]);
        }
        renderAll();
        if(state.ai.length===0){ endRound('ai'); return; }
        endTurn();
      }, 500);
    }

    function aiWants(card){
      if(card.joker) return true;
      // Prefer if matches any rank for set
      if(state.ai.some(c=>!c.joker && c.rank===card.rank)) return true;
      // Prefer if adjacent same suit run potential
      if(state.ai.some(c=>!c.joker && c.suit===card.suit && Math.abs(c.rank - card.rank)===1)) return true;
      return false;
    }

    function findAnyMeld(hand){
      // Try sets first
      const byRank = new Map();
      for(const c of hand){ if(c.joker) continue; const k=c.rank; (byRank.get(k)||byRank.set(k,[]).get(k)).push(c); }
      const jokers = hand.filter(c=>c.joker);
      for(const [r, list] of byRank){
        if(list.length + jokers.length >= 3){
          const take = list.slice(0);
          for(let j=0;j<Math.min(jokers.length, 4-list.length); j++) take.push(jokers[j]);
          return { type:'set', cards: take.slice(0, Math.max(3, take.length)) };
        }
      }
      // Runs per suit
      for(const s of SUITS){
        const inSuit = hand.filter(c=>!c.joker && c.suit===s).sort((a,b)=>a.rank-b.rank);
        if(inSuit.length>=2){
          const jok = jokers.slice();
          let seq=[inSuit[0]];
          for(let i=1;i<inSuit.length;i++){
            const gap = inSuit[i].rank - inSuit[i-1].rank;
            if(gap===1){ seq.push(inSuit[i]); }
            else if(gap>1){
              const need = gap-1;
              if(jok.length>=need){ seq.push(...jok.splice(0,need).map(_=>({joker:true, rank:0, suit:'J', id:-(Math.random()*1e6|0)}))); seq.push(inSuit[i]); }
              else { if(seq.length>=3) return { type:'run', cards: seq }; seq=[inSuit[i]]; }
            }
          }
          if(seq.length>=3) return { type:'run', cards: seq };
        }
      }
      return null;
    }

    function pickLeastUseful(hand){
      let bestIdx = 0; let bestScore = 1e9; let bestPts = -1;
      for(let i=0;i<hand.length;i++){
        const c = hand[i];
        let score = 0;
        if(c.joker){ score = 1000; } // never discard joker unless forced
        // prefer keeping cards that form pairs/near-runs
        for(const o of hand){ if(o===c) continue; if(!o.joker){ if(o.rank===c.rank) score -= 3; if(o.suit===c.suit && Math.abs(o.rank-c.rank)<=1) score -= 2; }}
        const pts = cardPoints(c);
        // prefer discarding high points
        score += pts * 0.5;
        if(score < bestScore || (score===bestScore && pts>bestPts)) { bestScore=score; bestIdx=i; bestPts=pts; }
      }
      return bestIdx;
    }

    function endRound(winner){
      let youDead = handPoints(state.you);
      let aiDead = handPoints(state.ai);
      if(winner==='you'){
        state.score.you += aiDead;
        toast(t('youWinRound') + aiDead);
      } else if(winner==='ai'){
        state.score.ai += youDead;
        toast(t('aiWinRound') + youDead);
      } else {
        toast(t('gameOver'));
      }
      state.round += 1;
      persistScore();
      // Start next round automatically
      setTimeout(()=>startGame(), 900);
    }

    function persistScore(){
      try{ localStorage.setItem(LS.score, JSON.stringify(state.score)); }catch(e){}
    }

    function restoreScore(){
      try{ const s = JSON.parse(localStorage.getItem(LS.score)||'null'); if(s) state.score = s; }catch(e){}
    }

    // Events
    els.btnNew.addEventListener('click', startGame);
    els.lang.addEventListener('change', ()=>{ localStorage.setItem(LS.lang, els.lang.value); applyI18n(); });
    els.theme.addEventListener('change', ()=>{ localStorage.setItem(LS.theme, els.theme.value); applyTheme(els.theme.value); });

    // Allow clicking discard to draw when allowed
    els.discard.addEventListener('click', ()=>{ if(state.turn==='you' && state.mustDraw) els.btnDrawDiscard.click(); });

    // Boot
    function applyTheme(theme){ document.documentElement.setAttribute('data-theme', theme==='light' ? 'light' : 'dark'); }

    (function init(){
      const lang = localStorage.getItem(LS.lang); if(lang) els.lang.value = lang; applyI18n();
      const theme = localStorage.getItem(LS.theme) || 'dark'; els.theme.value = theme; applyTheme(theme);
      restoreScore(); renderMeta(); startGame();
    })();
  </script>
</body>
</html>

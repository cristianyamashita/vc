<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Type Invaders</title>
  <style>
    :root {
      --bg: #0a0a1a;
      --text: #00ff88;
      --text-dim: #00aa66;
      --accent: #ff3366;
      --accent-2: #00aaff;
      --word-bg: rgba(0, 255, 136, 0.1);
      --word-border: #00ff88;
      --correct: #00ff88;
      --wrong: #ff3366;
      --panel-bg: rgba(10, 10, 26, 0.95);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Courier New', monospace;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      overflow: hidden;
    }

    #game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      background: 
        radial-gradient(ellipse at 50% 0%, rgba(0, 170, 255, 0.1) 0%, transparent 50%),
        linear-gradient(180deg, #0a0a1a 0%, #050510 100%);
      overflow: hidden;
    }

    /* Stars background */
    .stars {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background-image: 
        radial-gradient(2px 2px at 20px 30px, white, transparent),
        radial-gradient(2px 2px at 40px 70px, rgba(255,255,255,0.8), transparent),
        radial-gradient(1px 1px at 90px 40px, white, transparent),
        radial-gradient(2px 2px at 130px 80px, rgba(255,255,255,0.6), transparent),
        radial-gradient(1px 1px at 160px 120px, white, transparent);
      background-size: 200px 200px;
      animation: stars-move 100s linear infinite;
    }

    @keyframes stars-move {
      from { background-position: 0 0; }
      to { background-position: 0 1000px; }
    }

    /* HUD */
    #hud {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 25px;
      background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, transparent 100%);
      z-index: 100;
      font-size: 16px;
    }

    .hud-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .hud-label {
      color: var(--text-dim);
      text-transform: uppercase;
      font-size: 12px;
    }

    .hud-value {
      font-size: 20px;
      font-weight: bold;
      color: var(--text);
      text-shadow: 0 0 10px var(--text);
    }

    #lives {
      display: flex;
      gap: 5px;
    }

    .life {
      width: 20px;
      height: 20px;
      background: var(--accent);
      clip-path: polygon(50% 0%, 100% 35%, 80% 100%, 50% 75%, 20% 100%, 0% 35%);
      box-shadow: 0 0 10px var(--accent);
    }

    .life.lost {
      background: #333;
      box-shadow: none;
    }

    /* Game area */
    #game-area {
      position: absolute;
      top: 60px;
      bottom: 120px;
      left: 0;
      right: 0;
    }

    /* Defense line */
    #defense-line {
      position: absolute;
      bottom: 120px;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, 
        transparent 0%, 
        var(--accent) 20%, 
        var(--accent) 80%, 
        transparent 100%);
      box-shadow: 0 0 20px var(--accent), 0 0 40px var(--accent);
      animation: pulse-line 2s ease-in-out infinite;
    }

    @keyframes pulse-line {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 1; }
    }

    /* Words */
    .word {
      position: absolute;
      padding: 8px 16px;
      background: var(--word-bg);
      border: 2px solid var(--word-border);
      border-radius: 8px;
      font-size: 24px;
      font-weight: bold;
      letter-spacing: 2px;
      text-transform: uppercase;
      transition: transform 0.1s ease;
      cursor: default;
      user-select: none;
    }

    .word.targeted {
      border-color: var(--accent-2);
      box-shadow: 0 0 20px var(--accent-2), 0 0 40px rgba(0, 170, 255, 0.3);
      transform: scale(1.05);
    }

    .word .typed {
      color: var(--correct);
      text-shadow: 0 0 10px var(--correct);
    }

    .word .remaining {
      color: var(--text-dim);
    }

    /* Input area */
    #input-area {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 120px;
      background: linear-gradient(0deg, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.5) 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 10px;
      padding: 15px;
    }

    #current-target {
      font-size: 14px;
      color: var(--text-dim);
      height: 20px;
    }

    #input-wrapper {
      position: relative;
      width: 100%;
      max-width: 500px;
    }

    #type-input {
      width: 100%;
      padding: 15px 25px;
      font-size: 28px;
      font-family: 'Courier New', monospace;
      background: rgba(0, 255, 136, 0.1);
      border: 3px solid var(--text);
      border-radius: 12px;
      color: var(--text);
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 4px;
      outline: none;
      box-shadow: 0 0 30px rgba(0, 255, 136, 0.2), inset 0 0 20px rgba(0, 255, 136, 0.1);
    }

    #type-input:focus {
      border-color: var(--accent-2);
      box-shadow: 0 0 30px rgba(0, 170, 255, 0.3), inset 0 0 20px rgba(0, 170, 255, 0.1);
    }

    #type-input.error {
      border-color: var(--wrong);
      animation: shake 0.3s ease;
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-10px); }
      75% { transform: translateX(10px); }
    }

    /* Explosions */
    .explosion {
      position: absolute;
      pointer-events: none;
      animation: explode 0.5s ease-out forwards;
    }

    .explosion-particle {
      position: absolute;
      width: 8px;
      height: 8px;
      background: var(--text);
      border-radius: 50%;
      box-shadow: 0 0 10px var(--text);
    }

    @keyframes explode {
      0% { transform: scale(1); opacity: 1; }
      100% { transform: scale(2); opacity: 0; }
    }

    /* Screens */
    .screen {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: var(--panel-bg);
      z-index: 1000;
      gap: 30px;
    }

    .screen.hidden {
      display: none;
    }

    .screen h1 {
      font-size: 48px;
      text-shadow: 0 0 20px var(--text);
      letter-spacing: 8px;
      text-transform: uppercase;
    }

    .screen h2 {
      font-size: 32px;
      color: var(--accent);
      text-shadow: 0 0 15px var(--accent);
    }

    .screen p {
      font-size: 18px;
      color: var(--text-dim);
      text-align: center;
      max-width: 500px;
      line-height: 1.6;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 20px;
      margin: 20px 0;
    }

    .stat-item {
      text-align: center;
    }

    .stat-label {
      font-size: 12px;
      color: var(--text-dim);
      text-transform: uppercase;
    }

    .stat-value {
      font-size: 28px;
      color: var(--text);
      text-shadow: 0 0 10px var(--text);
    }

    .btn {
      padding: 15px 40px;
      font-size: 20px;
      font-family: 'Courier New', monospace;
      background: transparent;
      border: 3px solid var(--text);
      color: var(--text);
      border-radius: 10px;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 4px;
      transition: all 0.3s ease;
    }

    .btn:hover {
      background: var(--text);
      color: var(--bg);
      box-shadow: 0 0 30px var(--text);
    }

    .btn-secondary {
      border-color: var(--accent-2);
      color: var(--accent-2);
    }

    .btn-secondary:hover {
      background: var(--accent-2);
      color: var(--bg);
      box-shadow: 0 0 30px var(--accent-2);
    }

    /* Language selector */
    .lang-selector {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      gap: 10px;
    }

    .lang-btn {
      padding: 8px 12px;
      font-size: 14px;
      font-family: 'Courier New', monospace;
      background: transparent;
      border: 2px solid var(--text-dim);
      color: var(--text-dim);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .lang-btn:hover, .lang-btn.active {
      border-color: var(--text);
      color: var(--text);
    }

    /* Level up notification */
    #level-up {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      color: var(--accent-2);
      text-shadow: 0 0 30px var(--accent-2);
      animation: level-up 1.5s ease-out forwards;
      pointer-events: none;
      z-index: 500;
    }

    #level-up.hidden {
      display: none;
    }

    @keyframes level-up {
      0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
      20% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
      80% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
    }

    /* Combo indicator */
    #combo {
      position: absolute;
      top: 100px;
      right: 30px;
      text-align: right;
    }

    #combo.hidden {
      display: none;
    }

    #combo-count {
      font-size: 36px;
      color: var(--accent-2);
      text-shadow: 0 0 15px var(--accent-2);
    }

    #combo-label {
      font-size: 14px;
      color: var(--text-dim);
      text-transform: uppercase;
    }

    /* Difficulty indicator */
    #difficulty-display {
      position: absolute;
      top: 100px;
      left: 30px;
    }

    .difficulty-label {
      font-size: 12px;
      color: var(--text-dim);
      text-transform: uppercase;
    }

    .difficulty-bar {
      width: 150px;
      height: 8px;
      background: rgba(255,255,255,0.1);
      border-radius: 4px;
      margin-top: 5px;
      overflow: hidden;
    }

    .difficulty-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--text), var(--accent-2), var(--accent));
      border-radius: 4px;
      transition: width 0.5s ease;
    }

    /* Instructions */
    .instructions {
      background: rgba(0, 255, 136, 0.1);
      border: 1px solid var(--text-dim);
      border-radius: 10px;
      padding: 20px 30px;
      margin: 20px 0;
    }

    .instructions h3 {
      color: var(--text);
      margin-bottom: 10px;
    }

    .instructions ul {
      list-style: none;
      text-align: left;
    }

    .instructions li {
      padding: 5px 0;
      color: var(--text-dim);
    }

    .instructions li::before {
      content: '▸ ';
      color: var(--accent-2);
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div class="stars"></div>
    
    <!-- Start Screen -->
    <div id="start-screen" class="screen">
      <div class="lang-selector">
        <button class="lang-btn active" data-lang="en">EN</button>
        <button class="lang-btn" data-lang="pt">PT</button>
        <button class="lang-btn" data-lang="ja">JA</button>
      </div>
      <h1 data-i18n="title">Type Invaders</h1>
      <p data-i18n="description">Defend Earth by typing words before they reach the defense line! Words start slow and short, but get faster and longer as you progress.</p>
      <div class="instructions">
        <h3 data-i18n="howToPlay">How to Play</h3>
        <ul>
          <li data-i18n="instruction1">Type the falling words correctly</li>
          <li data-i18n="instruction2">Words automatically match as you type</li>
          <li data-i18n="instruction3">Press Enter or complete the word to destroy it</li>
          <li data-i18n="instruction4">Don't let words reach the red line!</li>
          <li data-i18n="instruction5">Build combos for bonus points</li>
        </ul>
      </div>
      <button class="btn" id="start-btn" data-i18n="startGame">Start Game</button>
    </div>

    <!-- Game Over Screen -->
    <div id="gameover-screen" class="screen hidden">
      <h2 data-i18n="gameOver">Game Over</h2>
      <div class="stats">
        <div class="stat-item">
          <div class="stat-label" data-i18n="finalScore">Final Score</div>
          <div class="stat-value" id="final-score">0</div>
        </div>
        <div class="stat-item">
          <div class="stat-label" data-i18n="level">Level</div>
          <div class="stat-value" id="final-level">1</div>
        </div>
        <div class="stat-item">
          <div class="stat-label" data-i18n="wordsDestroyed">Words Destroyed</div>
          <div class="stat-value" id="final-words">0</div>
        </div>
        <div class="stat-item">
          <div class="stat-label" data-i18n="maxCombo">Max Combo</div>
          <div class="stat-value" id="final-combo">0</div>
        </div>
      </div>
      <div style="display: flex; gap: 20px;">
        <button class="btn" id="restart-btn" data-i18n="playAgain">Play Again</button>
        <button class="btn btn-secondary" id="menu-btn" data-i18n="mainMenu">Main Menu</button>
      </div>
    </div>

    <!-- HUD -->
    <div id="hud">
      <div class="hud-item">
        <span class="hud-label" data-i18n="score">Score</span>
        <span class="hud-value" id="score">0</span>
      </div>
      <div class="hud-item">
        <span class="hud-label" data-i18n="level">Level</span>
        <span class="hud-value" id="level">1</span>
      </div>
      <div class="hud-item">
        <div id="lives"></div>
      </div>
    </div>

    <!-- Difficulty indicator -->
    <div id="difficulty-display">
      <div class="difficulty-label" data-i18n="difficulty">Difficulty</div>
      <div class="difficulty-bar">
        <div class="difficulty-fill" id="difficulty-fill" style="width: 10%"></div>
      </div>
    </div>

    <!-- Combo indicator -->
    <div id="combo" class="hidden">
      <div id="combo-count">0</div>
      <div id="combo-label">COMBO</div>
    </div>

    <!-- Level up notification -->
    <div id="level-up" class="hidden"></div>

    <!-- Game Area -->
    <div id="game-area"></div>

    <!-- Defense Line -->
    <div id="defense-line"></div>

    <!-- Input Area -->
    <div id="input-area">
      <div id="current-target"></div>
      <div id="input-wrapper">
        <input type="text" id="type-input" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
      </div>
    </div>
  </div>

  <script>
    // Word lists by difficulty
    const wordLists = {
      easy: [
        'cat', 'dog', 'sun', 'run', 'big', 'hot', 'red', 'box', 'cup', 'hat',
        'pen', 'map', 'top', 'car', 'bus', 'sky', 'fly', 'key', 'day', 'way',
        'old', 'new', 'yes', 'now', 'out', 'two', 'one', 'six', 'ten', 'end'
      ],
      medium: [
        'apple', 'water', 'house', 'light', 'music', 'earth', 'cloud', 'dream',
        'space', 'world', 'storm', 'night', 'magic', 'power', 'river', 'ocean',
        'tiger', 'eagle', 'green', 'black', 'white', 'happy', 'smart', 'quick',
        'brave', 'sweet', 'fresh', 'clear', 'sharp', 'round', 'speed', 'force'
      ],
      hard: [
        'keyboard', 'computer', 'adventure', 'challenge', 'discover', 'electric',
        'fantastic', 'graphics', 'halloween', 'important', 'junction', 'knowledge',
        'lightning', 'memorable', 'nightmare', 'objective', 'paradise', 'question',
        'revolution', 'satellite', 'telescope', 'umbrella', 'vacation', 'wonderful',
        'xylophone', 'yesterday', 'zeppelin', 'algorithm', 'butterfly', 'celebrate'
      ],
      extreme: [
        'acceleration', 'bibliography', 'catastrophic', 'determination', 'electromagnetic',
        'fundamentally', 'gravitational', 'hallucination', 'infrastructure', 'justification',
        'kaleidoscope', 'manufacturing', 'neurological', 'opportunities', 'philosophical',
        'questionable', 'revolutionary', 'sophisticated', 'technological', 'understanding'
      ]
    };

    // Translations
    const i18n = {
      en: {
        title: 'Type Invaders',
        description: 'Defend Earth by typing words before they reach the defense line! Words start slow and short, but get faster and longer as you progress.',
        howToPlay: 'How to Play',
        instruction1: 'Type the falling words correctly',
        instruction2: 'Words automatically match as you type',
        instruction3: 'Press Enter or complete the word to destroy it',
        instruction4: "Don't let words reach the red line!",
        instruction5: 'Build combos for bonus points',
        startGame: 'Start Game',
        gameOver: 'Game Over',
        finalScore: 'Final Score',
        level: 'Level',
        wordsDestroyed: 'Words Destroyed',
        maxCombo: 'Max Combo',
        playAgain: 'Play Again',
        mainMenu: 'Main Menu',
        score: 'Score',
        difficulty: 'Difficulty',
        levelUp: 'Level Up!',
        targeting: 'Targeting:'
      },
      pt: {
        title: 'Type Invaders',
        description: 'Defenda a Terra digitando palavras antes que cheguem à linha de defesa! Palavras começam lentas e curtas, mas ficam mais rápidas e longas conforme você progride.',
        howToPlay: 'Como Jogar',
        instruction1: 'Digite as palavras que caem corretamente',
        instruction2: 'Palavras são selecionadas automaticamente ao digitar',
        instruction3: 'Pressione Enter ou complete a palavra para destruí-la',
        instruction4: 'Não deixe as palavras chegarem à linha vermelha!',
        instruction5: 'Faça combos para pontos bônus',
        startGame: 'Iniciar Jogo',
        gameOver: 'Fim de Jogo',
        finalScore: 'Pontuação Final',
        level: 'Nível',
        wordsDestroyed: 'Palavras Destruídas',
        maxCombo: 'Combo Máximo',
        playAgain: 'Jogar Novamente',
        mainMenu: 'Menu Principal',
        score: 'Pontos',
        difficulty: 'Dificuldade',
        levelUp: 'Subiu de Nível!',
        targeting: 'Alvo:'
      },
      ja: {
        title: 'タイプインベーダー',
        description: '単語が防衛ラインに到達する前にタイプして地球を守れ！単語は最初はゆっくりで短いですが、進むにつれて速く長くなります。',
        howToPlay: '遊び方',
        instruction1: '落ちてくる単語を正しくタイプする',
        instruction2: 'タイプすると自動的に単語がマッチする',
        instruction3: 'Enterを押すか単語を完成させて破壊する',
        instruction4: '単語を赤いラインに到達させないで！',
        instruction5: 'コンボを作ってボーナスポイントを獲得',
        startGame: 'ゲーム開始',
        gameOver: 'ゲームオーバー',
        finalScore: '最終スコア',
        level: 'レベル',
        wordsDestroyed: '破壊した単語',
        maxCombo: '最大コンボ',
        playAgain: 'もう一度',
        mainMenu: 'メインメニュー',
        score: 'スコア',
        difficulty: '難易度',
        levelUp: 'レベルアップ！',
        targeting: 'ターゲット:'
      }
    };

    // Game state
    let currentLang = 'en';
    let gameRunning = false;
    let score = 0;
    let level = 1;
    let lives = 3;
    let words = [];
    let targetWord = null;
    let combo = 0;
    let maxCombo = 0;
    let wordsDestroyed = 0;
    let lastFrameTime = 0;
    let spawnTimer = 0;
    let animationId = null;

    // Game settings (adjusted by level)
    const baseSettings = {
      spawnInterval: 3000,   // ms between word spawns
      fallSpeed: 30,         // pixels per second
      maxWords: 3            // max words on screen
    };

    // DOM elements
    const gameContainer = document.getElementById('game-container');
    const gameArea = document.getElementById('game-area');
    const typeInput = document.getElementById('type-input');
    const scoreDisplay = document.getElementById('score');
    const levelDisplay = document.getElementById('level');
    const livesDisplay = document.getElementById('lives');
    const comboDisplay = document.getElementById('combo');
    const comboCount = document.getElementById('combo-count');
    const difficultyFill = document.getElementById('difficulty-fill');
    const levelUpDisplay = document.getElementById('level-up');
    const currentTargetDisplay = document.getElementById('current-target');
    const startScreen = document.getElementById('start-screen');
    const gameoverScreen = document.getElementById('gameover-screen');

    // Initialize
    function init() {
      setupLanguage();
      setupEventListeners();
      updateLives();
    }

    // Language setup
    function setupLanguage() {
      const savedLang = localStorage.getItem('type-invaders-lang') || 'en';
      setLanguage(savedLang);
    }

    function setLanguage(lang) {
      currentLang = lang;
      localStorage.setItem('type-invaders-lang', lang);

      document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        if (i18n[lang] && i18n[lang][key]) {
          el.textContent = i18n[lang][key];
        }
      });

      document.querySelectorAll('.lang-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.lang === lang);
      });
    }

    // Event listeners
    function setupEventListeners() {
      // Language buttons
      document.querySelectorAll('.lang-btn').forEach(btn => {
        btn.addEventListener('click', () => setLanguage(btn.dataset.lang));
      });

      // Start button
      document.getElementById('start-btn').addEventListener('click', startGame);
      document.getElementById('restart-btn').addEventListener('click', startGame);
      document.getElementById('menu-btn').addEventListener('click', showMainMenu);

      // Input handling
      typeInput.addEventListener('input', handleInput);
      typeInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          checkWordComplete();
        }
      });

      // Prevent input from losing focus
      document.addEventListener('click', () => {
        if (gameRunning) {
          typeInput.focus();
        }
      });
    }

    // Game control
    function startGame() {
      // Reset state
      score = 0;
      level = 1;
      lives = 3;
      words = [];
      targetWord = null;
      combo = 0;
      maxCombo = 0;
      wordsDestroyed = 0;
      spawnTimer = 0;
      lastFrameTime = performance.now();

      // Clear game area
      gameArea.innerHTML = '';

      // Update displays
      updateScore();
      updateLevel();
      updateLives();
      updateCombo();
      updateDifficulty();

      // Hide screens
      startScreen.classList.add('hidden');
      gameoverScreen.classList.add('hidden');

      // Start game
      gameRunning = true;
      typeInput.value = '';
      typeInput.focus();
      currentTargetDisplay.textContent = '';

      // Start game loop
      if (animationId) cancelAnimationFrame(animationId);
      gameLoop(performance.now());
    }

    function showMainMenu() {
      gameRunning = false;
      if (animationId) cancelAnimationFrame(animationId);
      gameArea.innerHTML = '';
      startScreen.classList.remove('hidden');
      gameoverScreen.classList.add('hidden');
    }

    function endGame() {
      gameRunning = false;
      if (animationId) cancelAnimationFrame(animationId);

      // Update final stats
      document.getElementById('final-score').textContent = score;
      document.getElementById('final-level').textContent = level;
      document.getElementById('final-words').textContent = wordsDestroyed;
      document.getElementById('final-combo').textContent = maxCombo;

      // Show game over screen
      gameoverScreen.classList.remove('hidden');
    }

    // Game loop
    function gameLoop(timestamp) {
      if (!gameRunning) return;

      const deltaTime = timestamp - lastFrameTime;
      lastFrameTime = timestamp;

      // Spawn words
      spawnTimer += deltaTime;
      const spawnInterval = getSpawnInterval();
      if (spawnTimer >= spawnInterval && words.length < getMaxWords()) {
        spawnWord();
        spawnTimer = 0;
      }

      // Update words
      updateWords(deltaTime);

      // Request next frame
      animationId = requestAnimationFrame(gameLoop);
    }

    // Word spawning
    function spawnWord() {
      const wordText = getRandomWord();
      const word = {
        text: wordText,
        typed: '',
        x: Math.random() * (gameArea.clientWidth - 200) + 50,
        y: -50,
        speed: getFallSpeed(),
        element: null
      };

      // Create DOM element
      const el = document.createElement('div');
      el.className = 'word';
      el.innerHTML = `<span class="typed"></span><span class="remaining">${wordText}</span>`;
      el.style.left = word.x + 'px';
      el.style.top = word.y + 'px';
      gameArea.appendChild(el);
      word.element = el;

      words.push(word);
    }

    function getRandomWord() {
      let pool;
      if (level <= 2) {
        pool = wordLists.easy;
      } else if (level <= 5) {
        pool = [...wordLists.easy, ...wordLists.medium];
      } else if (level <= 8) {
        pool = [...wordLists.medium, ...wordLists.hard];
      } else {
        pool = [...wordLists.hard, ...wordLists.extreme];
      }

      // Avoid duplicate words on screen
      const activeWords = words.map(w => w.text);
      const available = pool.filter(w => !activeWords.includes(w));
      
      if (available.length === 0) return pool[Math.floor(Math.random() * pool.length)];
      return available[Math.floor(Math.random() * available.length)];
    }

    // Level-based settings
    function getSpawnInterval() {
      const min = 800;
      const base = baseSettings.spawnInterval;
      return Math.max(min, base - (level - 1) * 200);
    }

    function getFallSpeed() {
      const base = baseSettings.fallSpeed;
      const variance = 10;
      return base + (level - 1) * 8 + (Math.random() * variance - variance / 2);
    }

    function getMaxWords() {
      return Math.min(8, baseSettings.maxWords + Math.floor(level / 2));
    }

    // Word updates
    function updateWords(deltaTime) {
      const defenseY = gameArea.clientHeight;

      for (let i = words.length - 1; i >= 0; i--) {
        const word = words[i];
        
        // Move word down
        word.y += word.speed * (deltaTime / 1000);
        word.element.style.top = word.y + 'px';

        // Check if word reached defense line
        if (word.y >= defenseY) {
          destroyWord(i, false);
          loseLife();
        }
      }
    }

    function destroyWord(index, success) {
      const word = words[index];
      
      if (success) {
        // Create explosion effect
        createExplosion(word.x + word.element.offsetWidth / 2, word.y + word.element.offsetHeight / 2);
        
        // Award points
        const points = word.text.length * 10 * (1 + combo * 0.1);
        addScore(Math.floor(points));
        
        // Increment combo and words destroyed
        combo++;
        maxCombo = Math.max(maxCombo, combo);
        wordsDestroyed++;
        updateCombo();
        
        // Check for level up
        if (wordsDestroyed % 10 === 0) {
          levelUp();
        }
      } else {
        // Reset combo on miss
        combo = 0;
        updateCombo();
      }

      // Remove word
      word.element.remove();
      words.splice(index, 1);

      // Clear target if it was the destroyed word
      if (targetWord === word) {
        targetWord = null;
        currentTargetDisplay.textContent = '';
        typeInput.value = '';
      }
    }

    function createExplosion(x, y) {
      const explosion = document.createElement('div');
      explosion.className = 'explosion';
      explosion.style.left = x + 'px';
      explosion.style.top = y + 'px';

      // Create particles
      for (let i = 0; i < 12; i++) {
        const particle = document.createElement('div');
        particle.className = 'explosion-particle';
        const angle = (i / 12) * Math.PI * 2;
        const distance = 30 + Math.random() * 20;
        particle.style.transform = `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px)`;
        explosion.appendChild(particle);
      }

      gameArea.appendChild(explosion);
      setTimeout(() => explosion.remove(), 500);
    }

    // Input handling
    function handleInput() {
      const typed = typeInput.value.toLowerCase();
      
      if (typed === '') {
        // Clear target
        if (targetWord) {
          targetWord.element.classList.remove('targeted');
          targetWord.typed = '';
          updateWordDisplay(targetWord);
        }
        targetWord = null;
        currentTargetDisplay.textContent = '';
        return;
      }

      // Find matching word
      let bestMatch = null;
      let bestMatchLength = 0;

      for (const word of words) {
        if (word.text.startsWith(typed) && typed.length > bestMatchLength) {
          bestMatch = word;
          bestMatchLength = typed.length;
        }
      }

      // Update target
      if (bestMatch !== targetWord) {
        if (targetWord) {
          targetWord.element.classList.remove('targeted');
          targetWord.typed = '';
          updateWordDisplay(targetWord);
        }
        targetWord = bestMatch;
        if (targetWord) {
          targetWord.element.classList.add('targeted');
        }
      }

      if (targetWord) {
        targetWord.typed = typed;
        updateWordDisplay(targetWord);
        currentTargetDisplay.textContent = `${i18n[currentLang].targeting} ${targetWord.text.toUpperCase()}`;
        typeInput.classList.remove('error');

        // Check if word is complete
        if (typed === targetWord.text) {
          const index = words.indexOf(targetWord);
          if (index !== -1) {
            destroyWord(index, true);
            typeInput.value = '';
          }
        }
      } else if (typed.length > 0) {
        // No matching word - show error
        typeInput.classList.add('error');
        setTimeout(() => typeInput.classList.remove('error'), 300);
        currentTargetDisplay.textContent = '';
      }
    }

    function checkWordComplete() {
      if (targetWord && typeInput.value.toLowerCase() === targetWord.text) {
        const index = words.indexOf(targetWord);
        if (index !== -1) {
          destroyWord(index, true);
          typeInput.value = '';
        }
      }
    }

    function updateWordDisplay(word) {
      const typedSpan = word.element.querySelector('.typed');
      const remainingSpan = word.element.querySelector('.remaining');
      typedSpan.textContent = word.typed.toUpperCase();
      remainingSpan.textContent = word.text.slice(word.typed.length).toUpperCase();
    }

    // Life management
    function loseLife() {
      lives--;
      updateLives();
      
      // Visual feedback
      gameContainer.style.animation = 'none';
      gameContainer.offsetHeight; // Trigger reflow
      gameContainer.style.animation = 'shake 0.3s ease';

      if (lives <= 0) {
        endGame();
      }
    }

    function updateLives() {
      livesDisplay.innerHTML = '';
      for (let i = 0; i < 3; i++) {
        const life = document.createElement('div');
        life.className = 'life' + (i >= lives ? ' lost' : '');
        livesDisplay.appendChild(life);
      }
    }

    // Score and level
    function addScore(points) {
      score += points;
      updateScore();
    }

    function updateScore() {
      scoreDisplay.textContent = score.toLocaleString();
    }

    function levelUp() {
      level++;
      updateLevel();
      updateDifficulty();

      // Show level up notification
      levelUpDisplay.textContent = `${i18n[currentLang].levelUp} ${level}`;
      levelUpDisplay.classList.remove('hidden');
      setTimeout(() => levelUpDisplay.classList.add('hidden'), 1500);
    }

    function updateLevel() {
      levelDisplay.textContent = level;
    }

    function updateDifficulty() {
      const percentage = Math.min(100, (level - 1) * 10 + 10);
      difficultyFill.style.width = percentage + '%';
    }

    function updateCombo() {
      if (combo >= 2) {
        comboDisplay.classList.remove('hidden');
        comboCount.textContent = combo + 'x';
      } else {
        comboDisplay.classList.add('hidden');
      }
    }

    // Start
    init();
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pachinko 3D</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Noto+Sans+JP:wght@400;700&display=swap');

        :root {
            --neon-pink: #ff00ff;
            --neon-blue: #00ffff;
            --neon-green: #39ff14;
            --bg-color: #0d0221;
            --text-color: #f0f0f0;
            --border-color: rgba(0, 255, 255, 0.5);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Orbitron', 'Noto Sans JP', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #webgl {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .ui-panel {
            position: absolute;
            background: rgba(10, 2, 30, 0.7);
            backdrop-filter: blur(5px);
            border: 2px solid var(--border-color);
            border-radius: 15px;
            padding: 10px 15px;
            box-shadow: 0 0 10px var(--neon-blue);
            text-align: center;
        }

        #lang-panel {
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            pointer-events: auto;
        }

        .lang-btn {
            background: transparent;
            border: 2px solid var(--neon-pink);
            color: var(--neon-pink);
            font-family: 'Orbitron', sans-serif;
            padding: 5px 10px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: 0 0 5px var(--neon-pink);
        }

        .lang-btn:hover, .lang-btn.active {
            background: var(--neon-pink);
            color: var(--bg-color);
            box-shadow: 0 0 15px var(--neon-pink);
        }

        #stats-panel {
            top: 20px;
            left: 20px;
            width: 150px;
        }

        #stats-panel h2 {
            margin: 0 0 10px 0;
            font-size: 1.2em;
            color: var(--neon-green);
            text-shadow: 0 0 8px var(--neon-green);
        }

        #stats-panel p {
            margin: 5px 0;
            font-size: 1em;
        }

        #controls-panel {
            bottom: 20px;
            width: 300px;
            max-width: 80%;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        
        #controls-panel label {
            font-size: 1em;
            color: var(--neon-blue);
            text-shadow: 0 0 5px var(--neon-blue);
        }

        #power-slider {
            width: 80%;
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
            height: 15px;
            background: rgba(0, 255, 255, 0.2);
            border-radius: 10px;
            border: 1px solid var(--neon-blue);
        }

        #power-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            background: var(--neon-green);
            border-radius: 50%;
            border: 2px solid var(--text-color);
            box-shadow: 0 0 10px var(--neon-green);
        }

        #launch-button {
            padding: 15px 30px;
            font-size: 1.2em;
            font-family: 'Orbitron', sans-serif;
            background: var(--neon-green);
            color: var(--bg-color);
            border: none;
            border-radius: 10px;
            cursor: pointer;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
            box-shadow: 0 0 15px var(--neon-green);
            transition: all 0.2s ease;
        }

        #launch-button:active {
            transform: scale(0.95);
            box-shadow: 0 0 5px var(--neon-green);
        }
        
        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: rgba(10, 2, 30, 0.9);
            border: 3px solid var(--neon-pink);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            transition: transform 0.5s ease-in-out;
            z-index: 100;
            font-size: 1.5em;
            text-shadow: 0 0 10px var(--neon-pink);
        }
        
        #message-box.show {
            transform: translate(-50%, -50%) scale(1);
        }
        
        #jackpot-message {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            font-size: 4em;
            font-weight: bold;
            color: var(--neon-pink);
            text-shadow: 0 0 10px #fff, 0 0 20px var(--neon-pink), 0 0 30px var(--neon-pink);
            opacity: 0;
            transition: all 0.5s ease-out;
            z-index: 101;
        }

        #jackpot-message.show {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="webgl"></canvas>
        <div id="ui-container">
            <div id="stats-panel" class="ui-panel">
                <h2 data-lang-key="stats">Stats</h2>
                <p><span data-lang-key="score">Score</span>: <span id="score">0</span></p>
                <p><span data-lang-key="balls">Balls</span>: <span id="balls">100</span></p>
            </div>
            
            <div id="lang-panel" class="ui-panel">
                <button class="lang-btn active" data-lang="jp">JP</button>
                <button class="lang-btn" data-lang="en">EN</button>
                <button class="lang-btn" data-lang="pt">PT</button>
            </div>

            <div id="controls-panel" class="ui-panel">
                <label for="power-slider" data-lang-key="power">Launch Power</label>
                <input type="range" id="power-slider" min="45" max="75" value="60">
                <button id="launch-button" data-lang-key="launch">LAUNCH</button>
            </div>
            
            <div id="message-box">
                <p data-lang-key="gameOver">Game Over!</p>
            </div>
            <div id="jackpot-message" data-lang-key="jackpot">JACKPOT!</div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/",
            "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';

        // --- LANGUAGE MANAGER ---
        const translations = {
            jp: {
                stats: 'ステータス',
                score: 'スコア',
                balls: '残り玉',
                power: '発射パワー',
                launch: '発射',
                gameOver: 'ゲームオーバー！',
                jackpot: 'ジャックポット！'
            },
            en: {
                stats: 'Stats',
                score: 'Score',
                balls: 'Balls',
                power: 'Launch Power',
                launch: 'LAUNCH',
                gameOver: 'Game Over!',
                jackpot: 'JACKPOT!'
            },
            pt: {
                stats: 'Estatísticas',
                score: 'Pontos',
                balls: 'Bolas',
                power: 'Força',
                launch: 'LANÇAR',
                gameOver: 'Fim de Jogo!',
                jackpot: 'JACKPOT!'
            }
        };

        const langButtons = document.querySelectorAll('.lang-btn');
        let currentLang = 'jp';

        function setLanguage(lang) {
            currentLang = lang;
            document.querySelectorAll('[data-lang-key]').forEach(el => {
                const key = el.dataset.langKey;
                if (translations[lang] && translations[lang][key]) {
                    el.textContent = translations[lang][key];
                }
            });
            langButtons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.lang === lang);
            });
        }

        langButtons.forEach(btn => {
            btn.addEventListener('click', () => setLanguage(btn.dataset.lang));
        });

        // --- GAME SETUP ---
        const scene = new THREE.Scene();
        const world = new CANNON.World({
            gravity: new CANNON.Vec3(0, -25, 0)
        });

        const canvas = document.getElementById('webgl');
        const renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: true,
            alpha: true
        });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        
        // --- SIZES AND CAMERA ---
        const boardSize = { width: 9, height: 16 };
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.set(0, 0, 22);
        scene.add(camera);

        function resize() {
            const container = document.getElementById('game-container');
            const { clientWidth, clientHeight } = container;
            renderer.setSize(clientWidth, clientHeight);
            camera.aspect = clientWidth / clientHeight;
            camera.updateProjectionMatrix();
        }
        window.addEventListener('resize', resize);
        
        // --- LIGHTING ---
        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const mainLight = new THREE.DirectionalLight(0xffffff, 2.0);
        mainLight.position.set(2, 5, 10);
        scene.add(mainLight);

        function addNeonLight(x, y, z, color) {
            const pointLight = new THREE.PointLight(color, 80, 15);
            pointLight.position.set(x, y, z);
            scene.add(pointLight);
        }
        addNeonLight(0, boardSize.height/2, 5, 0xff00ff);
        addNeonLight(-boardSize.width/2, 0, 5, 0x00ffff);
        addNeonLight(boardSize.width/2, 0, 5, 0x00ffff);

        // --- MATERIALS ---
        const ballMaterial = new CANNON.Material('ball');
        const pinMaterial = new CANNON.Material('pin');
        const wallMaterial = new CANNON.Material('wall');
        const pocketMaterial = new CANNON.Material('pocket');

        world.addContactMaterial(new CANNON.ContactMaterial(ballMaterial, pinMaterial, { friction: 0.1, restitution: 0.6 }));
        world.addContactMaterial(new CANNON.ContactMaterial(ballMaterial, wallMaterial, { friction: 0.1, restitution: 0.4 }));
        world.addContactMaterial(new CANNON.ContactMaterial(ballMaterial, pocketMaterial, { friction: 0.9, restitution: 0.1 }));
        
        const ballMeshMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.8, roughness: 0.1 });
        const pinMeshMaterial = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.6, roughness: 0.3 });
        const pocketMeshMaterials = {
            'win': new THREE.MeshStandardMaterial({ color: 0x39ff14, emissive: 0x39ff14, emissiveIntensity: 0.5 }),
            'jackpot': new THREE.MeshStandardMaterial({ color: 0xff00ff, emissive: 0xff00ff, emissiveIntensity: 0.7 }),
        };
        
        // --- GAME OBJECTS ---
        const objectsToUpdate = [];
        const ballRadius = 0.2;

        // Board Frame
        const frameDepth = 2;
        const frameThickness = 0.5;
        const frameMaterial = new THREE.MeshStandardMaterial({ color: 0x1a0530, metalness: 0.5, roughness: 0.4 });
        const framePositions = [
            { pos: [0, boardSize.height/2 + frameThickness/2, -frameDepth/2], scale: [boardSize.width + frameThickness*2, frameThickness, frameDepth] }, // Top
            { pos: [0, -boardSize.height/2 - frameThickness/2, -frameDepth/2], scale: [boardSize.width + frameThickness*2, frameThickness, frameDepth] }, // Bottom
            { pos: [-boardSize.width/2 - frameThickness/2, 0, -frameDepth/2], scale: [frameThickness, boardSize.height, frameDepth] }, // Left
            { pos: [boardSize.width/2 + frameThickness/2, 0, -frameDepth/2], scale: [frameThickness, boardSize.height, frameDepth] }, // Right
        ];
        framePositions.forEach(p => {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(p.scale[0], p.scale[1], p.scale[2]), frameMaterial);
            mesh.position.set(p.pos[0], p.pos[1], p.pos[2]);
            scene.add(mesh);
        });
        const backPlane = new THREE.Mesh(
            new THREE.PlaneGeometry(boardSize.width, boardSize.height),
            new THREE.MeshStandardMaterial({color: 0x05010d})
        );
        backPlane.position.z = -frameDepth/2;
        scene.add(backPlane);
        
        // Board Boundaries
        const wallDepth = 2;
        function createSideBoundary(x, y, width, height) {
            const shape = new CANNON.Box(new CANNON.Vec3(width/2, height/2, wallDepth/2));
            const body = new CANNON.Body({ mass: 0, material: wallMaterial });
            body.addShape(shape);
            body.position.set(x, y, 0);
            world.addBody(body);
        }
        createSideBoundary(boardSize.width / 2, 0, 0.1, boardSize.height); // Right Wall
        createSideBoundary(-boardSize.width / 2, 0, 0.1, boardSize.height); // Left Wall
        
        // --- FIX: Add a top boundary (ceiling) ---
        const ceilingBody = new CANNON.Body({
            mass: 0,
            material: wallMaterial,
            shape: new CANNON.Box(new CANNON.Vec3(boardSize.width / 2, 0.1, wallDepth))
        });
        ceilingBody.position.set(0, boardSize.height / 2, 0);
        world.addBody(ceilingBody);

        // Add front and back physics walls
        const backWallBody = new CANNON.Body({ mass: 0, material: wallMaterial, shape: new CANNON.Plane() });
        backWallBody.position.set(0, 0, -frameDepth / 2);
        world.addBody(backWallBody);

        const frontWallBody = new CANNON.Body({ mass: 0, material: wallMaterial, shape: new CANNON.Plane() });
        frontWallBody.position.set(0, 0, frameDepth / 2);
        frontWallBody.quaternion.setFromEuler(0, Math.PI, 0); // Face inwards
        world.addBody(frontWallBody);

        // --- NEW: Add bottom funnel walls ---
        function createFunnelWall(x, y, angle) {
            const funnelWallBody = new CANNON.Body({
                mass: 0,
                material: wallMaterial,
                shape: new CANNON.Box(new CANNON.Vec3(1.5, 0.1, wallDepth))
            });
            funnelWallBody.position.set(x, y, 0);
            funnelWallBody.quaternion.setFromEuler(0, 0, angle);
            world.addBody(funnelWallBody);
        }
        createFunnelWall(-2.5, -boardSize.height/2 + 2, -0.4);
        createFunnelWall(2.5, -boardSize.height/2 + 2, 0.4);


        // Launch Rail (Visual Only)
        const rail = new THREE.Mesh(
            new THREE.BoxGeometry(0.2, boardSize.height * 0.95, 0.2),
            new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.8 })
        );
        rail.position.set(-boardSize.width/2 + 0.3, 0, -0.5);
        scene.add(rail);

        // Pins
        for (let row = 0; row < 12; row++) {
            const isOffset = row % 2 !== 0;
            const pinsInRow = isOffset ? 6 : 7;
            const y = boardSize.height / 2 - 3 - row * 1.1;
            for (let col = 0; col < pinsInRow; col++) {
                const x = -boardSize.width / 2 + 1 + col * 1.2 + (isOffset ? 0.6 : 0);
                
                const pinBody = new CANNON.Body({
                    mass: 0,
                    shape: new CANNON.Cylinder(0.1, 0.1, 1, 8),
                    material: pinMaterial
                });
                pinBody.position.set(x, y, 0);
                pinBody.quaternion.setFromEuler(Math.PI / 2, 0, 0);
                world.addBody(pinBody);

                const pinMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1, 8), pinMeshMaterial);
                pinMesh.position.copy(pinBody.position);
                pinMesh.quaternion.copy(pinBody.quaternion);
                scene.add(pinMesh);
            }
        }
        
        // Pockets
        const pockets = [];
        const pocketWidth = 1.0;
        const pocketHeight = 0.5;
        const pocketPositions = [-3, -1, 1, 3];
        pocketPositions.forEach(x => {
            const pocketBody = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Box(new CANNON.Vec3(pocketWidth / 2, pocketHeight / 2, 0.5)),
                material: pocketMaterial,
                isTrigger: true
            });
            pocketBody.position.set(x, -boardSize.height/2 + pocketHeight, 0);
            world.addBody(pocketBody);
            pocketBody.userData = { type: 'win', points: 10 };

            const pocketMesh = new THREE.Mesh(new THREE.BoxGeometry(pocketWidth, pocketHeight, 1), pocketMeshMaterials.win);
            pocketMesh.position.copy(pocketBody.position);
            scene.add(pocketMesh);
            pockets.push({ body: pocketBody, mesh: pocketMesh });
            
            pocketBody.addEventListener('collide', (e) => handleCollision(e, pocketBody));
        });
        
        // Jackpot Hole
        const jackpotRadius = 0.6;
        const jackpotBody = new CANNON.Body({
            mass: 0,
            shape: new CANNON.Cylinder(jackpotRadius, jackpotRadius, 1, 16),
            material: pocketMaterial,
            isTrigger: true
        });
        jackpotBody.position.set(0, -2.5, 0);
        jackpotBody.quaternion.setFromEuler(Math.PI/2, 0, 0);
        world.addBody(jackpotBody);
        jackpotBody.userData = { type: 'jackpot', points: 50, balls: 10 };
        jackpotBody.addEventListener('collide', (e) => handleCollision(e, jackpotBody));

        const jackpotMesh = new THREE.Mesh(
            new THREE.TorusGeometry(jackpotRadius, 0.15, 16, 100),
            pocketMeshMaterials.jackpot
        );
        jackpotMesh.position.copy(jackpotBody.position);
        jackpotMesh.quaternion.copy(jackpotBody.quaternion);
        scene.add(jackpotMesh);
        
        // Center Spinner
        const spinnerRadius = 1.2;
        const spinnerBody = new CANNON.Body({ mass: 0, type: CANNON.Body.KINEMATIC, material: pinMaterial });
        const spinnerShape = new CANNON.Box(new CANNON.Vec3(spinnerRadius, 0.15, 0.15));
        spinnerBody.addShape(spinnerShape);
        spinnerBody.addShape(spinnerShape, new CANNON.Vec3(), new CANNON.Quaternion().setFromEuler(0,0,Math.PI/2));
        spinnerBody.position.set(0, 0.5, 0);
        world.addBody(spinnerBody);
        
        const spinnerMesh = new THREE.Mesh(new THREE.BoxGeometry(spinnerRadius*2, 0.3, 0.3), pocketMeshMaterials.jackpot.clone());
        const spinnerMesh2 = spinnerMesh.clone();
        spinnerMesh2.rotation.z = Math.PI / 2;
        const spinnerGroup = new THREE.Group();
        spinnerGroup.add(spinnerMesh, spinnerMesh2);
        spinnerGroup.position.copy(spinnerBody.position);
        scene.add(spinnerGroup);

        // --- GAME LOGIC ---
        let score = 0;
        let ballsLeft = 100;
        const scoreEl = document.getElementById('score');
        const ballsEl = document.getElementById('balls');
        const powerSlider = document.getElementById('power-slider');
        const launchButton = document.getElementById('launch-button');
        const messageBox = document.getElementById('message-box');
        const jackpotMessage = document.getElementById('jackpot-message');

        function launchBall() {
            if (ballsLeft <= 0) {
                messageBox.classList.add('show');
                return;
            }
            ballsLeft--;
            updateUI();

            const ballBody = new CANNON.Body({
                mass: 1, shape: new CANNON.Sphere(ballRadius), material: ballMaterial,
                linearDamping: 0.1, angularDamping: 0.1
            });

            const launchPower = parseFloat(powerSlider.value);
            const force = new CANNON.Vec3(launchPower * 0.25, launchPower * 0.85, (Math.random() - 0.5) * 4);
            
            ballBody.position.set(-boardSize.width / 2 + 0.3, -boardSize.height / 2 + 1, 0);
            
            const ballMesh = new THREE.Mesh(new THREE.SphereGeometry(ballRadius, 16, 16), ballMeshMaterial);
            ballMesh.position.copy(ballBody.position);
            
            world.addBody(ballBody);
            scene.add(ballMesh);
            objectsToUpdate.push({ body: ballBody, mesh: ballMesh });

            ballBody.applyImpulse(force, new CANNON.Vec3(0,0,0));
        }

        function handleCollision(event, triggerBody) {
            const ballBody = event.body === triggerBody ? event.target : event.body;
            const objectToRemove = objectsToUpdate.find(obj => obj.body === ballBody);

            if (objectToRemove) {
                const data = triggerBody.userData;
                if (data.type === 'win') {
                    score += data.points;
                    ballsLeft += 2;
                    flashPocket(pockets.find(p => p.body === triggerBody).mesh, 0x39ff14);
                } else if (data.type === 'jackpot') {
                    score += data.points;
                    ballsLeft += data.balls;
                    flashPocket(jackpotMesh, 0xff00ff);
                    showJackpotMessage();
                }
                removeBall(objectToRemove);
                updateUI();
            }
        }
        
        function flashPocket(mesh, color) {
            const originalIntensity = mesh.material.emissiveIntensity;
            mesh.material.emissive.setHex(0xffffff);
            mesh.material.emissiveIntensity = 2;
            setTimeout(() => {
                mesh.material.emissive.setHex(color);
                mesh.material.emissiveIntensity = originalIntensity;
            }, 200);
        }

        function showJackpotMessage() {
            jackpotMessage.classList.add('show');
            setTimeout(() => {
                jackpotMessage.classList.remove('show');
            }, 1500);
        }

        function removeBall(object) {
            world.removeBody(object.body);
            scene.remove(object.mesh);
            object.mesh.geometry.dispose();
            const index = objectsToUpdate.indexOf(object);
            if (index > -1) objectsToUpdate.splice(index, 1);
        }

        function updateUI() {
            scoreEl.textContent = score;
            ballsEl.textContent = ballsLeft;
        }

        launchButton.addEventListener('click', launchBall);

        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();
        let oldElapsedTime = 0;

        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();
            const deltaTime = elapsedTime - oldElapsedTime;
            oldElapsedTime = elapsedTime;

            world.step(1 / 60, deltaTime, 3);

            for (let i = objectsToUpdate.length - 1; i >= 0; i--) {
                const object = objectsToUpdate[i];
                object.mesh.position.copy(object.body.position);
                object.mesh.quaternion.copy(object.body.quaternion);
                if(object.mesh.position.y < -boardSize.height/2 - 2) {
                    removeBall(object);
                    updateUI(); // Update UI when ball is lost
                }
            }
            
            spinnerBody.angularVelocity.set(0, 0, 3);
            spinnerGroup.quaternion.copy(spinnerBody.quaternion);
            
            jackpotMesh.material.emissiveIntensity = 0.7 + Math.sin(elapsedTime * 5) * 0.3;

            renderer.render(scene, camera);
        }

        // --- INITIALIZATION ---
        resize();
        setLanguage('jp');
        updateUI();
        animate();
    </script>
</body>
</html>

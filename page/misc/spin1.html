<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ball in Rotating Hexagon â€¢ Physics Demo</title>
<style>
  :root{
    --bg:#111315;
    --panel:#1c1f22;
    --muted:#9aa4ad;
    --text:#e7edf3;
    --accent:#f59e0b; /* orange ball */
    --line:#a7b0b83d;
  }
  html, body {
    margin:0; height:100%; background:var(--bg); color:var(--text);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Noto Sans, "Apple Color Emoji", "Segoe UI Emoji";
  }
  .controls {
    position:fixed; inset:0 0 auto 0; height:54px; display:flex; align-items:center; gap:16px;
    padding:8px 12px; background:linear-gradient(180deg, #1b1e2140, #1b1e2100), var(--panel);
    border-bottom:1px solid #ffffff10; z-index:10; box-shadow:0 2px 14px #0007;
  }
  .row { display:flex; align-items:center; gap:10px; }
  label { font-size:12px; color:var(--muted); white-space:nowrap; }
  input[type="range"]{ -webkit-appearance:none; width:220px; height:6px; background:#2a2f35; border-radius:999px; outline:none; }
  input[type="range"]::-webkit-slider-thumb{ -webkit-appearance:none; width:14px; height:14px; border-radius:50%; background:#bcd4ff; border:1px solid #ffffff60; box-shadow:0 1px 4px #0008; }
  .value{ min-width:72px; text-align:right; font-variant-numeric: tabular-nums; color:#cfe3f7; font-size:12px; }
  button#reset { margin-left:auto; background:#2a3036; color:#e7edf3; border:1px solid #ffffff20; border-radius:10px; padding:8px 12px; font-weight:600; cursor:pointer; }
  button#reset:hover{ background:#343b42; }
  canvas{ display:block; position:fixed; inset:54px 0 0 0; width:100%; height:calc(100% - 54px); }
</style>
</head>
<body>
  <div class="controls">
    <div class="row">
      <label for="spin">Spin</label>
      <input id="spin" type="range" min="-3" max="3" step="0.01" value="1.2" />
      <div class="value"><span id="spinVal">1.20</span> rad/s</div>
    </div>
    <div class="row">
      <label for="elasticity">Elasticity</label>
      <input id="elasticity" type="range" min="0" max="1" step="0.01" value="0.98" />
      <div class="value"><span id="restitutionVal">0.98</span></div>
    </div>
    <div class="row">
      <label for="friction">Friction</label>
      <input id="friction" type="range" min="0" max="1" step="0.01" value="0.02" />
      <div class="value"><span id="frictionVal">0.02</span></div>
    </div>
    <div class="row">
      <label for="gravity">Gravity</label>
      <input id="gravity" type="range" min="0" max="2000" step="10" value="800" />
      <div class="value"><span id="gravityVal">800</span></div>
    </div>
    <div class="row">
      <label for="ballsize">Ball size</label>
      <input id="ballsize" type="range" min="6" max="40" step="1" value="16" />
      <div class="value"><span id="ballsizeVal">16</span> px</div>
    </div>
    <button id="reset">Reset</button>
  </div>
  <canvas id="c"></canvas>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const ui = {
    spin: document.getElementById('spin'),
    elasticity: document.getElementById('elasticity'),
    friction: document.getElementById('friction'),
    gravity: document.getElementById('gravity'),
    r: document.getElementById('ballsize'),
    spinVal: document.getElementById('spinVal'),
    restVal: document.getElementById('restitutionVal'),
    fricVal: document.getElementById('frictionVal'),
    gravVal: document.getElementById('gravityVal'),
    rVal: document.getElementById('ballsizeVal'),
    reset: document.getElementById('reset'),
  };

  const state = {
    width: 0, height: 0,
    center: {x:0, y:0},
    polyR: 240, // polygon circumradius
    polySides: 6,
    theta: 0, // current rotation
    omega: parseFloat(ui.spin.value),
    e: parseFloat(ui.elasticity.value),
    mu: parseFloat(ui.friction.value),
    g: parseFloat(ui.gravity.value),
    ball: {x:0, y:0, vx:0, vy:0, r: parseFloat(ui.r.value)},
    lastT: performance.now(),
  };

  function resize(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(canvas.clientWidth * dpr);
    canvas.height = Math.floor(canvas.clientHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    state.width = canvas.clientWidth;
    state.height = canvas.clientHeight;
    state.center.x = state.width/2;
    state.center.y = state.height/2;
    // fit polygon radius with some margin
    state.polyR = Math.min(state.width, state.height) * 0.33;
  }

  function resetBall(){
    const c = state.center;
    state.ball.r = parseFloat(ui.r.value);
    // place slightly above the bottom inside the polygon
    state.ball.x = c.x + 0;
    state.ball.y = c.y + state.polyR * 0.4;
    state.ball.vx = 0;
    state.ball.vy = 0;
  }

  function updateUiLabels(){
    ui.spinVal.textContent = (+ui.spin.value).toFixed(2);
    ui.restVal.textContent = (+ui.elasticity.value).toFixed(2);
    ui.fricVal.textContent = (+ui.friction.value).toFixed(2);
    ui.gravVal.textContent = Math.round(+ui.gravity.value);
    ui.rVal.textContent = Math.round(+ui.r.value);
  }

  // bind UI events
  ui.spin.addEventListener('input', () => state.omega = +ui.spin.value);
  ui.elasticity.addEventListener('input', () => state.e = +ui.elasticity.value);
  ui.friction.addEventListener('input', () => state.mu = +ui.friction.value);
  ui.gravity.addEventListener('input', () => state.g = +ui.gravity.value);
  ui.r.addEventListener('input', () => { state.ball.r = +ui.r.value; updateUiLabels(); });
  ui.reset.addEventListener('click', () => { resetBall(); });

  // Helpers ---------------------------------------------------------------
  function polyVertices(cx, cy, r, sides, theta){
    const verts = [];
    for(let i=0;i<sides;i++){
      const a = theta + i * (Math.PI*2/sides);
      verts.push({ x: cx + r*Math.cos(a), y: cy + r*Math.sin(a) });
    }
    return verts;
  }

  function closestPointOnSegment(ax, ay, bx, by, px, py){
    const abx = bx - ax, aby = by - ay;
    const apx = px - ax, apy = py - ay;
    const ab2 = abx*abx + aby*aby || 1e-9;
    let t = (apx*abx + apy*aby) / ab2;
    t = Math.max(0, Math.min(1, t));
    return { x: ax + abx*t, y: ay + aby*t, t };
  }

  // Animation -------------------------------------------------------------
  function step(now){
    const dt = Math.min(0.033, (now - state.lastT) / 1000); // clamp 30ms
    state.lastT = now;

    // Integrate rotation and gravity
    state.theta += state.omega * dt;

    const b = state.ball;
    b.vy += state.g * dt; // gravity downwards
    b.x += b.vx * dt;
    b.y += b.vy * dt;

    // Collide with rotating polygon walls
    const C = state.center;
    const verts = polyVertices(C.x, C.y, state.polyR, state.polySides, state.theta);

    for(let i=0;i<verts.length;i++){
      const a = verts[i];
      const c = verts[(i+1)%verts.length];

      // Find closest point on edge to ball center
      const q = closestPointOnSegment(a.x,a.y,c.x,c.y,b.x,b.y);
      const dx = b.x - q.x, dy = b.y - q.y;
      const dist = Math.hypot(dx,dy);
      if (dist === 0) continue;
      if (dist < b.r){
        // penetration
        const nX = dx / dist, nY = dy / dist; // normal from edge -> center
        const penetration = b.r - dist;
        // position correction (de-penetrate)
        b.x += nX * penetration;
        b.y += nY * penetration;

        // wall velocity at contact (due to rotation of polygon)
        // rvec from polygon center to contact point q
        const rx = q.x - C.x, ry = q.y - C.y;
        // omega k x r = (-omega * ry, omega * rx)
        const vwX = -state.omega * ry;
        const vwY =  state.omega * rx;

        // relative velocity at contact
        let vrelX = b.vx - vwX;
        let vrelY = b.vy - vwY;

        // decompose into normal and tangential components
        const vn = vrelX * nX + vrelY * nY; // scalar along normal
        let vtX = vrelX - vn * nX;
        let vtY = vrelY - vn * nY;

        // bounce with restitution
        const vnAfter = -state.e * vn;
        // apply simple tangential friction (damping)
        vtX *= (1 - state.mu);
        vtY *= (1 - state.mu);

        // combine and convert back to world by adding wall velocity
        vrelX = vnAfter * nX + vtX;
        vrelY = vnAfter * nY + vtY;

        b.vx = vrelX + vwX;
        b.vy = vrelY + vwY;
      }
    }

    draw(verts);
    requestAnimationFrame(step);
  }

  function draw(verts){
    const w = state.width, h = state.height;
    ctx.clearRect(0,0,w,h);

    // subtle vignette background
    const grd = ctx.createRadialGradient(w/2,h/2, Math.min(w,h)*0.1, w/2,h/2, Math.max(w,h)*0.8);
    grd.addColorStop(0, '#0f1214');
    grd.addColorStop(1, '#0b0d0f');
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,w,h);

    // polygon outline
    ctx.beginPath();
    verts.forEach((p, i) => {
      if (i===0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
    });
    ctx.closePath();
    ctx.strokeStyle = '#ffffff99';
    ctx.lineWidth = 2;
    ctx.stroke();

    // ball
    const b = state.ball;
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
    ctx.shadowColor = '#000';
    ctx.shadowBlur = 6;
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  // init
  function init(){
    resize();
    updateUiLabels();
    resetBall();
    window.addEventListener('resize', () => { resize(); });
    state.lastT = performance.now();
    requestAnimationFrame(step);
  }

  init();
})();
</script>
</body>
</html>

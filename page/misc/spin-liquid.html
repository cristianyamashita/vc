<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Liquid Spin — Physics Sandbox</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.3/p5.min.js"></script>
<style>
  :root {
    --panel-bg: #111518;
    --panel-fg: #e6eef5;
    --accent: #49a3ff;
    --muted: #7e8a97;
  }
  html, body { height: 100%; margin: 0; background:#0b0f12; color: var(--panel-fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Noto Sans", "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"; }
  #ui {
    position: fixed; top: 0; left: 0; right: 0;
    background: linear-gradient(180deg, rgba(10,14,18,.95), rgba(10,14,18,.80));
    backdrop-filter: blur(6px);
    border-bottom: 1px solid rgba(255,255,255,.06);
    z-index: 10;
  }
  #controls {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    gap: 10px 14px;
    padding: 10px 12px 12px;
    align-items: center;
  }
  .ctrl { display:flex; gap:10px; align-items:center; }
  .ctrl label { width: 175px; color: var(--muted); font-size: 12px; }
  .ctrl input[type="range"] { flex: 1; }
  .ctrl input[type="number"] { width: 80px; background:#0b0f12; border:1px solid #2a333b; color:var(--panel-fg); border-radius:6px; padding:4px 6px; }
  .palette { display:flex; gap:8px; flex-wrap:wrap; }
  .palette input[type="color"] { width: 36px; height: 28px; padding: 0; }
  .row {
    display:flex; gap:12px; align-items:center; padding: 8px 12px 12px;
    border-top: 1px solid rgba(255,255,255,.06);
  }
  button, select, input[type="color"] {
    background:#12181e; color:var(--panel-fg); border:1px solid #2d3740; border-radius:10px; padding:8px 12px; cursor:pointer;
  }
  button:hover { border-color: var(--accent); }
  #stats { margin-left:auto; color:var(--muted); font-variant-numeric: tabular-nums; }
  canvas { display:block; }
  /* keep canvas under the panel */
  #sketch-holder { position: fixed; inset: 56px 0 0 0; }
  @media (max-width: 980px) {
    #sketch-holder { inset: 92px 0 0 0; }
  }
</style>
</head>
<body>
<div id="ui">
  <div id="controls"></div>
  <div class="row">
    <button id="toggleBtn" data-lang="toggleBtn">Pause</button>
    <button id="resetBtn" data-lang="resetBtn">Reset</button>
    <select id="langSelector">
      <option value="en">English</option>
      <option value="pt">Português</option>
      <option value="ja">日本語</option>
    </select>
    <span id="stats">FPS: -- | Balls: --</span>
  </div>
</div>
<div id="sketch-holder"></div>

<script>
/* ======== Language State ======== */
const translations = {
  en: {
    title: "Liquid Spin — Physics Sandbox",
    numBalls: "Number of particles",
    radiusPx: "Particle size (px)",
    massVar: "Particle mass variability",
    eWall: "Container elasticity",
    eBall: "Particle elasticity",
    gravity: "Gravity strength",
    friction: "Viscosity (friction)",
    air: "Fluid resistance",
    spin: "Container spin (rad/s)",
    speedMul: "Initial speed multiplier",
    trails: "Enable trails",
    hexStroke: "Container stroke thickness",
    bg: "Background color",
    colorMode: "Particle color mode",
    colorMode_random: "Random",
    colorMode_uniform: "Uniform",
    colorMode_palette: "Palette",
    ballColor: "Uniform particle color",
    palette: "Palette colors",
    toggleBtn: "Pause",
    toggleBtn_start: "Start",
    resetBtn: "Reset",
    stats_fps: "FPS",
    stats_balls: "Particles",
  },
  pt: {
    title: "Giro Líquido — Sandbox de Física",
    numBalls: "Número de partículas",
    radiusPx: "Tamanho da partícula (px)",
    massVar: "Variabilidade de massa",
    eWall: "Elasticidade do recipiente",
    eBall: "Elasticidade da partícula",
    gravity: "Força da gravidade",
    friction: "Viscosidade (fricção)",
    air: "Resistência do fluido",
    spin: "Giro do recipiente (rad/s)",
    speedMul: "Multiplicador de velocidade inicial",
    trails: "Habilitar rastros",
    hexStroke: "Espessura da borda do recipiente",
    bg: "Cor de fundo",
    colorMode: "Modo de cor da partícula",
    colorMode_random: "Aleatório",
    colorMode_uniform: "Uniforme",
    colorMode_palette: "Paleta",
    ballColor: "Cor uniforme da partícula",
    palette: "Cores da paleta",
    toggleBtn: "Pausar",
    toggleBtn_start: "Iniciar",
    resetBtn: "Reiniciar",
    stats_fps: "FPS",
    stats_balls: "Partículas",
  },
  ja: {
    title: "液体スピン — 物理サンドボックス",
    numBalls: "パーティクル数",
    radiusPx: "パーティクルサイズ (px)",
    massVar: "パーティクル質量のばらつき",
    eWall: "容器の弾性",
    eBall: "パーティクルの弾性",
    gravity: "重力",
    friction: "粘性（摩擦）",
    air: "流体抵抗",
    spin: "容器の回転 (rad/s)",
    speedMul: "初期速度の乗数",
    trails: "軌跡を有効にする",
    hexStroke: "容器の線の太さ",
    bg: "背景色",
    colorMode: "パーティクルのカラーモード",
    colorMode_random: "ランダム",
    colorMode_uniform: "均一",
    colorMode_palette: "パレット",
    ballColor: "均一なパーティクルカラー",
    palette: "パレットの色",
    toggleBtn: "一時停止",
    toggleBtn_start: "開始",
    resetBtn: "リセット",
    stats_fps: "FPS",
    stats_balls: "パーティクル",
  }
};
let currentLang = 'en';

function setLanguage(lang) {
  currentLang = lang;
  document.documentElement.lang = lang;
  const t = translations[lang];
  document.title = t.title;
  // Update all UI elements
  document.querySelectorAll('[data-lang]').forEach(el => {
    const key = el.getAttribute('data-lang');
    if (t[key]) {
      if (el.tagName === 'BUTTON' || el.tagName === 'LABEL' || el.tagName === 'OPTION') {
        el.textContent = t[key];
      }
    }
  });
  // Special cases for controls
  for (const key in UI) {
    if (t[key] && UI[key].label) {
      UI[key].label.textContent = t[key];
    }
    if (key === 'colorMode' && UI[key].sel) {
      UI[key].sel.options[0].textContent = t.colorMode_random;
      UI[key].sel.options[1].textContent = t.colorMode_uniform;
      UI[key].sel.options[2].textContent = t.colorMode_palette;
    }
  }
  // Update toggle button text based on state
  const toggleBtn = document.getElementById('toggleBtn');
  if (running) {
    toggleBtn.textContent = t.toggleBtn;
  } else {
    toggleBtn.textContent = t.toggleBtn_start;
  }
}


/* ======== Simulation State ======== */
let params = {
  numBalls: 35,
  radiusPx: 22,
  massVar: true,
  eWall: 0.2,
  eBall: 0.3,
  gravity: 4.0,
  friction: 0.2,     // tangential damping on wall hit + global linear damping
  air: 0.08,          // per-second velocity damping
  spin: 1.0,          // rad/s
  speedMul: 1.0,
  trails: false,
  hexStroke: 4,
  bg: '#0b0f12',
  colorMode: 'palette',        // 'random' | 'uniform' | 'palette'
  ballColor: '#2563eb',       // used when colorMode = 'uniform'
  palette: ['#2563eb', '#3b82f6', '#60a5fa'],
};

let running = true;
let hex = {
  angle: 0,           // current hexagon angle (radians)
  omega: params.spin, // rad/s
  R: 0,               // circumradius (draw)
  center: null,       // p5.Vector
  vertices: [],       // world-space vertices this frame
  edges: []           // edges with normals this frame
};

const balls = [];
let lastMillis;
let fpsEMA = 0;
let metaballLayer;

/* ======== UI ======== */
const UI = {};
function addRange(label, key, min, max, step, fmt = (v)=>v) {
  const wrap = document.createElement('div'); wrap.className = 'ctrl';
  const lab = document.createElement('label'); lab.textContent = label; lab.setAttribute('data-lang', key); wrap.appendChild(lab);
  const slider = document.createElement('input'); slider.type='range'; slider.min=min; slider.max=max; slider.step=step; slider.value=params[key];
  const num = document.createElement('input'); num.type='number'; num.min=min; num.max=max; num.step=step; num.value=params[key];
  slider.oninput = ()=>{ num.value = slider.value; onParam(key, Number(slider.value)); };
  num.onchange = ()=>{ slider.value = num.value; onParam(key, Number(num.value)); };
  wrap.appendChild(slider); wrap.appendChild(num);
  document.getElementById('controls').appendChild(wrap);
  UI[key] = { slider, num, set(v){ slider.value=v; num.value=v; } };
}
function addToggle(label, key) {
  const wrap = document.createElement('div'); wrap.className = 'ctrl';
  const lab = document.createElement('label'); lab.textContent = label; lab.setAttribute('data-lang', key); wrap.appendChild(lab);
  const box = document.createElement('input'); box.type='checkbox'; box.checked=params[key];
  box.onchange = ()=> onParam(key, box.checked);
  wrap.appendChild(box);
  document.getElementById('controls').appendChild(wrap);
  UI[key] = { box, label: lab, set(v){ box.checked = v; } };
}
function addColor(label, key) {
  const wrap = document.createElement('div'); wrap.className = 'ctrl';
  const lab = document.createElement('label'); lab.textContent = label; lab.setAttribute('data-lang', key); wrap.appendChild(lab);
  const input = document.createElement('input'); input.type='color'; input.value=params[key];
  input.oninput = ()=> onParam(key, input.value);
  wrap.appendChild(input);
  document.getElementById('controls').appendChild(wrap);
  UI[key] = { input, label: lab, set(v){ input.value = v; } };
}

function addSelect(label, key, options) {
  const wrap = document.createElement('div'); wrap.className = 'ctrl';
  const lab = document.createElement('label'); lab.textContent = label; lab.setAttribute('data-lang', key); wrap.appendChild(lab);
  const sel = document.createElement('select');
  for (const opt of options) {
    const o = document.createElement('option');
    o.value = opt.value; o.textContent = opt.label;
    if (opt.value === params[key]) o.selected = true;
    sel.appendChild(o);
  }
  sel.onchange = ()=> onParam(key, sel.value);
  wrap.appendChild(sel);
  document.getElementById('controls').appendChild(wrap);
  UI[key] = { sel, label: lab, set(v){ sel.value = v; } };
}

function addPalette(labelPrefix, key) {
  const wrap = document.createElement('div'); wrap.className = 'ctrl';
  const lab = document.createElement('label'); lab.textContent = labelPrefix; lab.setAttribute('data-lang', key); wrap.appendChild(lab);
  const holder = document.createElement('div'); holder.className = 'palette';
  wrap.appendChild(holder);
  const inputs = [];
  params[key].forEach((col, idx) => {
    const input = document.createElement('input');
    input.type = 'color'; input.value = col;
    input.title = `Palette ${idx+1}`;
    input.oninput = ()=> { params[key][idx] = input.value; };
    holder.appendChild(input);
    inputs.push(input);
  });
  document.getElementById('controls').appendChild(wrap);
  UI[key] = { inputs, label: lab, set(arr){ arr.forEach((v,i)=>{ if (inputs[i]) inputs[i].value=v; }); } };
}

function onParam(key, val) {
  params[key] = val;
  if (key === 'numBalls') syncBallCount();
  if (key === 'radiusPx') updateBallSizes();
  if (key === 'massVar' || key === 'radiusPx') updateBallMasses();
  if (key === 'spin') hex.omega = val;
  if (key === 'bg') { /* background set next draw */ }
  if (key === 'hexStroke') { /* draw-time */ }
}

addRange('Number of balls',      'numBalls', 1, 200, 1);
addRange('Ball size (px)',       'radiusPx', 1, 30, 1);
addToggle('Ball mass variability','massVar');
addRange('Wall elasticity',      'eWall', 0, 1, 0.01);
addRange('Ball-ball elasticity', 'eBall', 0, 1, 0.01);
addRange('Gravity strength',     'gravity', 0, 10, 0.1);
addRange('Friction',             'friction', 0, 1, 0.01);
addRange('Air resistance',       'air', 0, 1, 0.01);
addRange('Hexagon spin (rad/s)', 'spin', -5, 5, 0.01);
addRange('Initial speed x',      'speedMul', 0, 5, 0.1);
addToggle('Enable trails',       'trails');
addRange('Hex stroke thickness', 'hexStroke', 0, 12, 1);
addColor('Background color',     'bg');

// Color controls
addSelect('Ball color mode', 'colorMode', [
  { value: 'random', label: 'Random' },
  { value: 'uniform', label: 'Uniform' },
  { value: 'palette', label: 'Palette' },
]);
addColor('Uniform ball color', 'ballColor');
addPalette('Palette colors', 'palette');

document.getElementById('toggleBtn').onclick = () => {
  running = !running;
  const t = translations[currentLang];
  document.getElementById('toggleBtn').textContent = running ? t.toggleBtn : t.toggleBtn_start;
};
document.getElementById('resetBtn').onclick = () => resetSim();
document.getElementById('langSelector').onchange = (e) => {
  setLanguage(e.target.value);
};


/* ======== p5 Sketch ======== */
new p5((p) => {
  p.setup = function() {
    // Set initial language from browser, if available
    const userLang = navigator.language.split('-')[0];
    if (translations[userLang]) {
      document.getElementById('langSelector').value = userLang;
      setLanguage(userLang);
    } else {
      setLanguage('en');
    }

    const holder = document.getElementById('sketch-holder');
    const c = p.createCanvas(holder.clientWidth, holder.clientHeight);
    c.parent(holder);
    metaballLayer = p.createGraphics(p.width, p.height);

    hex.center = p.createVector(p.width/2, p.height/2);
    recalcHexRadius();
    initBalls(params.numBalls);
    lastMillis = p.millis();
    p.frameRate(120);
  };

  p.windowResized = function() {
    const holder = document.getElementById('sketch-holder');
    p.resizeCanvas(holder.clientWidth, holder.clientHeight);
    metaballLayer.resizeCanvas(p.width, p.height);
    hex.center.set(p.width/2, p.height/2);
    recalcHexRadius();
    // keep balls inside after resize
    for (const b of balls) clampInsideHex(b);
  };

  p.draw = function() {
    const now = p.millis();
    const dt = Math.min(0.033, (now - lastMillis) / 1000); // clamp to avoid huge steps
    lastMillis = now;

    // fps smoothing
    const inst = 1/dt;
    fpsEMA = fpsEMA ? p.lerp(fpsEMA, inst, 0.1) : inst;

    // update rotating hexagon
    if (running) hex.angle += hex.omega * dt;
    updateHexGeometry(p);

    // physics step
    if (running) stepPhysics(p, dt);

    // METABALL RENDER
    // 1. Draw blurred circles to offscreen buffer
    metaballLayer.background(0, 0, 0, 0);
    metaballLayer.fill(255);
    metaballLayer.noStroke();

    for (const b of balls) {
      metaballLayer.circle(b.pos.x, b.pos.y, b.r*2);
    }

    metaballLayer.filter(p.BLUR, 32);
    metaballLayer.filter(p.THRESHOLD, 0.45);

    // 2. Draw the background
    if (params.trails) {
      p.fill(p.color(params.bg + '33')); // translucent trail
      p.noStroke();
      p.rect(0,0,p.width,p.height);
    } else {
      p.background(params.bg);
    }

    // 3. Draw the liquid using the metaball layer as a mask
    p.push();
    const liquidColor = p.color(params.palette[0] || params.ballColor);
    p.fill(liquidColor);
    p.noStroke();
    // Create a new image with the mask applied
    let masked = p.createImage(p.width, p.height);
    masked.copy(metaballLayer, 0, 0, p.width, p.height, 0, 0, p.width, p.height);
    // This is a trick: apply the mask to itself with a color
    masked.mask(metaballLayer);
    p.image(masked, 0, 0);
    p.pop();

    // 4. Draw hexagon container on top
    p.push();
    p.noFill();
    p.stroke(200,220,255);
    p.strokeWeight(params.hexStroke);
    p.beginShape();
    for (const v of hex.vertices) p.vertex(v.x, v.y);
    p.endShape(p.CLOSE);
    p.pop();

    // stats
    const t = translations[currentLang];
    document.getElementById('stats').textContent =
      `${t.stats_fps}: ${fpsEMA.toFixed(0)} | ${t.stats_balls}: ${balls.length}`;
  };
});

/* ======== Helpers & Physics ======== */

function recalcHexRadius() {
  // Leave margin for UI panel and stroke
  const margin = 24 + Math.max(2, params.hexStroke);
  const usableW = window.innerWidth - margin*2;
  const usableH = (window.innerHeight - document.getElementById('ui').offsetHeight) - margin*2;
  // circumradius R from center to vertex
  hex.R = 0.45 * Math.min(usableW, usableH);
}

function updateHexGeometry(p) {
  hex.vertices.length = 0;
  hex.edges.length = 0;
  const C = hex.center;
  // Regular hexagon (CCW), starting at angle offset so one edge is flat-ish
  for (let i = 0; i < 6; i++) {
    const a = hex.angle + i * (Math.PI/3);
    hex.vertices.push(p.createVector(
      C.x + hex.R * Math.cos(a),
      C.y + hex.R * Math.sin(a)
    ));
  }
  // edges with inward normals
  for (let i = 0; i < 6; i++) {
    const v0 = hex.vertices[i];
    const v1 = hex.vertices[(i+1)%6];
    const edge = p5.Vector.sub(v1, v0);
    let n = createPerp(edge); // candidate normal
    n.normalize();
    const mid = p5.Vector.add(v0, v1).mult(0.5);
    const toCenter = p5.Vector.sub(hex.center, mid);
    if (p5.Vector.dot(n, toCenter) < 0) n.mult(-1); // ensure inward
    hex.edges[i] = { v0, v1, n, mid };
  }
}

// 2D perpendicular: (x,y) -> (-y, x)
function createPerp(v) { return new p5.Vector(-v.y, v.x); }

function initBalls(n) {
  balls.length = 0;
  for (let i = 0; i < n; i++) balls.push(makeBall());
}

function syncBallCount() {
  const target = Math.max(1, Math.min(200, Math.floor(params.numBalls)));
  while (balls.length < target) balls.push(makeBall());
  while (balls.length > target) balls.pop();
}

function updateBallSizes() {
  for (const b of balls) { b.r = params.radiusPx; }
}

function updateBallMasses() {
  for (const b of balls) {
    const base = Math.PI * b.r * b.r;
    b.m = params.massVar ? base * (0.5 + Math.random()) : base;
    b.inv = 1 / b.m;
  }
}

function makeBall() {
  const r = params.radiusPx;
  // place roughly inside hex
  let pos;
  for (let tries=0; tries<1000; tries++) {
    const angle = Math.random()*2*Math.PI;
    const rad = (hex.R - r - 4) * Math.sqrt(Math.random());
    pos = createVector(hex.center.x + rad*Math.cos(angle), hex.center.y + rad*Math.sin(angle));
    if (insideHex(pos, r)) break;
  }
  const v = p5.Vector.random2D().mult(60 * params.speedMul);
  const base = Math.PI*r*r;
  const m = params.massVar ? base * (0.5 + Math.random()) : base;
  return {
    pos, vel: v, r,
    m, inv: 1/m
  };
}

function clampInsideHex(b) {
  // push inward if outside/overlapping
  for (const e of hex.edges) {
    const d = p5.Vector.dot(p5.Vector.sub(b.pos, e.v0), e.n);
    if (d < b.r) {
      const push = (b.r - d) + 0.1;
      b.pos.add(p5.Vector.mult(e.n, push));
    }
  }
}

function insideHex(p, r=0) {
  for (const e of hex.edges) {
    const d = p5.Vector.dot(p5.Vector.sub(p, e.v0), e.n);
    if (d < r) return false;
  }
  return true;
}

function resetSim() {
  hex.angle = 0;
  hex.omega = params.spin;
  initBalls(params.numBalls);
}

function stepPhysics(p, dt) {
  const g = new p5.Vector(0, params.gravity * 100); // px/s^2 for noticeable gravity
  const globalDamp = Math.max(0, Math.min(1, params.air));
  const friction = Math.max(0, Math.min(1, params.friction));

  // integrate + drag
  for (const b of balls) {
    // Air resistance (approx: exponential -> linearized)
    b.vel.mult(Math.max(0, 1 - globalDamp * dt));
    // Gravity
    b.vel.add(p5.Vector.mult(g, dt));
    // Integrate
    b.pos.add(p5.Vector.mult(b.vel, dt));
  }

  // wall collisions (with rotating wall velocity)
  for (const b of balls) {
    for (const e of hex.edges) {
      const rel = p5.Vector.sub(b.pos, e.v0);
      const d = p5.Vector.dot(rel, e.n); // inward distance from line
      if (d < b.r) {
        // positional correction
        const corr = (b.r - d) + 0.01;
        b.pos.add(p5.Vector.mult(e.n, corr));

        // contact point on wall (foot of perpendicular)
        const q = p5.Vector.sub(b.pos, p5.Vector.mult(e.n, b.r));

        // wall velocity due to rotation: v_w = ω × r (2D)
        const rvec = p5.Vector.sub(q, hex.center);
        const vwall = new p5.Vector(-hex.omega * rvec.y, hex.omega * rvec.x);

        // relative velocity
        const vrel = p5.Vector.sub(b.vel, vwall);
        const vn = p5.Vector.dot(vrel, e.n);
        // reflect only if approaching
        if (vn < 0) {
          const eCoef = params.eWall;
          // Split into normal / tangential
          const vN = p5.Vector.mult(e.n, vn);
          const vT = p5.Vector.sub(vrel, vN);
          // restitution on normal, friction (tangential damping)
          const vrelAfter = p5.Vector.add(
            p5.Vector.mult(vN, -eCoef),
            p5.Vector.mult(vT, Math.max(0, 1 - friction))
          );
          // back to world frame
          b.vel = p5.Vector.add(vrelAfter, vwall);
        }
      }
    }
  }

  // ball-ball collisions (impulse-based, frictionless with restitution)
  for (let i = 0; i < balls.length; i++) {
    for (let j = i+1; j < balls.length; j++) {
      const A = balls[i], B = balls[j];
      const delta = p5.Vector.sub(B.pos, A.pos);
      const dist2 = delta.x*delta.x + delta.y*delta.y;
      const rSum = A.r + B.r;
      if (dist2 > 0 && dist2 < rSum*rSum) {
        const dist = Math.sqrt(dist2);
        const n = p5.Vector.mult(delta, 1/dist); // from A to B
        // separate positions (baumgarte style)
        const penetration = rSum - dist + 0.01;
        const totalInv = A.inv + B.inv;
        if (totalInv > 0) {
          const corr = penetration / totalInv;
          A.pos.add(p5.Vector.mult(n, -corr * A.inv));
          B.pos.add(p5.Vector.mult(n,  corr * B.inv));
        }
        // relative velocity along normal
        const relv = p5.Vector.sub(B.vel, A.vel);
        const vrn = p5.Vector.dot(relv, n);
        if (vrn < 0) {
          const eCoef = params.eBall;
          const jImpulse = -(1 + eCoef) * vrn / (A.inv + B.inv);
          const J = p5.Vector.mult(n, jImpulse);
          A.vel.add(p5.Vector.mult(J, -A.inv));
          B.vel.add(p5.Vector.mult(J,  B.inv));
        }
      }
    }
  }

  // keep inside after interactions (robustness)
  for (const b of balls) clampInsideHex(b);
}

/* ======== Tiny p5 helpers in global scope ======== */
function createVector(x,y){ return new p5.Vector(x,y); }
</script>
</body>
</html>
